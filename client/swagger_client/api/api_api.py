# coding: utf-8

"""
    MLPlayground

    API  # noqa: E501

    OpenAPI spec version: 0.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class ApiApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_lumisection(self, **kwargs):  # noqa: E501
        """create_lumisection  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_lumisection(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Lumisection body:
        :return: Lumisection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_lumisection_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_lumisection_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_lumisection_with_http_info(self, **kwargs):  # noqa: E501
        """create_lumisection  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_lumisection_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Lumisection body:
        :return: Lumisection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_lumisection" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'ls_number' in params:
            form_params.append(('ls_number', params['ls_number']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'ls_number' in params:
            form_params.append(('ls_number', params['ls_number']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisections/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Lumisection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_lumisection(self, **kwargs):  # noqa: E501
        """create_lumisection  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_lumisection(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str run2:
        :param int ls_number2:
        :param datetime _date2:
        :param str run:
        :param int ls_number:
        :param datetime _date:
        :return: Lumisection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_lumisection_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_lumisection_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_lumisection_with_http_info(self, **kwargs):  # noqa: E501
        """create_lumisection  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_lumisection_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str run2:
        :param int ls_number2:
        :param datetime _date2:
        :param str run:
        :param int ls_number:
        :param datetime _date:
        :return: Lumisection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['run2', 'ls_number2', '_date2', 'run', 'ls_number', '_date']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_lumisection" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'ls_number' in params:
            form_params.append(('ls_number', params['ls_number']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'ls_number' in params:
            form_params.append(('ls_number', params['ls_number']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisections/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Lumisection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_lumisection(self, **kwargs):  # noqa: E501
        """create_lumisection  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_lumisection(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str run2:
        :param int ls_number2:
        :param datetime _date2:
        :param str run:
        :param int ls_number:
        :param datetime _date:
        :return: Lumisection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_lumisection_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_lumisection_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_lumisection_with_http_info(self, **kwargs):  # noqa: E501
        """create_lumisection  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_lumisection_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str run2:
        :param int ls_number2:
        :param datetime _date2:
        :param str run:
        :param int ls_number:
        :param datetime _date:
        :return: Lumisection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['run2', 'ls_number2', '_date2', 'run', 'ls_number', '_date']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_lumisection" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'ls_number' in params:
            form_params.append(('ls_number', params['ls_number']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'ls_number' in params:
            form_params.append(('ls_number', params['ls_number']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisections/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Lumisection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_lumisection_certification(self, **kwargs):  # noqa: E501
        """create_lumisection_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_lumisection_certification(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LumisectionCertification body:
        :return: LumisectionCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_lumisection_certification_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_lumisection_certification_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_lumisection_certification_with_http_info(self, **kwargs):  # noqa: E501
        """create_lumisection_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_lumisection_certification_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LumisectionCertification body:
        :return: LumisectionCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_lumisection_certification" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_golden_json' in params:
            form_params.append(('rr_is_golden_json', params['rr_is_golden_json']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            form_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            form_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            form_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            form_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            form_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            form_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            form_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            form_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            form_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            form_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            form_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            form_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_golden_json' in params:
            form_params.append(('rr_is_golden_json', params['rr_is_golden_json']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            form_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            form_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            form_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            form_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            form_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            form_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            form_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            form_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            form_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            form_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            form_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            form_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisection_certifications/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LumisectionCertification',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_lumisection_certification(self, **kwargs):  # noqa: E501
        """create_lumisection_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_lumisection_certification(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param datetime _date2:
        :param bool rr_is_golden_json2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param int id:
        :param int run:
        :param int lumisection:
        :param datetime _date:
        :param bool rr_is_golden_json:
        :param bool rr_is_pixel_good:
        :param bool rr_is_strip_good:
        :param bool rr_is_ecal_good:
        :param bool rr_is_hcal_good:
        :param bool rr_is_dt_good:
        :param bool rr_is_csc_good:
        :param bool rr_is_tracking_good:
        :param bool rr_is_muon_good:
        :param bool rr_is_egamma_good:
        :param bool rr_is_tau_good:
        :param bool rr_is_jetmet_good:
        :param bool rr_is_btag_good:
        :return: LumisectionCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_lumisection_certification_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_lumisection_certification_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_lumisection_certification_with_http_info(self, **kwargs):  # noqa: E501
        """create_lumisection_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_lumisection_certification_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param datetime _date2:
        :param bool rr_is_golden_json2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param int id:
        :param int run:
        :param int lumisection:
        :param datetime _date:
        :param bool rr_is_golden_json:
        :param bool rr_is_pixel_good:
        :param bool rr_is_strip_good:
        :param bool rr_is_ecal_good:
        :param bool rr_is_hcal_good:
        :param bool rr_is_dt_good:
        :param bool rr_is_csc_good:
        :param bool rr_is_tracking_good:
        :param bool rr_is_muon_good:
        :param bool rr_is_egamma_good:
        :param bool rr_is_tau_good:
        :param bool rr_is_jetmet_good:
        :param bool rr_is_btag_good:
        :return: LumisectionCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id2', 'run2', 'lumisection2', '_date2', 'rr_is_golden_json2', 'rr_is_pixel_good2', 'rr_is_strip_good2', 'rr_is_ecal_good2', 'rr_is_hcal_good2', 'rr_is_dt_good2', 'rr_is_csc_good2', 'rr_is_tracking_good2', 'rr_is_muon_good2', 'rr_is_egamma_good2', 'rr_is_tau_good2', 'rr_is_jetmet_good2', 'rr_is_btag_good2', 'id', 'run', 'lumisection', '_date', 'rr_is_golden_json', 'rr_is_pixel_good', 'rr_is_strip_good', 'rr_is_ecal_good', 'rr_is_hcal_good', 'rr_is_dt_good', 'rr_is_csc_good', 'rr_is_tracking_good', 'rr_is_muon_good', 'rr_is_egamma_good', 'rr_is_tau_good', 'rr_is_jetmet_good', 'rr_is_btag_good']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_lumisection_certification" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_golden_json' in params:
            form_params.append(('rr_is_golden_json', params['rr_is_golden_json']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            form_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            form_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            form_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            form_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            form_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            form_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            form_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            form_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            form_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            form_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            form_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            form_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_golden_json' in params:
            form_params.append(('rr_is_golden_json', params['rr_is_golden_json']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            form_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            form_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            form_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            form_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            form_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            form_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            form_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            form_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            form_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            form_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            form_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            form_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisection_certifications/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LumisectionCertification',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_lumisection_certification(self, **kwargs):  # noqa: E501
        """create_lumisection_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_lumisection_certification(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param datetime _date2:
        :param bool rr_is_golden_json2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param int id:
        :param int run:
        :param int lumisection:
        :param datetime _date:
        :param bool rr_is_golden_json:
        :param bool rr_is_pixel_good:
        :param bool rr_is_strip_good:
        :param bool rr_is_ecal_good:
        :param bool rr_is_hcal_good:
        :param bool rr_is_dt_good:
        :param bool rr_is_csc_good:
        :param bool rr_is_tracking_good:
        :param bool rr_is_muon_good:
        :param bool rr_is_egamma_good:
        :param bool rr_is_tau_good:
        :param bool rr_is_jetmet_good:
        :param bool rr_is_btag_good:
        :return: LumisectionCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_lumisection_certification_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_lumisection_certification_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_lumisection_certification_with_http_info(self, **kwargs):  # noqa: E501
        """create_lumisection_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_lumisection_certification_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param datetime _date2:
        :param bool rr_is_golden_json2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param int id:
        :param int run:
        :param int lumisection:
        :param datetime _date:
        :param bool rr_is_golden_json:
        :param bool rr_is_pixel_good:
        :param bool rr_is_strip_good:
        :param bool rr_is_ecal_good:
        :param bool rr_is_hcal_good:
        :param bool rr_is_dt_good:
        :param bool rr_is_csc_good:
        :param bool rr_is_tracking_good:
        :param bool rr_is_muon_good:
        :param bool rr_is_egamma_good:
        :param bool rr_is_tau_good:
        :param bool rr_is_jetmet_good:
        :param bool rr_is_btag_good:
        :return: LumisectionCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id2', 'run2', 'lumisection2', '_date2', 'rr_is_golden_json2', 'rr_is_pixel_good2', 'rr_is_strip_good2', 'rr_is_ecal_good2', 'rr_is_hcal_good2', 'rr_is_dt_good2', 'rr_is_csc_good2', 'rr_is_tracking_good2', 'rr_is_muon_good2', 'rr_is_egamma_good2', 'rr_is_tau_good2', 'rr_is_jetmet_good2', 'rr_is_btag_good2', 'id', 'run', 'lumisection', '_date', 'rr_is_golden_json', 'rr_is_pixel_good', 'rr_is_strip_good', 'rr_is_ecal_good', 'rr_is_hcal_good', 'rr_is_dt_good', 'rr_is_csc_good', 'rr_is_tracking_good', 'rr_is_muon_good', 'rr_is_egamma_good', 'rr_is_tau_good', 'rr_is_jetmet_good', 'rr_is_btag_good']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_lumisection_certification" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_golden_json' in params:
            form_params.append(('rr_is_golden_json', params['rr_is_golden_json']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            form_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            form_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            form_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            form_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            form_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            form_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            form_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            form_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            form_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            form_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            form_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            form_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_golden_json' in params:
            form_params.append(('rr_is_golden_json', params['rr_is_golden_json']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            form_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            form_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            form_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            form_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            form_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            form_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            form_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            form_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            form_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            form_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            form_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            form_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisection_certifications/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LumisectionCertification',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_lumisection_histogram1_d(self, **kwargs):  # noqa: E501
        """create_lumisection_histogram1_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_lumisection_histogram1_d(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LumisectionHistogram1D body:
        :return: LumisectionHistogram1D
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_lumisection_histogram1_d_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_lumisection_histogram1_d_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_lumisection_histogram1_d_with_http_info(self, **kwargs):  # noqa: E501
        """create_lumisection_histogram1_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_lumisection_histogram1_d_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LumisectionHistogram1D body:
        :return: LumisectionHistogram1D
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_lumisection_histogram1_d" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501
        if 'x_min' in params:
            form_params.append(('x_min', params['x_min']))  # noqa: E501
        if 'x_max' in params:
            form_params.append(('x_max', params['x_max']))  # noqa: E501
        if 'x_bin' in params:
            form_params.append(('x_bin', params['x_bin']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501
        if 'x_min' in params:
            form_params.append(('x_min', params['x_min']))  # noqa: E501
        if 'x_max' in params:
            form_params.append(('x_max', params['x_max']))  # noqa: E501
        if 'x_bin' in params:
            form_params.append(('x_bin', params['x_bin']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisection_histograms_1d/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LumisectionHistogram1D',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_lumisection_histogram1_d(self, **kwargs):  # noqa: E501
        """create_lumisection_histogram1_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_lumisection_histogram1_d(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param str title2:
        :param int entries2:
        :param list[float] data2:
        :param float x_min2:
        :param float x_max2:
        :param int x_bin2:
        :param int source_data_file2:
        :param int id:
        :param int run:
        :param int lumisection:
        :param str title:
        :param int entries:
        :param list[float] data:
        :param float x_min:
        :param float x_max:
        :param int x_bin:
        :param int source_data_file:
        :return: LumisectionHistogram1D
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_lumisection_histogram1_d_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_lumisection_histogram1_d_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_lumisection_histogram1_d_with_http_info(self, **kwargs):  # noqa: E501
        """create_lumisection_histogram1_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_lumisection_histogram1_d_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param str title2:
        :param int entries2:
        :param list[float] data2:
        :param float x_min2:
        :param float x_max2:
        :param int x_bin2:
        :param int source_data_file2:
        :param int id:
        :param int run:
        :param int lumisection:
        :param str title:
        :param int entries:
        :param list[float] data:
        :param float x_min:
        :param float x_max:
        :param int x_bin:
        :param int source_data_file:
        :return: LumisectionHistogram1D
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id2', 'run2', 'lumisection2', 'title2', 'entries2', 'data2', 'x_min2', 'x_max2', 'x_bin2', 'source_data_file2', 'id', 'run', 'lumisection', 'title', 'entries', 'data', 'x_min', 'x_max', 'x_bin', 'source_data_file']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_lumisection_histogram1_d" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501
        if 'x_min' in params:
            form_params.append(('x_min', params['x_min']))  # noqa: E501
        if 'x_max' in params:
            form_params.append(('x_max', params['x_max']))  # noqa: E501
        if 'x_bin' in params:
            form_params.append(('x_bin', params['x_bin']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501
        if 'x_min' in params:
            form_params.append(('x_min', params['x_min']))  # noqa: E501
        if 'x_max' in params:
            form_params.append(('x_max', params['x_max']))  # noqa: E501
        if 'x_bin' in params:
            form_params.append(('x_bin', params['x_bin']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisection_histograms_1d/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LumisectionHistogram1D',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_lumisection_histogram1_d(self, **kwargs):  # noqa: E501
        """create_lumisection_histogram1_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_lumisection_histogram1_d(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param str title2:
        :param int entries2:
        :param list[float] data2:
        :param float x_min2:
        :param float x_max2:
        :param int x_bin2:
        :param int source_data_file2:
        :param int id:
        :param int run:
        :param int lumisection:
        :param str title:
        :param int entries:
        :param list[float] data:
        :param float x_min:
        :param float x_max:
        :param int x_bin:
        :param int source_data_file:
        :return: LumisectionHistogram1D
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_lumisection_histogram1_d_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_lumisection_histogram1_d_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_lumisection_histogram1_d_with_http_info(self, **kwargs):  # noqa: E501
        """create_lumisection_histogram1_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_lumisection_histogram1_d_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param str title2:
        :param int entries2:
        :param list[float] data2:
        :param float x_min2:
        :param float x_max2:
        :param int x_bin2:
        :param int source_data_file2:
        :param int id:
        :param int run:
        :param int lumisection:
        :param str title:
        :param int entries:
        :param list[float] data:
        :param float x_min:
        :param float x_max:
        :param int x_bin:
        :param int source_data_file:
        :return: LumisectionHistogram1D
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id2', 'run2', 'lumisection2', 'title2', 'entries2', 'data2', 'x_min2', 'x_max2', 'x_bin2', 'source_data_file2', 'id', 'run', 'lumisection', 'title', 'entries', 'data', 'x_min', 'x_max', 'x_bin', 'source_data_file']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_lumisection_histogram1_d" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501
        if 'x_min' in params:
            form_params.append(('x_min', params['x_min']))  # noqa: E501
        if 'x_max' in params:
            form_params.append(('x_max', params['x_max']))  # noqa: E501
        if 'x_bin' in params:
            form_params.append(('x_bin', params['x_bin']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501
        if 'x_min' in params:
            form_params.append(('x_min', params['x_min']))  # noqa: E501
        if 'x_max' in params:
            form_params.append(('x_max', params['x_max']))  # noqa: E501
        if 'x_bin' in params:
            form_params.append(('x_bin', params['x_bin']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisection_histograms_1d/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LumisectionHistogram1D',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_lumisection_histogram2_d(self, **kwargs):  # noqa: E501
        """create_lumisection_histogram2_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_lumisection_histogram2_d(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LumisectionHistogram2D body:
        :return: LumisectionHistogram2D
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_lumisection_histogram2_d_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_lumisection_histogram2_d_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_lumisection_histogram2_d_with_http_info(self, **kwargs):  # noqa: E501
        """create_lumisection_histogram2_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_lumisection_histogram2_d_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LumisectionHistogram2D body:
        :return: LumisectionHistogram2D
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_lumisection_histogram2_d" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501
        if 'x_min' in params:
            form_params.append(('x_min', params['x_min']))  # noqa: E501
        if 'x_max' in params:
            form_params.append(('x_max', params['x_max']))  # noqa: E501
        if 'x_bin' in params:
            form_params.append(('x_bin', params['x_bin']))  # noqa: E501
        if 'y_max' in params:
            form_params.append(('y_max', params['y_max']))  # noqa: E501
        if 'y_min' in params:
            form_params.append(('y_min', params['y_min']))  # noqa: E501
        if 'y_bin' in params:
            form_params.append(('y_bin', params['y_bin']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501
        if 'x_min' in params:
            form_params.append(('x_min', params['x_min']))  # noqa: E501
        if 'x_max' in params:
            form_params.append(('x_max', params['x_max']))  # noqa: E501
        if 'x_bin' in params:
            form_params.append(('x_bin', params['x_bin']))  # noqa: E501
        if 'y_max' in params:
            form_params.append(('y_max', params['y_max']))  # noqa: E501
        if 'y_min' in params:
            form_params.append(('y_min', params['y_min']))  # noqa: E501
        if 'y_bin' in params:
            form_params.append(('y_bin', params['y_bin']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisection_histograms_2d/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LumisectionHistogram2D',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_lumisection_histogram2_d(self, **kwargs):  # noqa: E501
        """create_lumisection_histogram2_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_lumisection_histogram2_d(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param str title2:
        :param int entries2:
        :param list[list[float]] data2:
        :param float x_min2:
        :param float x_max2:
        :param int x_bin2:
        :param float y_max2:
        :param float y_min2:
        :param int y_bin2:
        :param int source_data_file2:
        :param int id:
        :param int run:
        :param int lumisection:
        :param str title:
        :param int entries:
        :param list[list[float]] data:
        :param float x_min:
        :param float x_max:
        :param int x_bin:
        :param float y_max:
        :param float y_min:
        :param int y_bin:
        :param int source_data_file:
        :return: LumisectionHistogram2D
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_lumisection_histogram2_d_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_lumisection_histogram2_d_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_lumisection_histogram2_d_with_http_info(self, **kwargs):  # noqa: E501
        """create_lumisection_histogram2_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_lumisection_histogram2_d_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param str title2:
        :param int entries2:
        :param list[list[float]] data2:
        :param float x_min2:
        :param float x_max2:
        :param int x_bin2:
        :param float y_max2:
        :param float y_min2:
        :param int y_bin2:
        :param int source_data_file2:
        :param int id:
        :param int run:
        :param int lumisection:
        :param str title:
        :param int entries:
        :param list[list[float]] data:
        :param float x_min:
        :param float x_max:
        :param int x_bin:
        :param float y_max:
        :param float y_min:
        :param int y_bin:
        :param int source_data_file:
        :return: LumisectionHistogram2D
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id2', 'run2', 'lumisection2', 'title2', 'entries2', 'data2', 'x_min2', 'x_max2', 'x_bin2', 'y_max2', 'y_min2', 'y_bin2', 'source_data_file2', 'id', 'run', 'lumisection', 'title', 'entries', 'data', 'x_min', 'x_max', 'x_bin', 'y_max', 'y_min', 'y_bin', 'source_data_file']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_lumisection_histogram2_d" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501
        if 'x_min' in params:
            form_params.append(('x_min', params['x_min']))  # noqa: E501
        if 'x_max' in params:
            form_params.append(('x_max', params['x_max']))  # noqa: E501
        if 'x_bin' in params:
            form_params.append(('x_bin', params['x_bin']))  # noqa: E501
        if 'y_max' in params:
            form_params.append(('y_max', params['y_max']))  # noqa: E501
        if 'y_min' in params:
            form_params.append(('y_min', params['y_min']))  # noqa: E501
        if 'y_bin' in params:
            form_params.append(('y_bin', params['y_bin']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501
        if 'x_min' in params:
            form_params.append(('x_min', params['x_min']))  # noqa: E501
        if 'x_max' in params:
            form_params.append(('x_max', params['x_max']))  # noqa: E501
        if 'x_bin' in params:
            form_params.append(('x_bin', params['x_bin']))  # noqa: E501
        if 'y_max' in params:
            form_params.append(('y_max', params['y_max']))  # noqa: E501
        if 'y_min' in params:
            form_params.append(('y_min', params['y_min']))  # noqa: E501
        if 'y_bin' in params:
            form_params.append(('y_bin', params['y_bin']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisection_histograms_2d/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LumisectionHistogram2D',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_lumisection_histogram2_d(self, **kwargs):  # noqa: E501
        """create_lumisection_histogram2_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_lumisection_histogram2_d(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param str title2:
        :param int entries2:
        :param list[list[float]] data2:
        :param float x_min2:
        :param float x_max2:
        :param int x_bin2:
        :param float y_max2:
        :param float y_min2:
        :param int y_bin2:
        :param int source_data_file2:
        :param int id:
        :param int run:
        :param int lumisection:
        :param str title:
        :param int entries:
        :param list[list[float]] data:
        :param float x_min:
        :param float x_max:
        :param int x_bin:
        :param float y_max:
        :param float y_min:
        :param int y_bin:
        :param int source_data_file:
        :return: LumisectionHistogram2D
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_lumisection_histogram2_d_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_lumisection_histogram2_d_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_lumisection_histogram2_d_with_http_info(self, **kwargs):  # noqa: E501
        """create_lumisection_histogram2_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_lumisection_histogram2_d_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param str title2:
        :param int entries2:
        :param list[list[float]] data2:
        :param float x_min2:
        :param float x_max2:
        :param int x_bin2:
        :param float y_max2:
        :param float y_min2:
        :param int y_bin2:
        :param int source_data_file2:
        :param int id:
        :param int run:
        :param int lumisection:
        :param str title:
        :param int entries:
        :param list[list[float]] data:
        :param float x_min:
        :param float x_max:
        :param int x_bin:
        :param float y_max:
        :param float y_min:
        :param int y_bin:
        :param int source_data_file:
        :return: LumisectionHistogram2D
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id2', 'run2', 'lumisection2', 'title2', 'entries2', 'data2', 'x_min2', 'x_max2', 'x_bin2', 'y_max2', 'y_min2', 'y_bin2', 'source_data_file2', 'id', 'run', 'lumisection', 'title', 'entries', 'data', 'x_min', 'x_max', 'x_bin', 'y_max', 'y_min', 'y_bin', 'source_data_file']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_lumisection_histogram2_d" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501
        if 'x_min' in params:
            form_params.append(('x_min', params['x_min']))  # noqa: E501
        if 'x_max' in params:
            form_params.append(('x_max', params['x_max']))  # noqa: E501
        if 'x_bin' in params:
            form_params.append(('x_bin', params['x_bin']))  # noqa: E501
        if 'y_max' in params:
            form_params.append(('y_max', params['y_max']))  # noqa: E501
        if 'y_min' in params:
            form_params.append(('y_min', params['y_min']))  # noqa: E501
        if 'y_bin' in params:
            form_params.append(('y_bin', params['y_bin']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501
        if 'x_min' in params:
            form_params.append(('x_min', params['x_min']))  # noqa: E501
        if 'x_max' in params:
            form_params.append(('x_max', params['x_max']))  # noqa: E501
        if 'x_bin' in params:
            form_params.append(('x_bin', params['x_bin']))  # noqa: E501
        if 'y_max' in params:
            form_params.append(('y_max', params['y_max']))  # noqa: E501
        if 'y_min' in params:
            form_params.append(('y_min', params['y_min']))  # noqa: E501
        if 'y_bin' in params:
            form_params.append(('y_bin', params['y_bin']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisection_histograms_2d/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LumisectionHistogram2D',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_prediction(self, **kwargs):  # noqa: E501
        """create_prediction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_prediction(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Prediction body:
        :return: Prediction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_prediction_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_prediction_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_prediction_with_http_info(self, **kwargs):  # noqa: E501
        """create_prediction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_prediction_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Prediction body:
        :return: Prediction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_prediction" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'strategy' in params:
            form_params.append(('strategy', params['strategy']))  # noqa: E501
        if 'run_histograms' in params:
            form_params.append(('run_histograms', params['run_histograms']))  # noqa: E501
            collection_formats['run_histograms'] = 'multi'  # noqa: E501
        if 'lumisection_histograms_1d' in params:
            form_params.append(('lumisection_histograms_1d', params['lumisection_histograms_1d']))  # noqa: E501
            collection_formats['lumisection_histograms_1d'] = 'multi'  # noqa: E501
        if 'lumisection_histograms_2d' in params:
            form_params.append(('lumisection_histograms_2d', params['lumisection_histograms_2d']))  # noqa: E501
            collection_formats['lumisection_histograms_2d'] = 'multi'  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501
        if 'task' in params:
            form_params.append(('task', params['task']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'strategy' in params:
            form_params.append(('strategy', params['strategy']))  # noqa: E501
        if 'run_histograms' in params:
            form_params.append(('run_histograms', params['run_histograms']))  # noqa: E501
            collection_formats['run_histograms'] = 'multi'  # noqa: E501
        if 'lumisection_histograms_1d' in params:
            form_params.append(('lumisection_histograms_1d', params['lumisection_histograms_1d']))  # noqa: E501
            collection_formats['lumisection_histograms_1d'] = 'multi'  # noqa: E501
        if 'lumisection_histograms_2d' in params:
            form_params.append(('lumisection_histograms_2d', params['lumisection_histograms_2d']))  # noqa: E501
            collection_formats['lumisection_histograms_2d'] = 'multi'  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501
        if 'task' in params:
            form_params.append(('task', params['task']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/predictions/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Prediction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_prediction(self, **kwargs):  # noqa: E501
        """create_prediction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_prediction(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id2:
        :param str strategy2:
        :param list[PredictionRunHistograms] run_histograms2:
        :param list[PredictionLumisectionHistograms1d] lumisection_histograms_1d2:
        :param list[PredictionLumisectionHistograms2d] lumisection_histograms_2d2:
        :param datetime created2:
        :param datetime modified2:
        :param int task2:
        :param int id:
        :param str strategy:
        :param list[PredictionRunHistograms] run_histograms:
        :param list[PredictionLumisectionHistograms1d] lumisection_histograms_1d:
        :param list[PredictionLumisectionHistograms2d] lumisection_histograms_2d:
        :param datetime created:
        :param datetime modified:
        :param int task:
        :return: Prediction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_prediction_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_prediction_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_prediction_with_http_info(self, **kwargs):  # noqa: E501
        """create_prediction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_prediction_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id2:
        :param str strategy2:
        :param list[PredictionRunHistograms] run_histograms2:
        :param list[PredictionLumisectionHistograms1d] lumisection_histograms_1d2:
        :param list[PredictionLumisectionHistograms2d] lumisection_histograms_2d2:
        :param datetime created2:
        :param datetime modified2:
        :param int task2:
        :param int id:
        :param str strategy:
        :param list[PredictionRunHistograms] run_histograms:
        :param list[PredictionLumisectionHistograms1d] lumisection_histograms_1d:
        :param list[PredictionLumisectionHistograms2d] lumisection_histograms_2d:
        :param datetime created:
        :param datetime modified:
        :param int task:
        :return: Prediction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id2', 'strategy2', 'run_histograms2', 'lumisection_histograms_1d2', 'lumisection_histograms_2d2', 'created2', 'modified2', 'task2', 'id', 'strategy', 'run_histograms', 'lumisection_histograms_1d', 'lumisection_histograms_2d', 'created', 'modified', 'task']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_prediction" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'strategy' in params:
            form_params.append(('strategy', params['strategy']))  # noqa: E501
        if 'run_histograms' in params:
            form_params.append(('run_histograms', params['run_histograms']))  # noqa: E501
            collection_formats['run_histograms'] = 'multi'  # noqa: E501
        if 'lumisection_histograms_1d' in params:
            form_params.append(('lumisection_histograms_1d', params['lumisection_histograms_1d']))  # noqa: E501
            collection_formats['lumisection_histograms_1d'] = 'multi'  # noqa: E501
        if 'lumisection_histograms_2d' in params:
            form_params.append(('lumisection_histograms_2d', params['lumisection_histograms_2d']))  # noqa: E501
            collection_formats['lumisection_histograms_2d'] = 'multi'  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501
        if 'task' in params:
            form_params.append(('task', params['task']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'strategy' in params:
            form_params.append(('strategy', params['strategy']))  # noqa: E501
        if 'run_histograms' in params:
            form_params.append(('run_histograms', params['run_histograms']))  # noqa: E501
            collection_formats['run_histograms'] = 'multi'  # noqa: E501
        if 'lumisection_histograms_1d' in params:
            form_params.append(('lumisection_histograms_1d', params['lumisection_histograms_1d']))  # noqa: E501
            collection_formats['lumisection_histograms_1d'] = 'multi'  # noqa: E501
        if 'lumisection_histograms_2d' in params:
            form_params.append(('lumisection_histograms_2d', params['lumisection_histograms_2d']))  # noqa: E501
            collection_formats['lumisection_histograms_2d'] = 'multi'  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501
        if 'task' in params:
            form_params.append(('task', params['task']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/predictions/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Prediction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_prediction(self, **kwargs):  # noqa: E501
        """create_prediction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_prediction(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id2:
        :param str strategy2:
        :param list[PredictionRunHistograms] run_histograms2:
        :param list[PredictionLumisectionHistograms1d] lumisection_histograms_1d2:
        :param list[PredictionLumisectionHistograms2d] lumisection_histograms_2d2:
        :param datetime created2:
        :param datetime modified2:
        :param int task2:
        :param int id:
        :param str strategy:
        :param list[PredictionRunHistograms] run_histograms:
        :param list[PredictionLumisectionHistograms1d] lumisection_histograms_1d:
        :param list[PredictionLumisectionHistograms2d] lumisection_histograms_2d:
        :param datetime created:
        :param datetime modified:
        :param int task:
        :return: Prediction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_prediction_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_prediction_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_prediction_with_http_info(self, **kwargs):  # noqa: E501
        """create_prediction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_prediction_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id2:
        :param str strategy2:
        :param list[PredictionRunHistograms] run_histograms2:
        :param list[PredictionLumisectionHistograms1d] lumisection_histograms_1d2:
        :param list[PredictionLumisectionHistograms2d] lumisection_histograms_2d2:
        :param datetime created2:
        :param datetime modified2:
        :param int task2:
        :param int id:
        :param str strategy:
        :param list[PredictionRunHistograms] run_histograms:
        :param list[PredictionLumisectionHistograms1d] lumisection_histograms_1d:
        :param list[PredictionLumisectionHistograms2d] lumisection_histograms_2d:
        :param datetime created:
        :param datetime modified:
        :param int task:
        :return: Prediction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id2', 'strategy2', 'run_histograms2', 'lumisection_histograms_1d2', 'lumisection_histograms_2d2', 'created2', 'modified2', 'task2', 'id', 'strategy', 'run_histograms', 'lumisection_histograms_1d', 'lumisection_histograms_2d', 'created', 'modified', 'task']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_prediction" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'strategy' in params:
            form_params.append(('strategy', params['strategy']))  # noqa: E501
        if 'run_histograms' in params:
            form_params.append(('run_histograms', params['run_histograms']))  # noqa: E501
            collection_formats['run_histograms'] = 'multi'  # noqa: E501
        if 'lumisection_histograms_1d' in params:
            form_params.append(('lumisection_histograms_1d', params['lumisection_histograms_1d']))  # noqa: E501
            collection_formats['lumisection_histograms_1d'] = 'multi'  # noqa: E501
        if 'lumisection_histograms_2d' in params:
            form_params.append(('lumisection_histograms_2d', params['lumisection_histograms_2d']))  # noqa: E501
            collection_formats['lumisection_histograms_2d'] = 'multi'  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501
        if 'task' in params:
            form_params.append(('task', params['task']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'strategy' in params:
            form_params.append(('strategy', params['strategy']))  # noqa: E501
        if 'run_histograms' in params:
            form_params.append(('run_histograms', params['run_histograms']))  # noqa: E501
            collection_formats['run_histograms'] = 'multi'  # noqa: E501
        if 'lumisection_histograms_1d' in params:
            form_params.append(('lumisection_histograms_1d', params['lumisection_histograms_1d']))  # noqa: E501
            collection_formats['lumisection_histograms_1d'] = 'multi'  # noqa: E501
        if 'lumisection_histograms_2d' in params:
            form_params.append(('lumisection_histograms_2d', params['lumisection_histograms_2d']))  # noqa: E501
            collection_formats['lumisection_histograms_2d'] = 'multi'  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501
        if 'task' in params:
            form_params.append(('task', params['task']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/predictions/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Prediction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_run(self, **kwargs):  # noqa: E501
        """create_run  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_run(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Run body:
        :return: Run
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_run_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_run_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_run_with_http_info(self, **kwargs):  # noqa: E501
        """create_run  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_run_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Run body:
        :return: Run
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_run" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'run_number' in params:
            form_params.append(('run_number', params['run_number']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'run_number' in params:
            form_params.append(('run_number', params['run_number']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/runs/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Run',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_run(self, **kwargs):  # noqa: E501
        """create_run  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_run(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int run_number2:
        :param datetime _date2:
        :param int run_number:
        :param datetime _date:
        :return: Run
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_run_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_run_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_run_with_http_info(self, **kwargs):  # noqa: E501
        """create_run  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_run_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int run_number2:
        :param datetime _date2:
        :param int run_number:
        :param datetime _date:
        :return: Run
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['run_number2', '_date2', 'run_number', '_date']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_run" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'run_number' in params:
            form_params.append(('run_number', params['run_number']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'run_number' in params:
            form_params.append(('run_number', params['run_number']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/runs/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Run',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_run(self, **kwargs):  # noqa: E501
        """create_run  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_run(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int run_number2:
        :param datetime _date2:
        :param int run_number:
        :param datetime _date:
        :return: Run
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_run_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_run_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_run_with_http_info(self, **kwargs):  # noqa: E501
        """create_run  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_run_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int run_number2:
        :param datetime _date2:
        :param int run_number:
        :param datetime _date:
        :return: Run
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['run_number2', '_date2', 'run_number', '_date']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_run" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'run_number' in params:
            form_params.append(('run_number', params['run_number']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'run_number' in params:
            form_params.append(('run_number', params['run_number']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/runs/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Run',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_run_certification(self, **kwargs):  # noqa: E501
        """create_run_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_run_certification(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RunCertification body:
        :return: RunCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_run_certification_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_run_certification_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_run_certification_with_http_info(self, **kwargs):  # noqa: E501
        """create_run_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_run_certification_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RunCertification body:
        :return: RunCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_run_certification" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            form_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            form_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            form_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            form_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            form_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            form_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            form_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            form_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            form_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            form_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            form_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            form_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'rr_frac_pixel_good' in params:
            form_params.append(('rr_frac_pixel_good', params['rr_frac_pixel_good']))  # noqa: E501
        if 'rr_frac_strip_good' in params:
            form_params.append(('rr_frac_strip_good', params['rr_frac_strip_good']))  # noqa: E501
        if 'rr_frac_ecal_good' in params:
            form_params.append(('rr_frac_ecal_good', params['rr_frac_ecal_good']))  # noqa: E501
        if 'rr_frac_hcal_good' in params:
            form_params.append(('rr_frac_hcal_good', params['rr_frac_hcal_good']))  # noqa: E501
        if 'rr_frac_dt_good' in params:
            form_params.append(('rr_frac_dt_good', params['rr_frac_dt_good']))  # noqa: E501
        if 'rr_frac_csc_good' in params:
            form_params.append(('rr_frac_csc_good', params['rr_frac_csc_good']))  # noqa: E501
        if 'rr_frac_tracking_good' in params:
            form_params.append(('rr_frac_tracking_good', params['rr_frac_tracking_good']))  # noqa: E501
        if 'rr_frac_muon_good' in params:
            form_params.append(('rr_frac_muon_good', params['rr_frac_muon_good']))  # noqa: E501
        if 'rr_frac_egamma_good' in params:
            form_params.append(('rr_frac_egamma_good', params['rr_frac_egamma_good']))  # noqa: E501
        if 'rr_frac_tau_good' in params:
            form_params.append(('rr_frac_tau_good', params['rr_frac_tau_good']))  # noqa: E501
        if 'rr_frac_jetmet_good' in params:
            form_params.append(('rr_frac_jetmet_good', params['rr_frac_jetmet_good']))  # noqa: E501
        if 'rr_frac_btag_good' in params:
            form_params.append(('rr_frac_btag_good', params['rr_frac_btag_good']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            form_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            form_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            form_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            form_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            form_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            form_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            form_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            form_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            form_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            form_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            form_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            form_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'rr_frac_pixel_good' in params:
            form_params.append(('rr_frac_pixel_good', params['rr_frac_pixel_good']))  # noqa: E501
        if 'rr_frac_strip_good' in params:
            form_params.append(('rr_frac_strip_good', params['rr_frac_strip_good']))  # noqa: E501
        if 'rr_frac_ecal_good' in params:
            form_params.append(('rr_frac_ecal_good', params['rr_frac_ecal_good']))  # noqa: E501
        if 'rr_frac_hcal_good' in params:
            form_params.append(('rr_frac_hcal_good', params['rr_frac_hcal_good']))  # noqa: E501
        if 'rr_frac_dt_good' in params:
            form_params.append(('rr_frac_dt_good', params['rr_frac_dt_good']))  # noqa: E501
        if 'rr_frac_csc_good' in params:
            form_params.append(('rr_frac_csc_good', params['rr_frac_csc_good']))  # noqa: E501
        if 'rr_frac_tracking_good' in params:
            form_params.append(('rr_frac_tracking_good', params['rr_frac_tracking_good']))  # noqa: E501
        if 'rr_frac_muon_good' in params:
            form_params.append(('rr_frac_muon_good', params['rr_frac_muon_good']))  # noqa: E501
        if 'rr_frac_egamma_good' in params:
            form_params.append(('rr_frac_egamma_good', params['rr_frac_egamma_good']))  # noqa: E501
        if 'rr_frac_tau_good' in params:
            form_params.append(('rr_frac_tau_good', params['rr_frac_tau_good']))  # noqa: E501
        if 'rr_frac_jetmet_good' in params:
            form_params.append(('rr_frac_jetmet_good', params['rr_frac_jetmet_good']))  # noqa: E501
        if 'rr_frac_btag_good' in params:
            form_params.append(('rr_frac_btag_good', params['rr_frac_btag_good']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/run_certifications/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RunCertification',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_run_certification(self, **kwargs):  # noqa: E501
        """create_run_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_run_certification(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id2:
        :param int run2:
        :param datetime _date2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param float rr_frac_pixel_good2:
        :param float rr_frac_strip_good2:
        :param float rr_frac_ecal_good2:
        :param float rr_frac_hcal_good2:
        :param float rr_frac_dt_good2:
        :param float rr_frac_csc_good2:
        :param float rr_frac_tracking_good2:
        :param float rr_frac_muon_good2:
        :param float rr_frac_egamma_good2:
        :param float rr_frac_tau_good2:
        :param float rr_frac_jetmet_good2:
        :param float rr_frac_btag_good2:
        :param int id:
        :param int run:
        :param datetime _date:
        :param bool rr_is_pixel_good:
        :param bool rr_is_strip_good:
        :param bool rr_is_ecal_good:
        :param bool rr_is_hcal_good:
        :param bool rr_is_dt_good:
        :param bool rr_is_csc_good:
        :param bool rr_is_tracking_good:
        :param bool rr_is_muon_good:
        :param bool rr_is_egamma_good:
        :param bool rr_is_tau_good:
        :param bool rr_is_jetmet_good:
        :param bool rr_is_btag_good:
        :param float rr_frac_pixel_good:
        :param float rr_frac_strip_good:
        :param float rr_frac_ecal_good:
        :param float rr_frac_hcal_good:
        :param float rr_frac_dt_good:
        :param float rr_frac_csc_good:
        :param float rr_frac_tracking_good:
        :param float rr_frac_muon_good:
        :param float rr_frac_egamma_good:
        :param float rr_frac_tau_good:
        :param float rr_frac_jetmet_good:
        :param float rr_frac_btag_good:
        :return: RunCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_run_certification_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_run_certification_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_run_certification_with_http_info(self, **kwargs):  # noqa: E501
        """create_run_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_run_certification_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id2:
        :param int run2:
        :param datetime _date2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param float rr_frac_pixel_good2:
        :param float rr_frac_strip_good2:
        :param float rr_frac_ecal_good2:
        :param float rr_frac_hcal_good2:
        :param float rr_frac_dt_good2:
        :param float rr_frac_csc_good2:
        :param float rr_frac_tracking_good2:
        :param float rr_frac_muon_good2:
        :param float rr_frac_egamma_good2:
        :param float rr_frac_tau_good2:
        :param float rr_frac_jetmet_good2:
        :param float rr_frac_btag_good2:
        :param int id:
        :param int run:
        :param datetime _date:
        :param bool rr_is_pixel_good:
        :param bool rr_is_strip_good:
        :param bool rr_is_ecal_good:
        :param bool rr_is_hcal_good:
        :param bool rr_is_dt_good:
        :param bool rr_is_csc_good:
        :param bool rr_is_tracking_good:
        :param bool rr_is_muon_good:
        :param bool rr_is_egamma_good:
        :param bool rr_is_tau_good:
        :param bool rr_is_jetmet_good:
        :param bool rr_is_btag_good:
        :param float rr_frac_pixel_good:
        :param float rr_frac_strip_good:
        :param float rr_frac_ecal_good:
        :param float rr_frac_hcal_good:
        :param float rr_frac_dt_good:
        :param float rr_frac_csc_good:
        :param float rr_frac_tracking_good:
        :param float rr_frac_muon_good:
        :param float rr_frac_egamma_good:
        :param float rr_frac_tau_good:
        :param float rr_frac_jetmet_good:
        :param float rr_frac_btag_good:
        :return: RunCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id2', 'run2', '_date2', 'rr_is_pixel_good2', 'rr_is_strip_good2', 'rr_is_ecal_good2', 'rr_is_hcal_good2', 'rr_is_dt_good2', 'rr_is_csc_good2', 'rr_is_tracking_good2', 'rr_is_muon_good2', 'rr_is_egamma_good2', 'rr_is_tau_good2', 'rr_is_jetmet_good2', 'rr_is_btag_good2', 'rr_frac_pixel_good2', 'rr_frac_strip_good2', 'rr_frac_ecal_good2', 'rr_frac_hcal_good2', 'rr_frac_dt_good2', 'rr_frac_csc_good2', 'rr_frac_tracking_good2', 'rr_frac_muon_good2', 'rr_frac_egamma_good2', 'rr_frac_tau_good2', 'rr_frac_jetmet_good2', 'rr_frac_btag_good2', 'id', 'run', '_date', 'rr_is_pixel_good', 'rr_is_strip_good', 'rr_is_ecal_good', 'rr_is_hcal_good', 'rr_is_dt_good', 'rr_is_csc_good', 'rr_is_tracking_good', 'rr_is_muon_good', 'rr_is_egamma_good', 'rr_is_tau_good', 'rr_is_jetmet_good', 'rr_is_btag_good', 'rr_frac_pixel_good', 'rr_frac_strip_good', 'rr_frac_ecal_good', 'rr_frac_hcal_good', 'rr_frac_dt_good', 'rr_frac_csc_good', 'rr_frac_tracking_good', 'rr_frac_muon_good', 'rr_frac_egamma_good', 'rr_frac_tau_good', 'rr_frac_jetmet_good', 'rr_frac_btag_good']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_run_certification" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            form_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            form_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            form_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            form_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            form_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            form_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            form_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            form_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            form_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            form_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            form_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            form_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'rr_frac_pixel_good' in params:
            form_params.append(('rr_frac_pixel_good', params['rr_frac_pixel_good']))  # noqa: E501
        if 'rr_frac_strip_good' in params:
            form_params.append(('rr_frac_strip_good', params['rr_frac_strip_good']))  # noqa: E501
        if 'rr_frac_ecal_good' in params:
            form_params.append(('rr_frac_ecal_good', params['rr_frac_ecal_good']))  # noqa: E501
        if 'rr_frac_hcal_good' in params:
            form_params.append(('rr_frac_hcal_good', params['rr_frac_hcal_good']))  # noqa: E501
        if 'rr_frac_dt_good' in params:
            form_params.append(('rr_frac_dt_good', params['rr_frac_dt_good']))  # noqa: E501
        if 'rr_frac_csc_good' in params:
            form_params.append(('rr_frac_csc_good', params['rr_frac_csc_good']))  # noqa: E501
        if 'rr_frac_tracking_good' in params:
            form_params.append(('rr_frac_tracking_good', params['rr_frac_tracking_good']))  # noqa: E501
        if 'rr_frac_muon_good' in params:
            form_params.append(('rr_frac_muon_good', params['rr_frac_muon_good']))  # noqa: E501
        if 'rr_frac_egamma_good' in params:
            form_params.append(('rr_frac_egamma_good', params['rr_frac_egamma_good']))  # noqa: E501
        if 'rr_frac_tau_good' in params:
            form_params.append(('rr_frac_tau_good', params['rr_frac_tau_good']))  # noqa: E501
        if 'rr_frac_jetmet_good' in params:
            form_params.append(('rr_frac_jetmet_good', params['rr_frac_jetmet_good']))  # noqa: E501
        if 'rr_frac_btag_good' in params:
            form_params.append(('rr_frac_btag_good', params['rr_frac_btag_good']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            form_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            form_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            form_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            form_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            form_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            form_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            form_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            form_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            form_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            form_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            form_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            form_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'rr_frac_pixel_good' in params:
            form_params.append(('rr_frac_pixel_good', params['rr_frac_pixel_good']))  # noqa: E501
        if 'rr_frac_strip_good' in params:
            form_params.append(('rr_frac_strip_good', params['rr_frac_strip_good']))  # noqa: E501
        if 'rr_frac_ecal_good' in params:
            form_params.append(('rr_frac_ecal_good', params['rr_frac_ecal_good']))  # noqa: E501
        if 'rr_frac_hcal_good' in params:
            form_params.append(('rr_frac_hcal_good', params['rr_frac_hcal_good']))  # noqa: E501
        if 'rr_frac_dt_good' in params:
            form_params.append(('rr_frac_dt_good', params['rr_frac_dt_good']))  # noqa: E501
        if 'rr_frac_csc_good' in params:
            form_params.append(('rr_frac_csc_good', params['rr_frac_csc_good']))  # noqa: E501
        if 'rr_frac_tracking_good' in params:
            form_params.append(('rr_frac_tracking_good', params['rr_frac_tracking_good']))  # noqa: E501
        if 'rr_frac_muon_good' in params:
            form_params.append(('rr_frac_muon_good', params['rr_frac_muon_good']))  # noqa: E501
        if 'rr_frac_egamma_good' in params:
            form_params.append(('rr_frac_egamma_good', params['rr_frac_egamma_good']))  # noqa: E501
        if 'rr_frac_tau_good' in params:
            form_params.append(('rr_frac_tau_good', params['rr_frac_tau_good']))  # noqa: E501
        if 'rr_frac_jetmet_good' in params:
            form_params.append(('rr_frac_jetmet_good', params['rr_frac_jetmet_good']))  # noqa: E501
        if 'rr_frac_btag_good' in params:
            form_params.append(('rr_frac_btag_good', params['rr_frac_btag_good']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/run_certifications/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RunCertification',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_run_certification(self, **kwargs):  # noqa: E501
        """create_run_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_run_certification(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id2:
        :param int run2:
        :param datetime _date2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param float rr_frac_pixel_good2:
        :param float rr_frac_strip_good2:
        :param float rr_frac_ecal_good2:
        :param float rr_frac_hcal_good2:
        :param float rr_frac_dt_good2:
        :param float rr_frac_csc_good2:
        :param float rr_frac_tracking_good2:
        :param float rr_frac_muon_good2:
        :param float rr_frac_egamma_good2:
        :param float rr_frac_tau_good2:
        :param float rr_frac_jetmet_good2:
        :param float rr_frac_btag_good2:
        :param int id:
        :param int run:
        :param datetime _date:
        :param bool rr_is_pixel_good:
        :param bool rr_is_strip_good:
        :param bool rr_is_ecal_good:
        :param bool rr_is_hcal_good:
        :param bool rr_is_dt_good:
        :param bool rr_is_csc_good:
        :param bool rr_is_tracking_good:
        :param bool rr_is_muon_good:
        :param bool rr_is_egamma_good:
        :param bool rr_is_tau_good:
        :param bool rr_is_jetmet_good:
        :param bool rr_is_btag_good:
        :param float rr_frac_pixel_good:
        :param float rr_frac_strip_good:
        :param float rr_frac_ecal_good:
        :param float rr_frac_hcal_good:
        :param float rr_frac_dt_good:
        :param float rr_frac_csc_good:
        :param float rr_frac_tracking_good:
        :param float rr_frac_muon_good:
        :param float rr_frac_egamma_good:
        :param float rr_frac_tau_good:
        :param float rr_frac_jetmet_good:
        :param float rr_frac_btag_good:
        :return: RunCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_run_certification_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_run_certification_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_run_certification_with_http_info(self, **kwargs):  # noqa: E501
        """create_run_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_run_certification_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id2:
        :param int run2:
        :param datetime _date2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param float rr_frac_pixel_good2:
        :param float rr_frac_strip_good2:
        :param float rr_frac_ecal_good2:
        :param float rr_frac_hcal_good2:
        :param float rr_frac_dt_good2:
        :param float rr_frac_csc_good2:
        :param float rr_frac_tracking_good2:
        :param float rr_frac_muon_good2:
        :param float rr_frac_egamma_good2:
        :param float rr_frac_tau_good2:
        :param float rr_frac_jetmet_good2:
        :param float rr_frac_btag_good2:
        :param int id:
        :param int run:
        :param datetime _date:
        :param bool rr_is_pixel_good:
        :param bool rr_is_strip_good:
        :param bool rr_is_ecal_good:
        :param bool rr_is_hcal_good:
        :param bool rr_is_dt_good:
        :param bool rr_is_csc_good:
        :param bool rr_is_tracking_good:
        :param bool rr_is_muon_good:
        :param bool rr_is_egamma_good:
        :param bool rr_is_tau_good:
        :param bool rr_is_jetmet_good:
        :param bool rr_is_btag_good:
        :param float rr_frac_pixel_good:
        :param float rr_frac_strip_good:
        :param float rr_frac_ecal_good:
        :param float rr_frac_hcal_good:
        :param float rr_frac_dt_good:
        :param float rr_frac_csc_good:
        :param float rr_frac_tracking_good:
        :param float rr_frac_muon_good:
        :param float rr_frac_egamma_good:
        :param float rr_frac_tau_good:
        :param float rr_frac_jetmet_good:
        :param float rr_frac_btag_good:
        :return: RunCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id2', 'run2', '_date2', 'rr_is_pixel_good2', 'rr_is_strip_good2', 'rr_is_ecal_good2', 'rr_is_hcal_good2', 'rr_is_dt_good2', 'rr_is_csc_good2', 'rr_is_tracking_good2', 'rr_is_muon_good2', 'rr_is_egamma_good2', 'rr_is_tau_good2', 'rr_is_jetmet_good2', 'rr_is_btag_good2', 'rr_frac_pixel_good2', 'rr_frac_strip_good2', 'rr_frac_ecal_good2', 'rr_frac_hcal_good2', 'rr_frac_dt_good2', 'rr_frac_csc_good2', 'rr_frac_tracking_good2', 'rr_frac_muon_good2', 'rr_frac_egamma_good2', 'rr_frac_tau_good2', 'rr_frac_jetmet_good2', 'rr_frac_btag_good2', 'id', 'run', '_date', 'rr_is_pixel_good', 'rr_is_strip_good', 'rr_is_ecal_good', 'rr_is_hcal_good', 'rr_is_dt_good', 'rr_is_csc_good', 'rr_is_tracking_good', 'rr_is_muon_good', 'rr_is_egamma_good', 'rr_is_tau_good', 'rr_is_jetmet_good', 'rr_is_btag_good', 'rr_frac_pixel_good', 'rr_frac_strip_good', 'rr_frac_ecal_good', 'rr_frac_hcal_good', 'rr_frac_dt_good', 'rr_frac_csc_good', 'rr_frac_tracking_good', 'rr_frac_muon_good', 'rr_frac_egamma_good', 'rr_frac_tau_good', 'rr_frac_jetmet_good', 'rr_frac_btag_good']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_run_certification" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            form_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            form_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            form_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            form_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            form_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            form_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            form_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            form_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            form_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            form_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            form_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            form_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'rr_frac_pixel_good' in params:
            form_params.append(('rr_frac_pixel_good', params['rr_frac_pixel_good']))  # noqa: E501
        if 'rr_frac_strip_good' in params:
            form_params.append(('rr_frac_strip_good', params['rr_frac_strip_good']))  # noqa: E501
        if 'rr_frac_ecal_good' in params:
            form_params.append(('rr_frac_ecal_good', params['rr_frac_ecal_good']))  # noqa: E501
        if 'rr_frac_hcal_good' in params:
            form_params.append(('rr_frac_hcal_good', params['rr_frac_hcal_good']))  # noqa: E501
        if 'rr_frac_dt_good' in params:
            form_params.append(('rr_frac_dt_good', params['rr_frac_dt_good']))  # noqa: E501
        if 'rr_frac_csc_good' in params:
            form_params.append(('rr_frac_csc_good', params['rr_frac_csc_good']))  # noqa: E501
        if 'rr_frac_tracking_good' in params:
            form_params.append(('rr_frac_tracking_good', params['rr_frac_tracking_good']))  # noqa: E501
        if 'rr_frac_muon_good' in params:
            form_params.append(('rr_frac_muon_good', params['rr_frac_muon_good']))  # noqa: E501
        if 'rr_frac_egamma_good' in params:
            form_params.append(('rr_frac_egamma_good', params['rr_frac_egamma_good']))  # noqa: E501
        if 'rr_frac_tau_good' in params:
            form_params.append(('rr_frac_tau_good', params['rr_frac_tau_good']))  # noqa: E501
        if 'rr_frac_jetmet_good' in params:
            form_params.append(('rr_frac_jetmet_good', params['rr_frac_jetmet_good']))  # noqa: E501
        if 'rr_frac_btag_good' in params:
            form_params.append(('rr_frac_btag_good', params['rr_frac_btag_good']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            form_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            form_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            form_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            form_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            form_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            form_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            form_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            form_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            form_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            form_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            form_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            form_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'rr_frac_pixel_good' in params:
            form_params.append(('rr_frac_pixel_good', params['rr_frac_pixel_good']))  # noqa: E501
        if 'rr_frac_strip_good' in params:
            form_params.append(('rr_frac_strip_good', params['rr_frac_strip_good']))  # noqa: E501
        if 'rr_frac_ecal_good' in params:
            form_params.append(('rr_frac_ecal_good', params['rr_frac_ecal_good']))  # noqa: E501
        if 'rr_frac_hcal_good' in params:
            form_params.append(('rr_frac_hcal_good', params['rr_frac_hcal_good']))  # noqa: E501
        if 'rr_frac_dt_good' in params:
            form_params.append(('rr_frac_dt_good', params['rr_frac_dt_good']))  # noqa: E501
        if 'rr_frac_csc_good' in params:
            form_params.append(('rr_frac_csc_good', params['rr_frac_csc_good']))  # noqa: E501
        if 'rr_frac_tracking_good' in params:
            form_params.append(('rr_frac_tracking_good', params['rr_frac_tracking_good']))  # noqa: E501
        if 'rr_frac_muon_good' in params:
            form_params.append(('rr_frac_muon_good', params['rr_frac_muon_good']))  # noqa: E501
        if 'rr_frac_egamma_good' in params:
            form_params.append(('rr_frac_egamma_good', params['rr_frac_egamma_good']))  # noqa: E501
        if 'rr_frac_tau_good' in params:
            form_params.append(('rr_frac_tau_good', params['rr_frac_tau_good']))  # noqa: E501
        if 'rr_frac_jetmet_good' in params:
            form_params.append(('rr_frac_jetmet_good', params['rr_frac_jetmet_good']))  # noqa: E501
        if 'rr_frac_btag_good' in params:
            form_params.append(('rr_frac_btag_good', params['rr_frac_btag_good']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/run_certifications/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RunCertification',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_run_histogram(self, **kwargs):  # noqa: E501
        """create_run_histogram  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_run_histogram(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RunHistogram body:
        :return: RunHistogram
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_run_histogram_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_run_histogram_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_run_histogram_with_http_info(self, **kwargs):  # noqa: E501
        """create_run_histogram  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_run_histogram_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RunHistogram body:
        :return: RunHistogram
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_run_histogram" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'primary_dataset' in params:
            form_params.append(('primary_dataset', params['primary_dataset']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'mean' in params:
            form_params.append(('mean', params['mean']))  # noqa: E501
        if 'rms' in params:
            form_params.append(('rms', params['rms']))  # noqa: E501
        if 'skewness' in params:
            form_params.append(('skewness', params['skewness']))  # noqa: E501
        if 'kurtosis' in params:
            form_params.append(('kurtosis', params['kurtosis']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'primary_dataset' in params:
            form_params.append(('primary_dataset', params['primary_dataset']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'mean' in params:
            form_params.append(('mean', params['mean']))  # noqa: E501
        if 'rms' in params:
            form_params.append(('rms', params['rms']))  # noqa: E501
        if 'skewness' in params:
            form_params.append(('skewness', params['skewness']))  # noqa: E501
        if 'kurtosis' in params:
            form_params.append(('kurtosis', params['kurtosis']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/run_histograms/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RunHistogram',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_run_histogram(self, **kwargs):  # noqa: E501
        """create_run_histogram  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_run_histogram(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id2:
        :param int run2:
        :param str title2:
        :param str primary_dataset2:
        :param int entries2:
        :param float mean2:
        :param float rms2:
        :param float skewness2:
        :param float kurtosis2:
        :param int source_data_file2:
        :param int id:
        :param int run:
        :param str title:
        :param str primary_dataset:
        :param int entries:
        :param float mean:
        :param float rms:
        :param float skewness:
        :param float kurtosis:
        :param int source_data_file:
        :return: RunHistogram
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_run_histogram_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_run_histogram_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_run_histogram_with_http_info(self, **kwargs):  # noqa: E501
        """create_run_histogram  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_run_histogram_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id2:
        :param int run2:
        :param str title2:
        :param str primary_dataset2:
        :param int entries2:
        :param float mean2:
        :param float rms2:
        :param float skewness2:
        :param float kurtosis2:
        :param int source_data_file2:
        :param int id:
        :param int run:
        :param str title:
        :param str primary_dataset:
        :param int entries:
        :param float mean:
        :param float rms:
        :param float skewness:
        :param float kurtosis:
        :param int source_data_file:
        :return: RunHistogram
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id2', 'run2', 'title2', 'primary_dataset2', 'entries2', 'mean2', 'rms2', 'skewness2', 'kurtosis2', 'source_data_file2', 'id', 'run', 'title', 'primary_dataset', 'entries', 'mean', 'rms', 'skewness', 'kurtosis', 'source_data_file']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_run_histogram" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'primary_dataset' in params:
            form_params.append(('primary_dataset', params['primary_dataset']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'mean' in params:
            form_params.append(('mean', params['mean']))  # noqa: E501
        if 'rms' in params:
            form_params.append(('rms', params['rms']))  # noqa: E501
        if 'skewness' in params:
            form_params.append(('skewness', params['skewness']))  # noqa: E501
        if 'kurtosis' in params:
            form_params.append(('kurtosis', params['kurtosis']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'primary_dataset' in params:
            form_params.append(('primary_dataset', params['primary_dataset']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'mean' in params:
            form_params.append(('mean', params['mean']))  # noqa: E501
        if 'rms' in params:
            form_params.append(('rms', params['rms']))  # noqa: E501
        if 'skewness' in params:
            form_params.append(('skewness', params['skewness']))  # noqa: E501
        if 'kurtosis' in params:
            form_params.append(('kurtosis', params['kurtosis']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/run_histograms/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RunHistogram',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_run_histogram(self, **kwargs):  # noqa: E501
        """create_run_histogram  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_run_histogram(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id2:
        :param int run2:
        :param str title2:
        :param str primary_dataset2:
        :param int entries2:
        :param float mean2:
        :param float rms2:
        :param float skewness2:
        :param float kurtosis2:
        :param int source_data_file2:
        :param int id:
        :param int run:
        :param str title:
        :param str primary_dataset:
        :param int entries:
        :param float mean:
        :param float rms:
        :param float skewness:
        :param float kurtosis:
        :param int source_data_file:
        :return: RunHistogram
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_run_histogram_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_run_histogram_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_run_histogram_with_http_info(self, **kwargs):  # noqa: E501
        """create_run_histogram  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_run_histogram_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id2:
        :param int run2:
        :param str title2:
        :param str primary_dataset2:
        :param int entries2:
        :param float mean2:
        :param float rms2:
        :param float skewness2:
        :param float kurtosis2:
        :param int source_data_file2:
        :param int id:
        :param int run:
        :param str title:
        :param str primary_dataset:
        :param int entries:
        :param float mean:
        :param float rms:
        :param float skewness:
        :param float kurtosis:
        :param int source_data_file:
        :return: RunHistogram
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id2', 'run2', 'title2', 'primary_dataset2', 'entries2', 'mean2', 'rms2', 'skewness2', 'kurtosis2', 'source_data_file2', 'id', 'run', 'title', 'primary_dataset', 'entries', 'mean', 'rms', 'skewness', 'kurtosis', 'source_data_file']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_run_histogram" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'primary_dataset' in params:
            form_params.append(('primary_dataset', params['primary_dataset']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'mean' in params:
            form_params.append(('mean', params['mean']))  # noqa: E501
        if 'rms' in params:
            form_params.append(('rms', params['rms']))  # noqa: E501
        if 'skewness' in params:
            form_params.append(('skewness', params['skewness']))  # noqa: E501
        if 'kurtosis' in params:
            form_params.append(('kurtosis', params['kurtosis']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'primary_dataset' in params:
            form_params.append(('primary_dataset', params['primary_dataset']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'mean' in params:
            form_params.append(('mean', params['mean']))  # noqa: E501
        if 'rms' in params:
            form_params.append(('rms', params['rms']))  # noqa: E501
        if 'skewness' in params:
            form_params.append(('skewness', params['skewness']))  # noqa: E501
        if 'kurtosis' in params:
            form_params.append(('kurtosis', params['kurtosis']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/run_histograms/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RunHistogram',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_strategy(self, **kwargs):  # noqa: E501
        """create_strategy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_strategy(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Strategy body:
        :return: Strategy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_strategy_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_strategy_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_strategy_with_http_info(self, **kwargs):  # noqa: E501
        """create_strategy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_strategy_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Strategy body:
        :return: Strategy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_strategy" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'model' in params:
            form_params.append(('model', params['model']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'model' in params:
            form_params.append(('model', params['model']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/strategies/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Strategy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_strategy(self, **kwargs):  # noqa: E501
        """create_strategy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_strategy(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id2:
        :param str model2:
        :param int id:
        :param str model:
        :return: Strategy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_strategy_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_strategy_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_strategy_with_http_info(self, **kwargs):  # noqa: E501
        """create_strategy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_strategy_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id2:
        :param str model2:
        :param int id:
        :param str model:
        :return: Strategy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id2', 'model2', 'id', 'model']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_strategy" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'model' in params:
            form_params.append(('model', params['model']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'model' in params:
            form_params.append(('model', params['model']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/strategies/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Strategy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_strategy(self, **kwargs):  # noqa: E501
        """create_strategy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_strategy(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id2:
        :param str model2:
        :param int id:
        :param str model:
        :return: Strategy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_strategy_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_strategy_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_strategy_with_http_info(self, **kwargs):  # noqa: E501
        """create_strategy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_strategy_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id2:
        :param str model2:
        :param int id:
        :param str model:
        :return: Strategy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id2', 'model2', 'id', 'model']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_strategy" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'model' in params:
            form_params.append(('model', params['model']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'model' in params:
            form_params.append(('model', params['model']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/strategies/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Strategy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_task(self, **kwargs):  # noqa: E501
        """create_task  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_task(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Task body:
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_task_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_task_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_task_with_http_info(self, **kwargs):  # noqa: E501
        """create_task  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_task_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Task body:
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_task" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'training_runs' in params:
            form_params.append(('training_runs', params['training_runs']))  # noqa: E501
            collection_formats['training_runs'] = 'multi'  # noqa: E501
        if 'testing_runs' in params:
            form_params.append(('testing_runs', params['testing_runs']))  # noqa: E501
            collection_formats['testing_runs'] = 'multi'  # noqa: E501
        if 'training_lumisections' in params:
            form_params.append(('training_lumisections', params['training_lumisections']))  # noqa: E501
            collection_formats['training_lumisections'] = 'multi'  # noqa: E501
        if 'testing_lumisections' in params:
            form_params.append(('testing_lumisections', params['testing_lumisections']))  # noqa: E501
            collection_formats['testing_lumisections'] = 'multi'  # noqa: E501
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'metadata' in params:
            form_params.append(('metadata', params['metadata']))  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'training_runs' in params:
            form_params.append(('training_runs', params['training_runs']))  # noqa: E501
            collection_formats['training_runs'] = 'multi'  # noqa: E501
        if 'testing_runs' in params:
            form_params.append(('testing_runs', params['testing_runs']))  # noqa: E501
            collection_formats['testing_runs'] = 'multi'  # noqa: E501
        if 'training_lumisections' in params:
            form_params.append(('training_lumisections', params['training_lumisections']))  # noqa: E501
            collection_formats['training_lumisections'] = 'multi'  # noqa: E501
        if 'testing_lumisections' in params:
            form_params.append(('testing_lumisections', params['testing_lumisections']))  # noqa: E501
            collection_formats['testing_lumisections'] = 'multi'  # noqa: E501
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'metadata' in params:
            form_params.append(('metadata', params['metadata']))  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/tasks/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Task',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_task(self, **kwargs):  # noqa: E501
        """create_task  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_task(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id2:
        :param list[TaskTrainingRuns] training_runs2:
        :param list[TaskTrainingRuns] testing_runs2:
        :param list[TaskTrainingLumisections] training_lumisections2:
        :param list[TaskTrainingLumisections] testing_lumisections2:
        :param str name2:
        :param str metadata2:
        :param datetime created2:
        :param datetime modified2:
        :param int id:
        :param list[TaskTrainingRuns] training_runs:
        :param list[TaskTrainingRuns] testing_runs:
        :param list[TaskTrainingLumisections] training_lumisections:
        :param list[TaskTrainingLumisections] testing_lumisections:
        :param str name:
        :param str metadata:
        :param datetime created:
        :param datetime modified:
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_task_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_task_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_task_with_http_info(self, **kwargs):  # noqa: E501
        """create_task  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_task_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id2:
        :param list[TaskTrainingRuns] training_runs2:
        :param list[TaskTrainingRuns] testing_runs2:
        :param list[TaskTrainingLumisections] training_lumisections2:
        :param list[TaskTrainingLumisections] testing_lumisections2:
        :param str name2:
        :param str metadata2:
        :param datetime created2:
        :param datetime modified2:
        :param int id:
        :param list[TaskTrainingRuns] training_runs:
        :param list[TaskTrainingRuns] testing_runs:
        :param list[TaskTrainingLumisections] training_lumisections:
        :param list[TaskTrainingLumisections] testing_lumisections:
        :param str name:
        :param str metadata:
        :param datetime created:
        :param datetime modified:
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id2', 'training_runs2', 'testing_runs2', 'training_lumisections2', 'testing_lumisections2', 'name2', 'metadata2', 'created2', 'modified2', 'id', 'training_runs', 'testing_runs', 'training_lumisections', 'testing_lumisections', 'name', 'metadata', 'created', 'modified']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_task" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'training_runs' in params:
            form_params.append(('training_runs', params['training_runs']))  # noqa: E501
            collection_formats['training_runs'] = 'multi'  # noqa: E501
        if 'testing_runs' in params:
            form_params.append(('testing_runs', params['testing_runs']))  # noqa: E501
            collection_formats['testing_runs'] = 'multi'  # noqa: E501
        if 'training_lumisections' in params:
            form_params.append(('training_lumisections', params['training_lumisections']))  # noqa: E501
            collection_formats['training_lumisections'] = 'multi'  # noqa: E501
        if 'testing_lumisections' in params:
            form_params.append(('testing_lumisections', params['testing_lumisections']))  # noqa: E501
            collection_formats['testing_lumisections'] = 'multi'  # noqa: E501
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'metadata' in params:
            form_params.append(('metadata', params['metadata']))  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'training_runs' in params:
            form_params.append(('training_runs', params['training_runs']))  # noqa: E501
            collection_formats['training_runs'] = 'multi'  # noqa: E501
        if 'testing_runs' in params:
            form_params.append(('testing_runs', params['testing_runs']))  # noqa: E501
            collection_formats['testing_runs'] = 'multi'  # noqa: E501
        if 'training_lumisections' in params:
            form_params.append(('training_lumisections', params['training_lumisections']))  # noqa: E501
            collection_formats['training_lumisections'] = 'multi'  # noqa: E501
        if 'testing_lumisections' in params:
            form_params.append(('testing_lumisections', params['testing_lumisections']))  # noqa: E501
            collection_formats['testing_lumisections'] = 'multi'  # noqa: E501
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'metadata' in params:
            form_params.append(('metadata', params['metadata']))  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/tasks/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Task',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_task(self, **kwargs):  # noqa: E501
        """create_task  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_task(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id2:
        :param list[TaskTrainingRuns] training_runs2:
        :param list[TaskTrainingRuns] testing_runs2:
        :param list[TaskTrainingLumisections] training_lumisections2:
        :param list[TaskTrainingLumisections] testing_lumisections2:
        :param str name2:
        :param str metadata2:
        :param datetime created2:
        :param datetime modified2:
        :param int id:
        :param list[TaskTrainingRuns] training_runs:
        :param list[TaskTrainingRuns] testing_runs:
        :param list[TaskTrainingLumisections] training_lumisections:
        :param list[TaskTrainingLumisections] testing_lumisections:
        :param str name:
        :param str metadata:
        :param datetime created:
        :param datetime modified:
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_task_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_task_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_task_with_http_info(self, **kwargs):  # noqa: E501
        """create_task  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_task_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id2:
        :param list[TaskTrainingRuns] training_runs2:
        :param list[TaskTrainingRuns] testing_runs2:
        :param list[TaskTrainingLumisections] training_lumisections2:
        :param list[TaskTrainingLumisections] testing_lumisections2:
        :param str name2:
        :param str metadata2:
        :param datetime created2:
        :param datetime modified2:
        :param int id:
        :param list[TaskTrainingRuns] training_runs:
        :param list[TaskTrainingRuns] testing_runs:
        :param list[TaskTrainingLumisections] training_lumisections:
        :param list[TaskTrainingLumisections] testing_lumisections:
        :param str name:
        :param str metadata:
        :param datetime created:
        :param datetime modified:
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id2', 'training_runs2', 'testing_runs2', 'training_lumisections2', 'testing_lumisections2', 'name2', 'metadata2', 'created2', 'modified2', 'id', 'training_runs', 'testing_runs', 'training_lumisections', 'testing_lumisections', 'name', 'metadata', 'created', 'modified']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_task" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'training_runs' in params:
            form_params.append(('training_runs', params['training_runs']))  # noqa: E501
            collection_formats['training_runs'] = 'multi'  # noqa: E501
        if 'testing_runs' in params:
            form_params.append(('testing_runs', params['testing_runs']))  # noqa: E501
            collection_formats['testing_runs'] = 'multi'  # noqa: E501
        if 'training_lumisections' in params:
            form_params.append(('training_lumisections', params['training_lumisections']))  # noqa: E501
            collection_formats['training_lumisections'] = 'multi'  # noqa: E501
        if 'testing_lumisections' in params:
            form_params.append(('testing_lumisections', params['testing_lumisections']))  # noqa: E501
            collection_formats['testing_lumisections'] = 'multi'  # noqa: E501
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'metadata' in params:
            form_params.append(('metadata', params['metadata']))  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'training_runs' in params:
            form_params.append(('training_runs', params['training_runs']))  # noqa: E501
            collection_formats['training_runs'] = 'multi'  # noqa: E501
        if 'testing_runs' in params:
            form_params.append(('testing_runs', params['testing_runs']))  # noqa: E501
            collection_formats['testing_runs'] = 'multi'  # noqa: E501
        if 'training_lumisections' in params:
            form_params.append(('training_lumisections', params['training_lumisections']))  # noqa: E501
            collection_formats['training_lumisections'] = 'multi'  # noqa: E501
        if 'testing_lumisections' in params:
            form_params.append(('testing_lumisections', params['testing_lumisections']))  # noqa: E501
            collection_formats['testing_lumisections'] = 'multi'  # noqa: E501
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'metadata' in params:
            form_params.append(('metadata', params['metadata']))  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/tasks/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Task',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def destroy_lumisection(self, id, **kwargs):  # noqa: E501
        """destroy_lumisection  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.destroy_lumisection(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection. (required)
        :param str run: run
        :param str ls_number: ls_number
        :param str _date: date
        :param str oms_zerobias_rate: oms_zerobias_rate
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.destroy_lumisection_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.destroy_lumisection_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def destroy_lumisection_with_http_info(self, id, **kwargs):  # noqa: E501
        """destroy_lumisection  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.destroy_lumisection_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection. (required)
        :param str run: run
        :param str ls_number: ls_number
        :param str _date: date
        :param str oms_zerobias_rate: oms_zerobias_rate
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'run', 'ls_number', '_date', 'oms_zerobias_rate']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method destroy_lumisection" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `destroy_lumisection`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'run' in params:
            query_params.append(('run', params['run']))  # noqa: E501
        if 'ls_number' in params:
            query_params.append(('ls_number', params['ls_number']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'oms_zerobias_rate' in params:
            query_params.append(('oms_zerobias_rate', params['oms_zerobias_rate']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisections/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def destroy_lumisection_certification(self, id, **kwargs):  # noqa: E501
        """destroy_lumisection_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.destroy_lumisection_certification(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection certification. (required)
        :param str lumisection: lumisection
        :param str _date: date
        :param str rr_is_golden_json: rr_is_golden_json
        :param str rr_is_pixel_good: rr_is_pixel_good
        :param str rr_is_strip_good: rr_is_strip_good
        :param str rr_is_ecal_good: rr_is_ecal_good
        :param str rr_is_hcal_good: rr_is_hcal_good
        :param str rr_is_dt_good: rr_is_dt_good
        :param str rr_is_csc_good: rr_is_csc_good
        :param str rr_is_tracking_good: rr_is_tracking_good
        :param str rr_is_muon_good: rr_is_muon_good
        :param str rr_is_egamma_good: rr_is_egamma_good
        :param str rr_is_tau_good: rr_is_tau_good
        :param str rr_is_jetmet_good: rr_is_jetmet_good
        :param str rr_is_btag_good: rr_is_btag_good
        :param str run: run
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.destroy_lumisection_certification_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.destroy_lumisection_certification_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def destroy_lumisection_certification_with_http_info(self, id, **kwargs):  # noqa: E501
        """destroy_lumisection_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.destroy_lumisection_certification_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection certification. (required)
        :param str lumisection: lumisection
        :param str _date: date
        :param str rr_is_golden_json: rr_is_golden_json
        :param str rr_is_pixel_good: rr_is_pixel_good
        :param str rr_is_strip_good: rr_is_strip_good
        :param str rr_is_ecal_good: rr_is_ecal_good
        :param str rr_is_hcal_good: rr_is_hcal_good
        :param str rr_is_dt_good: rr_is_dt_good
        :param str rr_is_csc_good: rr_is_csc_good
        :param str rr_is_tracking_good: rr_is_tracking_good
        :param str rr_is_muon_good: rr_is_muon_good
        :param str rr_is_egamma_good: rr_is_egamma_good
        :param str rr_is_tau_good: rr_is_tau_good
        :param str rr_is_jetmet_good: rr_is_jetmet_good
        :param str rr_is_btag_good: rr_is_btag_good
        :param str run: run
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'lumisection', '_date', 'rr_is_golden_json', 'rr_is_pixel_good', 'rr_is_strip_good', 'rr_is_ecal_good', 'rr_is_hcal_good', 'rr_is_dt_good', 'rr_is_csc_good', 'rr_is_tracking_good', 'rr_is_muon_good', 'rr_is_egamma_good', 'rr_is_tau_good', 'rr_is_jetmet_good', 'rr_is_btag_good', 'run']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method destroy_lumisection_certification" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `destroy_lumisection_certification`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lumisection' in params:
            query_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_golden_json' in params:
            query_params.append(('rr_is_golden_json', params['rr_is_golden_json']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            query_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            query_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            query_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            query_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            query_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            query_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            query_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            query_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            query_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            query_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            query_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            query_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'run' in params:
            query_params.append(('run', params['run']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisection_certifications/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def destroy_lumisection_histogram1_d(self, id, **kwargs):  # noqa: E501
        """destroy_lumisection_histogram1_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.destroy_lumisection_histogram1_d(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection histogram1d. (required)
        :param str lumisection__run__run_number: lumisection__run__run_number
        :param str lumisection__run__run_number__gte: lumisection__run__run_number__gte
        :param str lumisection__run__run_number__lte: lumisection__run__run_number__lte
        :param str lumisection__ls_number: lumisection__ls_number
        :param str lumisection__ls_number__gte: lumisection__ls_number__gte
        :param str lumisection__ls_number__lte: lumisection__ls_number__lte
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str lumisection__ls_number__in: lumisection__ls_number__in
        :param str lumisection__run__run_number__in: lumisection__run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.destroy_lumisection_histogram1_d_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.destroy_lumisection_histogram1_d_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def destroy_lumisection_histogram1_d_with_http_info(self, id, **kwargs):  # noqa: E501
        """destroy_lumisection_histogram1_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.destroy_lumisection_histogram1_d_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection histogram1d. (required)
        :param str lumisection__run__run_number: lumisection__run__run_number
        :param str lumisection__run__run_number__gte: lumisection__run__run_number__gte
        :param str lumisection__run__run_number__lte: lumisection__run__run_number__lte
        :param str lumisection__ls_number: lumisection__ls_number
        :param str lumisection__ls_number__gte: lumisection__ls_number__gte
        :param str lumisection__ls_number__lte: lumisection__ls_number__lte
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str lumisection__ls_number__in: lumisection__ls_number__in
        :param str lumisection__run__run_number__in: lumisection__run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'lumisection__run__run_number', 'lumisection__run__run_number__gte', 'lumisection__run__run_number__lte', 'lumisection__ls_number', 'lumisection__ls_number__gte', 'lumisection__ls_number__lte', 'entries__gte', 'entries__lte', 'source_data_file', 'title', 'lumisection__ls_number__in', 'lumisection__run__run_number__in', 'source_data_file__filepath__contains']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method destroy_lumisection_histogram1_d" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `destroy_lumisection_histogram1_d`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lumisection__run__run_number' in params:
            query_params.append(('lumisection__run__run_number', params['lumisection__run__run_number']))  # noqa: E501
        if 'lumisection__run__run_number__gte' in params:
            query_params.append(('lumisection__run__run_number__gte', params['lumisection__run__run_number__gte']))  # noqa: E501
        if 'lumisection__run__run_number__lte' in params:
            query_params.append(('lumisection__run__run_number__lte', params['lumisection__run__run_number__lte']))  # noqa: E501
        if 'lumisection__ls_number' in params:
            query_params.append(('lumisection__ls_number', params['lumisection__ls_number']))  # noqa: E501
        if 'lumisection__ls_number__gte' in params:
            query_params.append(('lumisection__ls_number__gte', params['lumisection__ls_number__gte']))  # noqa: E501
        if 'lumisection__ls_number__lte' in params:
            query_params.append(('lumisection__ls_number__lte', params['lumisection__ls_number__lte']))  # noqa: E501
        if 'entries__gte' in params:
            query_params.append(('entries__gte', params['entries__gte']))  # noqa: E501
        if 'entries__lte' in params:
            query_params.append(('entries__lte', params['entries__lte']))  # noqa: E501
        if 'source_data_file' in params:
            query_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'title' in params:
            query_params.append(('title', params['title']))  # noqa: E501
        if 'lumisection__ls_number__in' in params:
            query_params.append(('lumisection__ls_number__in', params['lumisection__ls_number__in']))  # noqa: E501
        if 'lumisection__run__run_number__in' in params:
            query_params.append(('lumisection__run__run_number__in', params['lumisection__run__run_number__in']))  # noqa: E501
        if 'source_data_file__filepath__contains' in params:
            query_params.append(('source_data_file__filepath__contains', params['source_data_file__filepath__contains']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisection_histograms_1d/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def destroy_lumisection_histogram2_d(self, id, **kwargs):  # noqa: E501
        """destroy_lumisection_histogram2_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.destroy_lumisection_histogram2_d(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection histogram2d. (required)
        :param str lumisection__run__run_number: lumisection__run__run_number
        :param str lumisection__run__run_number__gte: lumisection__run__run_number__gte
        :param str lumisection__run__run_number__lte: lumisection__run__run_number__lte
        :param str lumisection__ls_number: lumisection__ls_number
        :param str lumisection__ls_number__gte: lumisection__ls_number__gte
        :param str lumisection__ls_number__lte: lumisection__ls_number__lte
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str lumisection__ls_number__in: lumisection__ls_number__in
        :param str lumisection__run__run_number__in: lumisection__run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.destroy_lumisection_histogram2_d_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.destroy_lumisection_histogram2_d_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def destroy_lumisection_histogram2_d_with_http_info(self, id, **kwargs):  # noqa: E501
        """destroy_lumisection_histogram2_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.destroy_lumisection_histogram2_d_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection histogram2d. (required)
        :param str lumisection__run__run_number: lumisection__run__run_number
        :param str lumisection__run__run_number__gte: lumisection__run__run_number__gte
        :param str lumisection__run__run_number__lte: lumisection__run__run_number__lte
        :param str lumisection__ls_number: lumisection__ls_number
        :param str lumisection__ls_number__gte: lumisection__ls_number__gte
        :param str lumisection__ls_number__lte: lumisection__ls_number__lte
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str lumisection__ls_number__in: lumisection__ls_number__in
        :param str lumisection__run__run_number__in: lumisection__run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'lumisection__run__run_number', 'lumisection__run__run_number__gte', 'lumisection__run__run_number__lte', 'lumisection__ls_number', 'lumisection__ls_number__gte', 'lumisection__ls_number__lte', 'entries__gte', 'entries__lte', 'source_data_file', 'title', 'lumisection__ls_number__in', 'lumisection__run__run_number__in', 'source_data_file__filepath__contains']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method destroy_lumisection_histogram2_d" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `destroy_lumisection_histogram2_d`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lumisection__run__run_number' in params:
            query_params.append(('lumisection__run__run_number', params['lumisection__run__run_number']))  # noqa: E501
        if 'lumisection__run__run_number__gte' in params:
            query_params.append(('lumisection__run__run_number__gte', params['lumisection__run__run_number__gte']))  # noqa: E501
        if 'lumisection__run__run_number__lte' in params:
            query_params.append(('lumisection__run__run_number__lte', params['lumisection__run__run_number__lte']))  # noqa: E501
        if 'lumisection__ls_number' in params:
            query_params.append(('lumisection__ls_number', params['lumisection__ls_number']))  # noqa: E501
        if 'lumisection__ls_number__gte' in params:
            query_params.append(('lumisection__ls_number__gte', params['lumisection__ls_number__gte']))  # noqa: E501
        if 'lumisection__ls_number__lte' in params:
            query_params.append(('lumisection__ls_number__lte', params['lumisection__ls_number__lte']))  # noqa: E501
        if 'entries__gte' in params:
            query_params.append(('entries__gte', params['entries__gte']))  # noqa: E501
        if 'entries__lte' in params:
            query_params.append(('entries__lte', params['entries__lte']))  # noqa: E501
        if 'source_data_file' in params:
            query_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'title' in params:
            query_params.append(('title', params['title']))  # noqa: E501
        if 'lumisection__ls_number__in' in params:
            query_params.append(('lumisection__ls_number__in', params['lumisection__ls_number__in']))  # noqa: E501
        if 'lumisection__run__run_number__in' in params:
            query_params.append(('lumisection__run__run_number__in', params['lumisection__run__run_number__in']))  # noqa: E501
        if 'source_data_file__filepath__contains' in params:
            query_params.append(('source_data_file__filepath__contains', params['source_data_file__filepath__contains']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisection_histograms_2d/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def destroy_prediction(self, id, **kwargs):  # noqa: E501
        """destroy_prediction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.destroy_prediction(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this prediction. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.destroy_prediction_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.destroy_prediction_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def destroy_prediction_with_http_info(self, id, **kwargs):  # noqa: E501
        """destroy_prediction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.destroy_prediction_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this prediction. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method destroy_prediction" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `destroy_prediction`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/predictions/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def destroy_run(self, run_number, **kwargs):  # noqa: E501
        """destroy_run  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.destroy_run(run_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str run_number: A unique value identifying this run. (required)
        :param str run_number: run_number
        :param str run_date: run_date
        :param str year: year
        :param str period: period
        :param str _date: date
        :param str oms_fill: oms_fill
        :param str oms_lumisections: oms_lumisections
        :param str oms_initial_lumi: oms_initial_lumi
        :param str oms_end_lumi: oms_end_lumi
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.destroy_run_with_http_info(run_number, **kwargs)  # noqa: E501
        else:
            (data) = self.destroy_run_with_http_info(run_number, **kwargs)  # noqa: E501
            return data

    def destroy_run_with_http_info(self, run_number, **kwargs):  # noqa: E501
        """destroy_run  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.destroy_run_with_http_info(run_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str run_number: A unique value identifying this run. (required)
        :param str run_number: run_number
        :param str run_date: run_date
        :param str year: year
        :param str period: period
        :param str _date: date
        :param str oms_fill: oms_fill
        :param str oms_lumisections: oms_lumisections
        :param str oms_initial_lumi: oms_initial_lumi
        :param str oms_end_lumi: oms_end_lumi
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['run_number', 'run_number', 'run_date', 'year', 'period', '_date', 'oms_fill', 'oms_lumisections', 'oms_initial_lumi', 'oms_end_lumi']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method destroy_run" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'run_number' is set
        if ('run_number' not in params or
                params['run_number'] is None):
            raise ValueError("Missing the required parameter `run_number` when calling `destroy_run`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'run_number' in params:
            path_params['run_number'] = params['run_number']  # noqa: E501

        query_params = []
        if 'run_number' in params:
            query_params.append(('run_number', params['run_number']))  # noqa: E501
        if 'run_date' in params:
            query_params.append(('run_date', params['run_date']))  # noqa: E501
        if 'year' in params:
            query_params.append(('year', params['year']))  # noqa: E501
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'oms_fill' in params:
            query_params.append(('oms_fill', params['oms_fill']))  # noqa: E501
        if 'oms_lumisections' in params:
            query_params.append(('oms_lumisections', params['oms_lumisections']))  # noqa: E501
        if 'oms_initial_lumi' in params:
            query_params.append(('oms_initial_lumi', params['oms_initial_lumi']))  # noqa: E501
        if 'oms_end_lumi' in params:
            query_params.append(('oms_end_lumi', params['oms_end_lumi']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/runs/{run_number}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def destroy_run_certification(self, id, **kwargs):  # noqa: E501
        """destroy_run_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.destroy_run_certification(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this run certification. (required)
        :param str run: run
        :param str _date: date
        :param str rr_is_pixel_good: rr_is_pixel_good
        :param str rr_is_strip_good: rr_is_strip_good
        :param str rr_is_ecal_good: rr_is_ecal_good
        :param str rr_is_hcal_good: rr_is_hcal_good
        :param str rr_is_dt_good: rr_is_dt_good
        :param str rr_is_csc_good: rr_is_csc_good
        :param str rr_is_tracking_good: rr_is_tracking_good
        :param str rr_is_muon_good: rr_is_muon_good
        :param str rr_is_egamma_good: rr_is_egamma_good
        :param str rr_is_tau_good: rr_is_tau_good
        :param str rr_is_jetmet_good: rr_is_jetmet_good
        :param str rr_is_btag_good: rr_is_btag_good
        :param str rr_frac_pixel_good: rr_frac_pixel_good
        :param str rr_frac_strip_good: rr_frac_strip_good
        :param str rr_frac_ecal_good: rr_frac_ecal_good
        :param str rr_frac_hcal_good: rr_frac_hcal_good
        :param str rr_frac_dt_good: rr_frac_dt_good
        :param str rr_frac_csc_good: rr_frac_csc_good
        :param str rr_frac_tracking_good: rr_frac_tracking_good
        :param str rr_frac_muon_good: rr_frac_muon_good
        :param str rr_frac_egamma_good: rr_frac_egamma_good
        :param str rr_frac_tau_good: rr_frac_tau_good
        :param str rr_frac_jetmet_good: rr_frac_jetmet_good
        :param str rr_frac_btag_good: rr_frac_btag_good
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.destroy_run_certification_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.destroy_run_certification_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def destroy_run_certification_with_http_info(self, id, **kwargs):  # noqa: E501
        """destroy_run_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.destroy_run_certification_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this run certification. (required)
        :param str run: run
        :param str _date: date
        :param str rr_is_pixel_good: rr_is_pixel_good
        :param str rr_is_strip_good: rr_is_strip_good
        :param str rr_is_ecal_good: rr_is_ecal_good
        :param str rr_is_hcal_good: rr_is_hcal_good
        :param str rr_is_dt_good: rr_is_dt_good
        :param str rr_is_csc_good: rr_is_csc_good
        :param str rr_is_tracking_good: rr_is_tracking_good
        :param str rr_is_muon_good: rr_is_muon_good
        :param str rr_is_egamma_good: rr_is_egamma_good
        :param str rr_is_tau_good: rr_is_tau_good
        :param str rr_is_jetmet_good: rr_is_jetmet_good
        :param str rr_is_btag_good: rr_is_btag_good
        :param str rr_frac_pixel_good: rr_frac_pixel_good
        :param str rr_frac_strip_good: rr_frac_strip_good
        :param str rr_frac_ecal_good: rr_frac_ecal_good
        :param str rr_frac_hcal_good: rr_frac_hcal_good
        :param str rr_frac_dt_good: rr_frac_dt_good
        :param str rr_frac_csc_good: rr_frac_csc_good
        :param str rr_frac_tracking_good: rr_frac_tracking_good
        :param str rr_frac_muon_good: rr_frac_muon_good
        :param str rr_frac_egamma_good: rr_frac_egamma_good
        :param str rr_frac_tau_good: rr_frac_tau_good
        :param str rr_frac_jetmet_good: rr_frac_jetmet_good
        :param str rr_frac_btag_good: rr_frac_btag_good
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'run', '_date', 'rr_is_pixel_good', 'rr_is_strip_good', 'rr_is_ecal_good', 'rr_is_hcal_good', 'rr_is_dt_good', 'rr_is_csc_good', 'rr_is_tracking_good', 'rr_is_muon_good', 'rr_is_egamma_good', 'rr_is_tau_good', 'rr_is_jetmet_good', 'rr_is_btag_good', 'rr_frac_pixel_good', 'rr_frac_strip_good', 'rr_frac_ecal_good', 'rr_frac_hcal_good', 'rr_frac_dt_good', 'rr_frac_csc_good', 'rr_frac_tracking_good', 'rr_frac_muon_good', 'rr_frac_egamma_good', 'rr_frac_tau_good', 'rr_frac_jetmet_good', 'rr_frac_btag_good']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method destroy_run_certification" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `destroy_run_certification`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'run' in params:
            query_params.append(('run', params['run']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            query_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            query_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            query_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            query_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            query_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            query_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            query_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            query_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            query_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            query_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            query_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            query_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'rr_frac_pixel_good' in params:
            query_params.append(('rr_frac_pixel_good', params['rr_frac_pixel_good']))  # noqa: E501
        if 'rr_frac_strip_good' in params:
            query_params.append(('rr_frac_strip_good', params['rr_frac_strip_good']))  # noqa: E501
        if 'rr_frac_ecal_good' in params:
            query_params.append(('rr_frac_ecal_good', params['rr_frac_ecal_good']))  # noqa: E501
        if 'rr_frac_hcal_good' in params:
            query_params.append(('rr_frac_hcal_good', params['rr_frac_hcal_good']))  # noqa: E501
        if 'rr_frac_dt_good' in params:
            query_params.append(('rr_frac_dt_good', params['rr_frac_dt_good']))  # noqa: E501
        if 'rr_frac_csc_good' in params:
            query_params.append(('rr_frac_csc_good', params['rr_frac_csc_good']))  # noqa: E501
        if 'rr_frac_tracking_good' in params:
            query_params.append(('rr_frac_tracking_good', params['rr_frac_tracking_good']))  # noqa: E501
        if 'rr_frac_muon_good' in params:
            query_params.append(('rr_frac_muon_good', params['rr_frac_muon_good']))  # noqa: E501
        if 'rr_frac_egamma_good' in params:
            query_params.append(('rr_frac_egamma_good', params['rr_frac_egamma_good']))  # noqa: E501
        if 'rr_frac_tau_good' in params:
            query_params.append(('rr_frac_tau_good', params['rr_frac_tau_good']))  # noqa: E501
        if 'rr_frac_jetmet_good' in params:
            query_params.append(('rr_frac_jetmet_good', params['rr_frac_jetmet_good']))  # noqa: E501
        if 'rr_frac_btag_good' in params:
            query_params.append(('rr_frac_btag_good', params['rr_frac_btag_good']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/run_certifications/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def destroy_run_histogram(self, id, **kwargs):  # noqa: E501
        """destroy_run_histogram  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.destroy_run_histogram(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this run histogram. (required)
        :param str run__run_number__gte: run__run_number__gte
        :param str run__run_number__lte: run__run_number__lte
        :param str run__run_number: run__run_number
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str mean: mean
        :param str mean__gte: mean__gte
        :param str mean__lte: mean__lte
        :param str rms: rms
        :param str rms__gte: rms__gte
        :param str rms__lte: rms__lte
        :param str skewness: skewness
        :param str skewness__gte: skewness__gte
        :param str skewness__lte: skewness__lte
        :param str kurtosis: kurtosis
        :param str kurtosis__gte: kurtosis__gte
        :param str kurtosis__lte: kurtosis__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str primary_dataset: primary_dataset
        :param str run__run_number__in: run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.destroy_run_histogram_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.destroy_run_histogram_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def destroy_run_histogram_with_http_info(self, id, **kwargs):  # noqa: E501
        """destroy_run_histogram  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.destroy_run_histogram_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this run histogram. (required)
        :param str run__run_number__gte: run__run_number__gte
        :param str run__run_number__lte: run__run_number__lte
        :param str run__run_number: run__run_number
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str mean: mean
        :param str mean__gte: mean__gte
        :param str mean__lte: mean__lte
        :param str rms: rms
        :param str rms__gte: rms__gte
        :param str rms__lte: rms__lte
        :param str skewness: skewness
        :param str skewness__gte: skewness__gte
        :param str skewness__lte: skewness__lte
        :param str kurtosis: kurtosis
        :param str kurtosis__gte: kurtosis__gte
        :param str kurtosis__lte: kurtosis__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str primary_dataset: primary_dataset
        :param str run__run_number__in: run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'run__run_number__gte', 'run__run_number__lte', 'run__run_number', 'entries__gte', 'entries__lte', 'mean', 'mean__gte', 'mean__lte', 'rms', 'rms__gte', 'rms__lte', 'skewness', 'skewness__gte', 'skewness__lte', 'kurtosis', 'kurtosis__gte', 'kurtosis__lte', 'source_data_file', 'title', 'primary_dataset', 'run__run_number__in', 'source_data_file__filepath__contains']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method destroy_run_histogram" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `destroy_run_histogram`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'run__run_number__gte' in params:
            query_params.append(('run__run_number__gte', params['run__run_number__gte']))  # noqa: E501
        if 'run__run_number__lte' in params:
            query_params.append(('run__run_number__lte', params['run__run_number__lte']))  # noqa: E501
        if 'run__run_number' in params:
            query_params.append(('run__run_number', params['run__run_number']))  # noqa: E501
        if 'entries__gte' in params:
            query_params.append(('entries__gte', params['entries__gte']))  # noqa: E501
        if 'entries__lte' in params:
            query_params.append(('entries__lte', params['entries__lte']))  # noqa: E501
        if 'mean' in params:
            query_params.append(('mean', params['mean']))  # noqa: E501
        if 'mean__gte' in params:
            query_params.append(('mean__gte', params['mean__gte']))  # noqa: E501
        if 'mean__lte' in params:
            query_params.append(('mean__lte', params['mean__lte']))  # noqa: E501
        if 'rms' in params:
            query_params.append(('rms', params['rms']))  # noqa: E501
        if 'rms__gte' in params:
            query_params.append(('rms__gte', params['rms__gte']))  # noqa: E501
        if 'rms__lte' in params:
            query_params.append(('rms__lte', params['rms__lte']))  # noqa: E501
        if 'skewness' in params:
            query_params.append(('skewness', params['skewness']))  # noqa: E501
        if 'skewness__gte' in params:
            query_params.append(('skewness__gte', params['skewness__gte']))  # noqa: E501
        if 'skewness__lte' in params:
            query_params.append(('skewness__lte', params['skewness__lte']))  # noqa: E501
        if 'kurtosis' in params:
            query_params.append(('kurtosis', params['kurtosis']))  # noqa: E501
        if 'kurtosis__gte' in params:
            query_params.append(('kurtosis__gte', params['kurtosis__gte']))  # noqa: E501
        if 'kurtosis__lte' in params:
            query_params.append(('kurtosis__lte', params['kurtosis__lte']))  # noqa: E501
        if 'source_data_file' in params:
            query_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'title' in params:
            query_params.append(('title', params['title']))  # noqa: E501
        if 'primary_dataset' in params:
            query_params.append(('primary_dataset', params['primary_dataset']))  # noqa: E501
        if 'run__run_number__in' in params:
            query_params.append(('run__run_number__in', params['run__run_number__in']))  # noqa: E501
        if 'source_data_file__filepath__contains' in params:
            query_params.append(('source_data_file__filepath__contains', params['source_data_file__filepath__contains']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/run_histograms/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def destroy_strategy(self, id, **kwargs):  # noqa: E501
        """destroy_strategy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.destroy_strategy(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this strategy. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.destroy_strategy_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.destroy_strategy_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def destroy_strategy_with_http_info(self, id, **kwargs):  # noqa: E501
        """destroy_strategy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.destroy_strategy_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this strategy. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method destroy_strategy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `destroy_strategy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/strategies/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def destroy_task(self, id, **kwargs):  # noqa: E501
        """destroy_task  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.destroy_task(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this task. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.destroy_task_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.destroy_task_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def destroy_task_with_http_info(self, id, **kwargs):  # noqa: E501
        """destroy_task  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.destroy_task_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this task. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method destroy_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `destroy_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/tasks/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_histogram_data_files(self, **kwargs):  # noqa: E501
        """list_histogram_data_files  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_histogram_data_files(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: A page number within the paginated result set.
        :param str id: id
        :param str data_era: data_era
        :param str data_dimensionality: data_dimensionality
        :param str granularity: granularity
        :param str processing_complete: Processing complete
        :param str entries_total__gt: entries_total__gt
        :param str entries_total__lt: entries_total__lt
        :param str filepath__contains: filepath__contains
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_histogram_data_files_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_histogram_data_files_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_histogram_data_files_with_http_info(self, **kwargs):  # noqa: E501
        """list_histogram_data_files  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_histogram_data_files_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: A page number within the paginated result set.
        :param str id: id
        :param str data_era: data_era
        :param str data_dimensionality: data_dimensionality
        :param str granularity: granularity
        :param str processing_complete: Processing complete
        :param str entries_total__gt: entries_total__gt
        :param str entries_total__lt: entries_total__lt
        :param str filepath__contains: filepath__contains
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'id', 'data_era', 'data_dimensionality', 'granularity', 'processing_complete', 'entries_total__gt', 'entries_total__lt', 'filepath__contains']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_histogram_data_files" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'data_era' in params:
            query_params.append(('data_era', params['data_era']))  # noqa: E501
        if 'data_dimensionality' in params:
            query_params.append(('data_dimensionality', params['data_dimensionality']))  # noqa: E501
        if 'granularity' in params:
            query_params.append(('granularity', params['granularity']))  # noqa: E501
        if 'processing_complete' in params:
            query_params.append(('processing_complete', params['processing_complete']))  # noqa: E501
        if 'entries_total__gt' in params:
            query_params.append(('entries_total__gt', params['entries_total__gt']))  # noqa: E501
        if 'entries_total__lt' in params:
            query_params.append(('entries_total__lt', params['entries_total__lt']))  # noqa: E501
        if 'filepath__contains' in params:
            query_params.append(('filepath__contains', params['filepath__contains']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/histogram_data_files/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_lumisection_certifications(self, **kwargs):  # noqa: E501
        """list_lumisection_certifications  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_lumisection_certifications(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: A page number within the paginated result set.
        :param str lumisection: lumisection
        :param str _date: date
        :param str rr_is_golden_json: rr_is_golden_json
        :param str rr_is_pixel_good: rr_is_pixel_good
        :param str rr_is_strip_good: rr_is_strip_good
        :param str rr_is_ecal_good: rr_is_ecal_good
        :param str rr_is_hcal_good: rr_is_hcal_good
        :param str rr_is_dt_good: rr_is_dt_good
        :param str rr_is_csc_good: rr_is_csc_good
        :param str rr_is_tracking_good: rr_is_tracking_good
        :param str rr_is_muon_good: rr_is_muon_good
        :param str rr_is_egamma_good: rr_is_egamma_good
        :param str rr_is_tau_good: rr_is_tau_good
        :param str rr_is_jetmet_good: rr_is_jetmet_good
        :param str rr_is_btag_good: rr_is_btag_good
        :param str run: run
        :return: InlineResponse20010
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_lumisection_certifications_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_lumisection_certifications_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_lumisection_certifications_with_http_info(self, **kwargs):  # noqa: E501
        """list_lumisection_certifications  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_lumisection_certifications_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: A page number within the paginated result set.
        :param str lumisection: lumisection
        :param str _date: date
        :param str rr_is_golden_json: rr_is_golden_json
        :param str rr_is_pixel_good: rr_is_pixel_good
        :param str rr_is_strip_good: rr_is_strip_good
        :param str rr_is_ecal_good: rr_is_ecal_good
        :param str rr_is_hcal_good: rr_is_hcal_good
        :param str rr_is_dt_good: rr_is_dt_good
        :param str rr_is_csc_good: rr_is_csc_good
        :param str rr_is_tracking_good: rr_is_tracking_good
        :param str rr_is_muon_good: rr_is_muon_good
        :param str rr_is_egamma_good: rr_is_egamma_good
        :param str rr_is_tau_good: rr_is_tau_good
        :param str rr_is_jetmet_good: rr_is_jetmet_good
        :param str rr_is_btag_good: rr_is_btag_good
        :param str run: run
        :return: InlineResponse20010
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'lumisection', '_date', 'rr_is_golden_json', 'rr_is_pixel_good', 'rr_is_strip_good', 'rr_is_ecal_good', 'rr_is_hcal_good', 'rr_is_dt_good', 'rr_is_csc_good', 'rr_is_tracking_good', 'rr_is_muon_good', 'rr_is_egamma_good', 'rr_is_tau_good', 'rr_is_jetmet_good', 'rr_is_btag_good', 'run']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_lumisection_certifications" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'lumisection' in params:
            query_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_golden_json' in params:
            query_params.append(('rr_is_golden_json', params['rr_is_golden_json']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            query_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            query_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            query_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            query_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            query_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            query_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            query_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            query_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            query_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            query_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            query_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            query_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'run' in params:
            query_params.append(('run', params['run']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisection_certifications/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20010',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_lumisection_histogram1_ds(self, **kwargs):  # noqa: E501
        """list_lumisection_histogram1_ds  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_lumisection_histogram1_ds(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: A page number within the paginated result set.
        :param str lumisection__run__run_number: lumisection__run__run_number
        :param str lumisection__run__run_number__gte: lumisection__run__run_number__gte
        :param str lumisection__run__run_number__lte: lumisection__run__run_number__lte
        :param str lumisection__ls_number: lumisection__ls_number
        :param str lumisection__ls_number__gte: lumisection__ls_number__gte
        :param str lumisection__ls_number__lte: lumisection__ls_number__lte
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str lumisection__ls_number__in: lumisection__ls_number__in
        :param str lumisection__run__run_number__in: lumisection__run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_lumisection_histogram1_ds_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_lumisection_histogram1_ds_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_lumisection_histogram1_ds_with_http_info(self, **kwargs):  # noqa: E501
        """list_lumisection_histogram1_ds  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_lumisection_histogram1_ds_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: A page number within the paginated result set.
        :param str lumisection__run__run_number: lumisection__run__run_number
        :param str lumisection__run__run_number__gte: lumisection__run__run_number__gte
        :param str lumisection__run__run_number__lte: lumisection__run__run_number__lte
        :param str lumisection__ls_number: lumisection__ls_number
        :param str lumisection__ls_number__gte: lumisection__ls_number__gte
        :param str lumisection__ls_number__lte: lumisection__ls_number__lte
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str lumisection__ls_number__in: lumisection__ls_number__in
        :param str lumisection__run__run_number__in: lumisection__run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'lumisection__run__run_number', 'lumisection__run__run_number__gte', 'lumisection__run__run_number__lte', 'lumisection__ls_number', 'lumisection__ls_number__gte', 'lumisection__ls_number__lte', 'entries__gte', 'entries__lte', 'source_data_file', 'title', 'lumisection__ls_number__in', 'lumisection__run__run_number__in', 'source_data_file__filepath__contains']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_lumisection_histogram1_ds" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'lumisection__run__run_number' in params:
            query_params.append(('lumisection__run__run_number', params['lumisection__run__run_number']))  # noqa: E501
        if 'lumisection__run__run_number__gte' in params:
            query_params.append(('lumisection__run__run_number__gte', params['lumisection__run__run_number__gte']))  # noqa: E501
        if 'lumisection__run__run_number__lte' in params:
            query_params.append(('lumisection__run__run_number__lte', params['lumisection__run__run_number__lte']))  # noqa: E501
        if 'lumisection__ls_number' in params:
            query_params.append(('lumisection__ls_number', params['lumisection__ls_number']))  # noqa: E501
        if 'lumisection__ls_number__gte' in params:
            query_params.append(('lumisection__ls_number__gte', params['lumisection__ls_number__gte']))  # noqa: E501
        if 'lumisection__ls_number__lte' in params:
            query_params.append(('lumisection__ls_number__lte', params['lumisection__ls_number__lte']))  # noqa: E501
        if 'entries__gte' in params:
            query_params.append(('entries__gte', params['entries__gte']))  # noqa: E501
        if 'entries__lte' in params:
            query_params.append(('entries__lte', params['entries__lte']))  # noqa: E501
        if 'source_data_file' in params:
            query_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'title' in params:
            query_params.append(('title', params['title']))  # noqa: E501
        if 'lumisection__ls_number__in' in params:
            query_params.append(('lumisection__ls_number__in', params['lumisection__ls_number__in']))  # noqa: E501
        if 'lumisection__run__run_number__in' in params:
            query_params.append(('lumisection__run__run_number__in', params['lumisection__run__run_number__in']))  # noqa: E501
        if 'source_data_file__filepath__contains' in params:
            query_params.append(('source_data_file__filepath__contains', params['source_data_file__filepath__contains']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisection_histograms_1d/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2002',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_lumisection_histogram2_ds(self, **kwargs):  # noqa: E501
        """list_lumisection_histogram2_ds  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_lumisection_histogram2_ds(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: A page number within the paginated result set.
        :param str lumisection__run__run_number: lumisection__run__run_number
        :param str lumisection__run__run_number__gte: lumisection__run__run_number__gte
        :param str lumisection__run__run_number__lte: lumisection__run__run_number__lte
        :param str lumisection__ls_number: lumisection__ls_number
        :param str lumisection__ls_number__gte: lumisection__ls_number__gte
        :param str lumisection__ls_number__lte: lumisection__ls_number__lte
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str lumisection__ls_number__in: lumisection__ls_number__in
        :param str lumisection__run__run_number__in: lumisection__run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_lumisection_histogram2_ds_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_lumisection_histogram2_ds_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_lumisection_histogram2_ds_with_http_info(self, **kwargs):  # noqa: E501
        """list_lumisection_histogram2_ds  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_lumisection_histogram2_ds_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: A page number within the paginated result set.
        :param str lumisection__run__run_number: lumisection__run__run_number
        :param str lumisection__run__run_number__gte: lumisection__run__run_number__gte
        :param str lumisection__run__run_number__lte: lumisection__run__run_number__lte
        :param str lumisection__ls_number: lumisection__ls_number
        :param str lumisection__ls_number__gte: lumisection__ls_number__gte
        :param str lumisection__ls_number__lte: lumisection__ls_number__lte
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str lumisection__ls_number__in: lumisection__ls_number__in
        :param str lumisection__run__run_number__in: lumisection__run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'lumisection__run__run_number', 'lumisection__run__run_number__gte', 'lumisection__run__run_number__lte', 'lumisection__ls_number', 'lumisection__ls_number__gte', 'lumisection__ls_number__lte', 'entries__gte', 'entries__lte', 'source_data_file', 'title', 'lumisection__ls_number__in', 'lumisection__run__run_number__in', 'source_data_file__filepath__contains']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_lumisection_histogram2_ds" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'lumisection__run__run_number' in params:
            query_params.append(('lumisection__run__run_number', params['lumisection__run__run_number']))  # noqa: E501
        if 'lumisection__run__run_number__gte' in params:
            query_params.append(('lumisection__run__run_number__gte', params['lumisection__run__run_number__gte']))  # noqa: E501
        if 'lumisection__run__run_number__lte' in params:
            query_params.append(('lumisection__run__run_number__lte', params['lumisection__run__run_number__lte']))  # noqa: E501
        if 'lumisection__ls_number' in params:
            query_params.append(('lumisection__ls_number', params['lumisection__ls_number']))  # noqa: E501
        if 'lumisection__ls_number__gte' in params:
            query_params.append(('lumisection__ls_number__gte', params['lumisection__ls_number__gte']))  # noqa: E501
        if 'lumisection__ls_number__lte' in params:
            query_params.append(('lumisection__ls_number__lte', params['lumisection__ls_number__lte']))  # noqa: E501
        if 'entries__gte' in params:
            query_params.append(('entries__gte', params['entries__gte']))  # noqa: E501
        if 'entries__lte' in params:
            query_params.append(('entries__lte', params['entries__lte']))  # noqa: E501
        if 'source_data_file' in params:
            query_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'title' in params:
            query_params.append(('title', params['title']))  # noqa: E501
        if 'lumisection__ls_number__in' in params:
            query_params.append(('lumisection__ls_number__in', params['lumisection__ls_number__in']))  # noqa: E501
        if 'lumisection__run__run_number__in' in params:
            query_params.append(('lumisection__run__run_number__in', params['lumisection__run__run_number__in']))  # noqa: E501
        if 'source_data_file__filepath__contains' in params:
            query_params.append(('source_data_file__filepath__contains', params['source_data_file__filepath__contains']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisection_histograms_2d/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2003',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_lumisections(self, **kwargs):  # noqa: E501
        """list_lumisections  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_lumisections(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: A page number within the paginated result set.
        :param str run: run
        :param str ls_number: ls_number
        :param str _date: date
        :param str oms_zerobias_rate: oms_zerobias_rate
        :return: InlineResponse2008
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_lumisections_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_lumisections_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_lumisections_with_http_info(self, **kwargs):  # noqa: E501
        """list_lumisections  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_lumisections_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: A page number within the paginated result set.
        :param str run: run
        :param str ls_number: ls_number
        :param str _date: date
        :param str oms_zerobias_rate: oms_zerobias_rate
        :return: InlineResponse2008
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'run', 'ls_number', '_date', 'oms_zerobias_rate']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_lumisections" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'run' in params:
            query_params.append(('run', params['run']))  # noqa: E501
        if 'ls_number' in params:
            query_params.append(('ls_number', params['ls_number']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'oms_zerobias_rate' in params:
            query_params.append(('oms_zerobias_rate', params['oms_zerobias_rate']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisections/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2008',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_predictions(self, **kwargs):  # noqa: E501
        """list_predictions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_predictions(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: A page number within the paginated result set.
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_predictions_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_predictions_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_predictions_with_http_info(self, **kwargs):  # noqa: E501
        """list_predictions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_predictions_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: A page number within the paginated result set.
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_predictions" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/predictions/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2006',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_run_certifications(self, **kwargs):  # noqa: E501
        """list_run_certifications  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_run_certifications(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: A page number within the paginated result set.
        :param str run: run
        :param str _date: date
        :param str rr_is_pixel_good: rr_is_pixel_good
        :param str rr_is_strip_good: rr_is_strip_good
        :param str rr_is_ecal_good: rr_is_ecal_good
        :param str rr_is_hcal_good: rr_is_hcal_good
        :param str rr_is_dt_good: rr_is_dt_good
        :param str rr_is_csc_good: rr_is_csc_good
        :param str rr_is_tracking_good: rr_is_tracking_good
        :param str rr_is_muon_good: rr_is_muon_good
        :param str rr_is_egamma_good: rr_is_egamma_good
        :param str rr_is_tau_good: rr_is_tau_good
        :param str rr_is_jetmet_good: rr_is_jetmet_good
        :param str rr_is_btag_good: rr_is_btag_good
        :param str rr_frac_pixel_good: rr_frac_pixel_good
        :param str rr_frac_strip_good: rr_frac_strip_good
        :param str rr_frac_ecal_good: rr_frac_ecal_good
        :param str rr_frac_hcal_good: rr_frac_hcal_good
        :param str rr_frac_dt_good: rr_frac_dt_good
        :param str rr_frac_csc_good: rr_frac_csc_good
        :param str rr_frac_tracking_good: rr_frac_tracking_good
        :param str rr_frac_muon_good: rr_frac_muon_good
        :param str rr_frac_egamma_good: rr_frac_egamma_good
        :param str rr_frac_tau_good: rr_frac_tau_good
        :param str rr_frac_jetmet_good: rr_frac_jetmet_good
        :param str rr_frac_btag_good: rr_frac_btag_good
        :return: InlineResponse2009
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_run_certifications_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_run_certifications_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_run_certifications_with_http_info(self, **kwargs):  # noqa: E501
        """list_run_certifications  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_run_certifications_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: A page number within the paginated result set.
        :param str run: run
        :param str _date: date
        :param str rr_is_pixel_good: rr_is_pixel_good
        :param str rr_is_strip_good: rr_is_strip_good
        :param str rr_is_ecal_good: rr_is_ecal_good
        :param str rr_is_hcal_good: rr_is_hcal_good
        :param str rr_is_dt_good: rr_is_dt_good
        :param str rr_is_csc_good: rr_is_csc_good
        :param str rr_is_tracking_good: rr_is_tracking_good
        :param str rr_is_muon_good: rr_is_muon_good
        :param str rr_is_egamma_good: rr_is_egamma_good
        :param str rr_is_tau_good: rr_is_tau_good
        :param str rr_is_jetmet_good: rr_is_jetmet_good
        :param str rr_is_btag_good: rr_is_btag_good
        :param str rr_frac_pixel_good: rr_frac_pixel_good
        :param str rr_frac_strip_good: rr_frac_strip_good
        :param str rr_frac_ecal_good: rr_frac_ecal_good
        :param str rr_frac_hcal_good: rr_frac_hcal_good
        :param str rr_frac_dt_good: rr_frac_dt_good
        :param str rr_frac_csc_good: rr_frac_csc_good
        :param str rr_frac_tracking_good: rr_frac_tracking_good
        :param str rr_frac_muon_good: rr_frac_muon_good
        :param str rr_frac_egamma_good: rr_frac_egamma_good
        :param str rr_frac_tau_good: rr_frac_tau_good
        :param str rr_frac_jetmet_good: rr_frac_jetmet_good
        :param str rr_frac_btag_good: rr_frac_btag_good
        :return: InlineResponse2009
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'run', '_date', 'rr_is_pixel_good', 'rr_is_strip_good', 'rr_is_ecal_good', 'rr_is_hcal_good', 'rr_is_dt_good', 'rr_is_csc_good', 'rr_is_tracking_good', 'rr_is_muon_good', 'rr_is_egamma_good', 'rr_is_tau_good', 'rr_is_jetmet_good', 'rr_is_btag_good', 'rr_frac_pixel_good', 'rr_frac_strip_good', 'rr_frac_ecal_good', 'rr_frac_hcal_good', 'rr_frac_dt_good', 'rr_frac_csc_good', 'rr_frac_tracking_good', 'rr_frac_muon_good', 'rr_frac_egamma_good', 'rr_frac_tau_good', 'rr_frac_jetmet_good', 'rr_frac_btag_good']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_run_certifications" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'run' in params:
            query_params.append(('run', params['run']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            query_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            query_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            query_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            query_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            query_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            query_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            query_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            query_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            query_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            query_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            query_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            query_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'rr_frac_pixel_good' in params:
            query_params.append(('rr_frac_pixel_good', params['rr_frac_pixel_good']))  # noqa: E501
        if 'rr_frac_strip_good' in params:
            query_params.append(('rr_frac_strip_good', params['rr_frac_strip_good']))  # noqa: E501
        if 'rr_frac_ecal_good' in params:
            query_params.append(('rr_frac_ecal_good', params['rr_frac_ecal_good']))  # noqa: E501
        if 'rr_frac_hcal_good' in params:
            query_params.append(('rr_frac_hcal_good', params['rr_frac_hcal_good']))  # noqa: E501
        if 'rr_frac_dt_good' in params:
            query_params.append(('rr_frac_dt_good', params['rr_frac_dt_good']))  # noqa: E501
        if 'rr_frac_csc_good' in params:
            query_params.append(('rr_frac_csc_good', params['rr_frac_csc_good']))  # noqa: E501
        if 'rr_frac_tracking_good' in params:
            query_params.append(('rr_frac_tracking_good', params['rr_frac_tracking_good']))  # noqa: E501
        if 'rr_frac_muon_good' in params:
            query_params.append(('rr_frac_muon_good', params['rr_frac_muon_good']))  # noqa: E501
        if 'rr_frac_egamma_good' in params:
            query_params.append(('rr_frac_egamma_good', params['rr_frac_egamma_good']))  # noqa: E501
        if 'rr_frac_tau_good' in params:
            query_params.append(('rr_frac_tau_good', params['rr_frac_tau_good']))  # noqa: E501
        if 'rr_frac_jetmet_good' in params:
            query_params.append(('rr_frac_jetmet_good', params['rr_frac_jetmet_good']))  # noqa: E501
        if 'rr_frac_btag_good' in params:
            query_params.append(('rr_frac_btag_good', params['rr_frac_btag_good']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/run_certifications/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2009',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_run_histograms(self, **kwargs):  # noqa: E501
        """list_run_histograms  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_run_histograms(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: A page number within the paginated result set.
        :param str run__run_number__gte: run__run_number__gte
        :param str run__run_number__lte: run__run_number__lte
        :param str run__run_number: run__run_number
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str mean: mean
        :param str mean__gte: mean__gte
        :param str mean__lte: mean__lte
        :param str rms: rms
        :param str rms__gte: rms__gte
        :param str rms__lte: rms__lte
        :param str skewness: skewness
        :param str skewness__gte: skewness__gte
        :param str skewness__lte: skewness__lte
        :param str kurtosis: kurtosis
        :param str kurtosis__gte: kurtosis__gte
        :param str kurtosis__lte: kurtosis__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str primary_dataset: primary_dataset
        :param str run__run_number__in: run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_run_histograms_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_run_histograms_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_run_histograms_with_http_info(self, **kwargs):  # noqa: E501
        """list_run_histograms  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_run_histograms_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: A page number within the paginated result set.
        :param str run__run_number__gte: run__run_number__gte
        :param str run__run_number__lte: run__run_number__lte
        :param str run__run_number: run__run_number
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str mean: mean
        :param str mean__gte: mean__gte
        :param str mean__lte: mean__lte
        :param str rms: rms
        :param str rms__gte: rms__gte
        :param str rms__lte: rms__lte
        :param str skewness: skewness
        :param str skewness__gte: skewness__gte
        :param str skewness__lte: skewness__lte
        :param str kurtosis: kurtosis
        :param str kurtosis__gte: kurtosis__gte
        :param str kurtosis__lte: kurtosis__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str primary_dataset: primary_dataset
        :param str run__run_number__in: run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'run__run_number__gte', 'run__run_number__lte', 'run__run_number', 'entries__gte', 'entries__lte', 'mean', 'mean__gte', 'mean__lte', 'rms', 'rms__gte', 'rms__lte', 'skewness', 'skewness__gte', 'skewness__lte', 'kurtosis', 'kurtosis__gte', 'kurtosis__lte', 'source_data_file', 'title', 'primary_dataset', 'run__run_number__in', 'source_data_file__filepath__contains']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_run_histograms" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'run__run_number__gte' in params:
            query_params.append(('run__run_number__gte', params['run__run_number__gte']))  # noqa: E501
        if 'run__run_number__lte' in params:
            query_params.append(('run__run_number__lte', params['run__run_number__lte']))  # noqa: E501
        if 'run__run_number' in params:
            query_params.append(('run__run_number', params['run__run_number']))  # noqa: E501
        if 'entries__gte' in params:
            query_params.append(('entries__gte', params['entries__gte']))  # noqa: E501
        if 'entries__lte' in params:
            query_params.append(('entries__lte', params['entries__lte']))  # noqa: E501
        if 'mean' in params:
            query_params.append(('mean', params['mean']))  # noqa: E501
        if 'mean__gte' in params:
            query_params.append(('mean__gte', params['mean__gte']))  # noqa: E501
        if 'mean__lte' in params:
            query_params.append(('mean__lte', params['mean__lte']))  # noqa: E501
        if 'rms' in params:
            query_params.append(('rms', params['rms']))  # noqa: E501
        if 'rms__gte' in params:
            query_params.append(('rms__gte', params['rms__gte']))  # noqa: E501
        if 'rms__lte' in params:
            query_params.append(('rms__lte', params['rms__lte']))  # noqa: E501
        if 'skewness' in params:
            query_params.append(('skewness', params['skewness']))  # noqa: E501
        if 'skewness__gte' in params:
            query_params.append(('skewness__gte', params['skewness__gte']))  # noqa: E501
        if 'skewness__lte' in params:
            query_params.append(('skewness__lte', params['skewness__lte']))  # noqa: E501
        if 'kurtosis' in params:
            query_params.append(('kurtosis', params['kurtosis']))  # noqa: E501
        if 'kurtosis__gte' in params:
            query_params.append(('kurtosis__gte', params['kurtosis__gte']))  # noqa: E501
        if 'kurtosis__lte' in params:
            query_params.append(('kurtosis__lte', params['kurtosis__lte']))  # noqa: E501
        if 'source_data_file' in params:
            query_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'title' in params:
            query_params.append(('title', params['title']))  # noqa: E501
        if 'primary_dataset' in params:
            query_params.append(('primary_dataset', params['primary_dataset']))  # noqa: E501
        if 'run__run_number__in' in params:
            query_params.append(('run__run_number__in', params['run__run_number__in']))  # noqa: E501
        if 'source_data_file__filepath__contains' in params:
            query_params.append(('source_data_file__filepath__contains', params['source_data_file__filepath__contains']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/run_histograms/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2001',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_runs(self, **kwargs):  # noqa: E501
        """list_runs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_runs(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: A page number within the paginated result set.
        :param str run_number: run_number
        :param str run_date: run_date
        :param str year: year
        :param str period: period
        :param str _date: date
        :param str oms_fill: oms_fill
        :param str oms_lumisections: oms_lumisections
        :param str oms_initial_lumi: oms_initial_lumi
        :param str oms_end_lumi: oms_end_lumi
        :return: InlineResponse2007
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_runs_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_runs_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_runs_with_http_info(self, **kwargs):  # noqa: E501
        """list_runs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_runs_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: A page number within the paginated result set.
        :param str run_number: run_number
        :param str run_date: run_date
        :param str year: year
        :param str period: period
        :param str _date: date
        :param str oms_fill: oms_fill
        :param str oms_lumisections: oms_lumisections
        :param str oms_initial_lumi: oms_initial_lumi
        :param str oms_end_lumi: oms_end_lumi
        :return: InlineResponse2007
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'run_number', 'run_date', 'year', 'period', '_date', 'oms_fill', 'oms_lumisections', 'oms_initial_lumi', 'oms_end_lumi']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_runs" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'run_number' in params:
            query_params.append(('run_number', params['run_number']))  # noqa: E501
        if 'run_date' in params:
            query_params.append(('run_date', params['run_date']))  # noqa: E501
        if 'year' in params:
            query_params.append(('year', params['year']))  # noqa: E501
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'oms_fill' in params:
            query_params.append(('oms_fill', params['oms_fill']))  # noqa: E501
        if 'oms_lumisections' in params:
            query_params.append(('oms_lumisections', params['oms_lumisections']))  # noqa: E501
        if 'oms_initial_lumi' in params:
            query_params.append(('oms_initial_lumi', params['oms_initial_lumi']))  # noqa: E501
        if 'oms_end_lumi' in params:
            query_params.append(('oms_end_lumi', params['oms_end_lumi']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/runs/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2007',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_strategys(self, **kwargs):  # noqa: E501
        """list_strategys  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_strategys(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: A page number within the paginated result set.
        :return: InlineResponse2005
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_strategys_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_strategys_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_strategys_with_http_info(self, **kwargs):  # noqa: E501
        """list_strategys  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_strategys_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: A page number within the paginated result set.
        :return: InlineResponse2005
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_strategys" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/strategies/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2005',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_tasks(self, **kwargs):  # noqa: E501
        """list_tasks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_tasks(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: A page number within the paginated result set.
        :return: InlineResponse2004
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_tasks_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_tasks_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_tasks_with_http_info(self, **kwargs):  # noqa: E501
        """list_tasks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_tasks_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: A page number within the paginated result set.
        :return: InlineResponse2004
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_tasks" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/tasks/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2004',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def partial_update_lumisection(self, id, **kwargs):  # noqa: E501
        """partial_update_lumisection  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_lumisection(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection. (required)
        :param Lumisection body:
        :param str run: run
        :param str ls_number: ls_number
        :param str _date: date
        :param str oms_zerobias_rate: oms_zerobias_rate
        :return: Lumisection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.partial_update_lumisection_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.partial_update_lumisection_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def partial_update_lumisection_with_http_info(self, id, **kwargs):  # noqa: E501
        """partial_update_lumisection  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_lumisection_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection. (required)
        :param Lumisection body:
        :param str run: run
        :param str ls_number: ls_number
        :param str _date: date
        :param str oms_zerobias_rate: oms_zerobias_rate
        :return: Lumisection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'run', 'ls_number', '_date', 'oms_zerobias_rate']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method partial_update_lumisection" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `partial_update_lumisection`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'run' in params:
            query_params.append(('run', params['run']))  # noqa: E501
        if 'ls_number' in params:
            query_params.append(('ls_number', params['ls_number']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'oms_zerobias_rate' in params:
            query_params.append(('oms_zerobias_rate', params['oms_zerobias_rate']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'ls_number' in params:
            form_params.append(('ls_number', params['ls_number']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'ls_number' in params:
            form_params.append(('ls_number', params['ls_number']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisections/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Lumisection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def partial_update_lumisection(self, id, **kwargs):  # noqa: E501
        """partial_update_lumisection  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_lumisection(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection. (required)
        :param str run2:
        :param int ls_number2:
        :param datetime _date2:
        :param str run2:
        :param int ls_number2:
        :param datetime _date2:
        :param str run: run
        :param str ls_number: ls_number
        :param str _date: date
        :param str oms_zerobias_rate: oms_zerobias_rate
        :return: Lumisection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.partial_update_lumisection_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.partial_update_lumisection_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def partial_update_lumisection_with_http_info(self, id, **kwargs):  # noqa: E501
        """partial_update_lumisection  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_lumisection_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection. (required)
        :param str run2:
        :param int ls_number2:
        :param datetime _date2:
        :param str run2:
        :param int ls_number2:
        :param datetime _date2:
        :param str run: run
        :param str ls_number: ls_number
        :param str _date: date
        :param str oms_zerobias_rate: oms_zerobias_rate
        :return: Lumisection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'run2', 'ls_number2', '_date2', 'run2', 'ls_number2', '_date2', 'run', 'ls_number', '_date', 'oms_zerobias_rate']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method partial_update_lumisection" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `partial_update_lumisection`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'run' in params:
            query_params.append(('run', params['run']))  # noqa: E501
        if 'ls_number' in params:
            query_params.append(('ls_number', params['ls_number']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'oms_zerobias_rate' in params:
            query_params.append(('oms_zerobias_rate', params['oms_zerobias_rate']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'ls_number' in params:
            form_params.append(('ls_number', params['ls_number']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'ls_number' in params:
            form_params.append(('ls_number', params['ls_number']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisections/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Lumisection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def partial_update_lumisection(self, id, **kwargs):  # noqa: E501
        """partial_update_lumisection  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_lumisection(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection. (required)
        :param str run2:
        :param int ls_number2:
        :param datetime _date2:
        :param str run2:
        :param int ls_number2:
        :param datetime _date2:
        :param str run: run
        :param str ls_number: ls_number
        :param str _date: date
        :param str oms_zerobias_rate: oms_zerobias_rate
        :return: Lumisection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.partial_update_lumisection_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.partial_update_lumisection_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def partial_update_lumisection_with_http_info(self, id, **kwargs):  # noqa: E501
        """partial_update_lumisection  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_lumisection_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection. (required)
        :param str run2:
        :param int ls_number2:
        :param datetime _date2:
        :param str run2:
        :param int ls_number2:
        :param datetime _date2:
        :param str run: run
        :param str ls_number: ls_number
        :param str _date: date
        :param str oms_zerobias_rate: oms_zerobias_rate
        :return: Lumisection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'run2', 'ls_number2', '_date2', 'run2', 'ls_number2', '_date2', 'run', 'ls_number', '_date', 'oms_zerobias_rate']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method partial_update_lumisection" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `partial_update_lumisection`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'run' in params:
            query_params.append(('run', params['run']))  # noqa: E501
        if 'ls_number' in params:
            query_params.append(('ls_number', params['ls_number']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'oms_zerobias_rate' in params:
            query_params.append(('oms_zerobias_rate', params['oms_zerobias_rate']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'ls_number' in params:
            form_params.append(('ls_number', params['ls_number']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'ls_number' in params:
            form_params.append(('ls_number', params['ls_number']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisections/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Lumisection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def partial_update_lumisection_certification(self, id, **kwargs):  # noqa: E501
        """partial_update_lumisection_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_lumisection_certification(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection certification. (required)
        :param LumisectionCertification body:
        :param str lumisection: lumisection
        :param str _date: date
        :param str rr_is_golden_json: rr_is_golden_json
        :param str rr_is_pixel_good: rr_is_pixel_good
        :param str rr_is_strip_good: rr_is_strip_good
        :param str rr_is_ecal_good: rr_is_ecal_good
        :param str rr_is_hcal_good: rr_is_hcal_good
        :param str rr_is_dt_good: rr_is_dt_good
        :param str rr_is_csc_good: rr_is_csc_good
        :param str rr_is_tracking_good: rr_is_tracking_good
        :param str rr_is_muon_good: rr_is_muon_good
        :param str rr_is_egamma_good: rr_is_egamma_good
        :param str rr_is_tau_good: rr_is_tau_good
        :param str rr_is_jetmet_good: rr_is_jetmet_good
        :param str rr_is_btag_good: rr_is_btag_good
        :param str run: run
        :return: LumisectionCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.partial_update_lumisection_certification_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.partial_update_lumisection_certification_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def partial_update_lumisection_certification_with_http_info(self, id, **kwargs):  # noqa: E501
        """partial_update_lumisection_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_lumisection_certification_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection certification. (required)
        :param LumisectionCertification body:
        :param str lumisection: lumisection
        :param str _date: date
        :param str rr_is_golden_json: rr_is_golden_json
        :param str rr_is_pixel_good: rr_is_pixel_good
        :param str rr_is_strip_good: rr_is_strip_good
        :param str rr_is_ecal_good: rr_is_ecal_good
        :param str rr_is_hcal_good: rr_is_hcal_good
        :param str rr_is_dt_good: rr_is_dt_good
        :param str rr_is_csc_good: rr_is_csc_good
        :param str rr_is_tracking_good: rr_is_tracking_good
        :param str rr_is_muon_good: rr_is_muon_good
        :param str rr_is_egamma_good: rr_is_egamma_good
        :param str rr_is_tau_good: rr_is_tau_good
        :param str rr_is_jetmet_good: rr_is_jetmet_good
        :param str rr_is_btag_good: rr_is_btag_good
        :param str run: run
        :return: LumisectionCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'lumisection', '_date', 'rr_is_golden_json', 'rr_is_pixel_good', 'rr_is_strip_good', 'rr_is_ecal_good', 'rr_is_hcal_good', 'rr_is_dt_good', 'rr_is_csc_good', 'rr_is_tracking_good', 'rr_is_muon_good', 'rr_is_egamma_good', 'rr_is_tau_good', 'rr_is_jetmet_good', 'rr_is_btag_good', 'run']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method partial_update_lumisection_certification" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `partial_update_lumisection_certification`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lumisection' in params:
            query_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_golden_json' in params:
            query_params.append(('rr_is_golden_json', params['rr_is_golden_json']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            query_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            query_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            query_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            query_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            query_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            query_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            query_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            query_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            query_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            query_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            query_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            query_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'run' in params:
            query_params.append(('run', params['run']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_golden_json' in params:
            form_params.append(('rr_is_golden_json', params['rr_is_golden_json']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            form_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            form_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            form_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            form_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            form_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            form_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            form_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            form_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            form_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            form_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            form_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            form_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_golden_json' in params:
            form_params.append(('rr_is_golden_json', params['rr_is_golden_json']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            form_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            form_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            form_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            form_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            form_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            form_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            form_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            form_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            form_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            form_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            form_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            form_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisection_certifications/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LumisectionCertification',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def partial_update_lumisection_certification(self, id, **kwargs):  # noqa: E501
        """partial_update_lumisection_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_lumisection_certification(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection certification. (required)
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param datetime _date2:
        :param bool rr_is_golden_json2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param datetime _date2:
        :param bool rr_is_golden_json2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param str lumisection: lumisection
        :param str _date: date
        :param str rr_is_golden_json: rr_is_golden_json
        :param str rr_is_pixel_good: rr_is_pixel_good
        :param str rr_is_strip_good: rr_is_strip_good
        :param str rr_is_ecal_good: rr_is_ecal_good
        :param str rr_is_hcal_good: rr_is_hcal_good
        :param str rr_is_dt_good: rr_is_dt_good
        :param str rr_is_csc_good: rr_is_csc_good
        :param str rr_is_tracking_good: rr_is_tracking_good
        :param str rr_is_muon_good: rr_is_muon_good
        :param str rr_is_egamma_good: rr_is_egamma_good
        :param str rr_is_tau_good: rr_is_tau_good
        :param str rr_is_jetmet_good: rr_is_jetmet_good
        :param str rr_is_btag_good: rr_is_btag_good
        :param str run: run
        :return: LumisectionCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.partial_update_lumisection_certification_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.partial_update_lumisection_certification_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def partial_update_lumisection_certification_with_http_info(self, id, **kwargs):  # noqa: E501
        """partial_update_lumisection_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_lumisection_certification_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection certification. (required)
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param datetime _date2:
        :param bool rr_is_golden_json2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param datetime _date2:
        :param bool rr_is_golden_json2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param str lumisection: lumisection
        :param str _date: date
        :param str rr_is_golden_json: rr_is_golden_json
        :param str rr_is_pixel_good: rr_is_pixel_good
        :param str rr_is_strip_good: rr_is_strip_good
        :param str rr_is_ecal_good: rr_is_ecal_good
        :param str rr_is_hcal_good: rr_is_hcal_good
        :param str rr_is_dt_good: rr_is_dt_good
        :param str rr_is_csc_good: rr_is_csc_good
        :param str rr_is_tracking_good: rr_is_tracking_good
        :param str rr_is_muon_good: rr_is_muon_good
        :param str rr_is_egamma_good: rr_is_egamma_good
        :param str rr_is_tau_good: rr_is_tau_good
        :param str rr_is_jetmet_good: rr_is_jetmet_good
        :param str rr_is_btag_good: rr_is_btag_good
        :param str run: run
        :return: LumisectionCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'id2', 'run2', 'lumisection2', '_date2', 'rr_is_golden_json2', 'rr_is_pixel_good2', 'rr_is_strip_good2', 'rr_is_ecal_good2', 'rr_is_hcal_good2', 'rr_is_dt_good2', 'rr_is_csc_good2', 'rr_is_tracking_good2', 'rr_is_muon_good2', 'rr_is_egamma_good2', 'rr_is_tau_good2', 'rr_is_jetmet_good2', 'rr_is_btag_good2', 'id2', 'run2', 'lumisection2', '_date2', 'rr_is_golden_json2', 'rr_is_pixel_good2', 'rr_is_strip_good2', 'rr_is_ecal_good2', 'rr_is_hcal_good2', 'rr_is_dt_good2', 'rr_is_csc_good2', 'rr_is_tracking_good2', 'rr_is_muon_good2', 'rr_is_egamma_good2', 'rr_is_tau_good2', 'rr_is_jetmet_good2', 'rr_is_btag_good2', 'lumisection', '_date', 'rr_is_golden_json', 'rr_is_pixel_good', 'rr_is_strip_good', 'rr_is_ecal_good', 'rr_is_hcal_good', 'rr_is_dt_good', 'rr_is_csc_good', 'rr_is_tracking_good', 'rr_is_muon_good', 'rr_is_egamma_good', 'rr_is_tau_good', 'rr_is_jetmet_good', 'rr_is_btag_good', 'run']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method partial_update_lumisection_certification" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `partial_update_lumisection_certification`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lumisection' in params:
            query_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_golden_json' in params:
            query_params.append(('rr_is_golden_json', params['rr_is_golden_json']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            query_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            query_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            query_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            query_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            query_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            query_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            query_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            query_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            query_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            query_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            query_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            query_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'run' in params:
            query_params.append(('run', params['run']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_golden_json' in params:
            form_params.append(('rr_is_golden_json', params['rr_is_golden_json']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            form_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            form_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            form_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            form_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            form_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            form_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            form_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            form_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            form_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            form_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            form_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            form_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_golden_json' in params:
            form_params.append(('rr_is_golden_json', params['rr_is_golden_json']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            form_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            form_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            form_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            form_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            form_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            form_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            form_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            form_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            form_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            form_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            form_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            form_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisection_certifications/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LumisectionCertification',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def partial_update_lumisection_certification(self, id, **kwargs):  # noqa: E501
        """partial_update_lumisection_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_lumisection_certification(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection certification. (required)
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param datetime _date2:
        :param bool rr_is_golden_json2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param datetime _date2:
        :param bool rr_is_golden_json2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param str lumisection: lumisection
        :param str _date: date
        :param str rr_is_golden_json: rr_is_golden_json
        :param str rr_is_pixel_good: rr_is_pixel_good
        :param str rr_is_strip_good: rr_is_strip_good
        :param str rr_is_ecal_good: rr_is_ecal_good
        :param str rr_is_hcal_good: rr_is_hcal_good
        :param str rr_is_dt_good: rr_is_dt_good
        :param str rr_is_csc_good: rr_is_csc_good
        :param str rr_is_tracking_good: rr_is_tracking_good
        :param str rr_is_muon_good: rr_is_muon_good
        :param str rr_is_egamma_good: rr_is_egamma_good
        :param str rr_is_tau_good: rr_is_tau_good
        :param str rr_is_jetmet_good: rr_is_jetmet_good
        :param str rr_is_btag_good: rr_is_btag_good
        :param str run: run
        :return: LumisectionCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.partial_update_lumisection_certification_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.partial_update_lumisection_certification_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def partial_update_lumisection_certification_with_http_info(self, id, **kwargs):  # noqa: E501
        """partial_update_lumisection_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_lumisection_certification_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection certification. (required)
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param datetime _date2:
        :param bool rr_is_golden_json2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param datetime _date2:
        :param bool rr_is_golden_json2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param str lumisection: lumisection
        :param str _date: date
        :param str rr_is_golden_json: rr_is_golden_json
        :param str rr_is_pixel_good: rr_is_pixel_good
        :param str rr_is_strip_good: rr_is_strip_good
        :param str rr_is_ecal_good: rr_is_ecal_good
        :param str rr_is_hcal_good: rr_is_hcal_good
        :param str rr_is_dt_good: rr_is_dt_good
        :param str rr_is_csc_good: rr_is_csc_good
        :param str rr_is_tracking_good: rr_is_tracking_good
        :param str rr_is_muon_good: rr_is_muon_good
        :param str rr_is_egamma_good: rr_is_egamma_good
        :param str rr_is_tau_good: rr_is_tau_good
        :param str rr_is_jetmet_good: rr_is_jetmet_good
        :param str rr_is_btag_good: rr_is_btag_good
        :param str run: run
        :return: LumisectionCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'id2', 'run2', 'lumisection2', '_date2', 'rr_is_golden_json2', 'rr_is_pixel_good2', 'rr_is_strip_good2', 'rr_is_ecal_good2', 'rr_is_hcal_good2', 'rr_is_dt_good2', 'rr_is_csc_good2', 'rr_is_tracking_good2', 'rr_is_muon_good2', 'rr_is_egamma_good2', 'rr_is_tau_good2', 'rr_is_jetmet_good2', 'rr_is_btag_good2', 'id2', 'run2', 'lumisection2', '_date2', 'rr_is_golden_json2', 'rr_is_pixel_good2', 'rr_is_strip_good2', 'rr_is_ecal_good2', 'rr_is_hcal_good2', 'rr_is_dt_good2', 'rr_is_csc_good2', 'rr_is_tracking_good2', 'rr_is_muon_good2', 'rr_is_egamma_good2', 'rr_is_tau_good2', 'rr_is_jetmet_good2', 'rr_is_btag_good2', 'lumisection', '_date', 'rr_is_golden_json', 'rr_is_pixel_good', 'rr_is_strip_good', 'rr_is_ecal_good', 'rr_is_hcal_good', 'rr_is_dt_good', 'rr_is_csc_good', 'rr_is_tracking_good', 'rr_is_muon_good', 'rr_is_egamma_good', 'rr_is_tau_good', 'rr_is_jetmet_good', 'rr_is_btag_good', 'run']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method partial_update_lumisection_certification" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `partial_update_lumisection_certification`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lumisection' in params:
            query_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_golden_json' in params:
            query_params.append(('rr_is_golden_json', params['rr_is_golden_json']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            query_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            query_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            query_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            query_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            query_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            query_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            query_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            query_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            query_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            query_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            query_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            query_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'run' in params:
            query_params.append(('run', params['run']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_golden_json' in params:
            form_params.append(('rr_is_golden_json', params['rr_is_golden_json']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            form_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            form_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            form_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            form_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            form_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            form_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            form_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            form_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            form_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            form_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            form_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            form_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_golden_json' in params:
            form_params.append(('rr_is_golden_json', params['rr_is_golden_json']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            form_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            form_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            form_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            form_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            form_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            form_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            form_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            form_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            form_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            form_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            form_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            form_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisection_certifications/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LumisectionCertification',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def partial_update_lumisection_histogram1_d(self, id, **kwargs):  # noqa: E501
        """partial_update_lumisection_histogram1_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_lumisection_histogram1_d(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection histogram1d. (required)
        :param LumisectionHistogram1D body:
        :param str lumisection__run__run_number: lumisection__run__run_number
        :param str lumisection__run__run_number__gte: lumisection__run__run_number__gte
        :param str lumisection__run__run_number__lte: lumisection__run__run_number__lte
        :param str lumisection__ls_number: lumisection__ls_number
        :param str lumisection__ls_number__gte: lumisection__ls_number__gte
        :param str lumisection__ls_number__lte: lumisection__ls_number__lte
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str lumisection__ls_number__in: lumisection__ls_number__in
        :param str lumisection__run__run_number__in: lumisection__run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: LumisectionHistogram1D
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.partial_update_lumisection_histogram1_d_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.partial_update_lumisection_histogram1_d_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def partial_update_lumisection_histogram1_d_with_http_info(self, id, **kwargs):  # noqa: E501
        """partial_update_lumisection_histogram1_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_lumisection_histogram1_d_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection histogram1d. (required)
        :param LumisectionHistogram1D body:
        :param str lumisection__run__run_number: lumisection__run__run_number
        :param str lumisection__run__run_number__gte: lumisection__run__run_number__gte
        :param str lumisection__run__run_number__lte: lumisection__run__run_number__lte
        :param str lumisection__ls_number: lumisection__ls_number
        :param str lumisection__ls_number__gte: lumisection__ls_number__gte
        :param str lumisection__ls_number__lte: lumisection__ls_number__lte
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str lumisection__ls_number__in: lumisection__ls_number__in
        :param str lumisection__run__run_number__in: lumisection__run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: LumisectionHistogram1D
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'lumisection__run__run_number', 'lumisection__run__run_number__gte', 'lumisection__run__run_number__lte', 'lumisection__ls_number', 'lumisection__ls_number__gte', 'lumisection__ls_number__lte', 'entries__gte', 'entries__lte', 'source_data_file', 'title', 'lumisection__ls_number__in', 'lumisection__run__run_number__in', 'source_data_file__filepath__contains']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method partial_update_lumisection_histogram1_d" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `partial_update_lumisection_histogram1_d`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lumisection__run__run_number' in params:
            query_params.append(('lumisection__run__run_number', params['lumisection__run__run_number']))  # noqa: E501
        if 'lumisection__run__run_number__gte' in params:
            query_params.append(('lumisection__run__run_number__gte', params['lumisection__run__run_number__gte']))  # noqa: E501
        if 'lumisection__run__run_number__lte' in params:
            query_params.append(('lumisection__run__run_number__lte', params['lumisection__run__run_number__lte']))  # noqa: E501
        if 'lumisection__ls_number' in params:
            query_params.append(('lumisection__ls_number', params['lumisection__ls_number']))  # noqa: E501
        if 'lumisection__ls_number__gte' in params:
            query_params.append(('lumisection__ls_number__gte', params['lumisection__ls_number__gte']))  # noqa: E501
        if 'lumisection__ls_number__lte' in params:
            query_params.append(('lumisection__ls_number__lte', params['lumisection__ls_number__lte']))  # noqa: E501
        if 'entries__gte' in params:
            query_params.append(('entries__gte', params['entries__gte']))  # noqa: E501
        if 'entries__lte' in params:
            query_params.append(('entries__lte', params['entries__lte']))  # noqa: E501
        if 'source_data_file' in params:
            query_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'title' in params:
            query_params.append(('title', params['title']))  # noqa: E501
        if 'lumisection__ls_number__in' in params:
            query_params.append(('lumisection__ls_number__in', params['lumisection__ls_number__in']))  # noqa: E501
        if 'lumisection__run__run_number__in' in params:
            query_params.append(('lumisection__run__run_number__in', params['lumisection__run__run_number__in']))  # noqa: E501
        if 'source_data_file__filepath__contains' in params:
            query_params.append(('source_data_file__filepath__contains', params['source_data_file__filepath__contains']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501
        if 'x_min' in params:
            form_params.append(('x_min', params['x_min']))  # noqa: E501
        if 'x_max' in params:
            form_params.append(('x_max', params['x_max']))  # noqa: E501
        if 'x_bin' in params:
            form_params.append(('x_bin', params['x_bin']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501
        if 'x_min' in params:
            form_params.append(('x_min', params['x_min']))  # noqa: E501
        if 'x_max' in params:
            form_params.append(('x_max', params['x_max']))  # noqa: E501
        if 'x_bin' in params:
            form_params.append(('x_bin', params['x_bin']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisection_histograms_1d/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LumisectionHistogram1D',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def partial_update_lumisection_histogram1_d(self, id, **kwargs):  # noqa: E501
        """partial_update_lumisection_histogram1_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_lumisection_histogram1_d(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection histogram1d. (required)
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param str title2:
        :param int entries2:
        :param list[float] data2:
        :param float x_min2:
        :param float x_max2:
        :param int x_bin2:
        :param int source_data_file2:
        :param int id2:
        :param int run:
        :param int lumisection:
        :param str title2:
        :param int entries:
        :param list[float] data:
        :param float x_min:
        :param float x_max:
        :param int x_bin:
        :param int source_data_file2:
        :param str lumisection__run__run_number: lumisection__run__run_number
        :param str lumisection__run__run_number__gte: lumisection__run__run_number__gte
        :param str lumisection__run__run_number__lte: lumisection__run__run_number__lte
        :param str lumisection__ls_number: lumisection__ls_number
        :param str lumisection__ls_number__gte: lumisection__ls_number__gte
        :param str lumisection__ls_number__lte: lumisection__ls_number__lte
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str lumisection__ls_number__in: lumisection__ls_number__in
        :param str lumisection__run__run_number__in: lumisection__run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: LumisectionHistogram1D
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.partial_update_lumisection_histogram1_d_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.partial_update_lumisection_histogram1_d_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def partial_update_lumisection_histogram1_d_with_http_info(self, id, **kwargs):  # noqa: E501
        """partial_update_lumisection_histogram1_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_lumisection_histogram1_d_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection histogram1d. (required)
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param str title2:
        :param int entries2:
        :param list[float] data2:
        :param float x_min2:
        :param float x_max2:
        :param int x_bin2:
        :param int source_data_file2:
        :param int id2:
        :param int run:
        :param int lumisection:
        :param str title2:
        :param int entries:
        :param list[float] data:
        :param float x_min:
        :param float x_max:
        :param int x_bin:
        :param int source_data_file2:
        :param str lumisection__run__run_number: lumisection__run__run_number
        :param str lumisection__run__run_number__gte: lumisection__run__run_number__gte
        :param str lumisection__run__run_number__lte: lumisection__run__run_number__lte
        :param str lumisection__ls_number: lumisection__ls_number
        :param str lumisection__ls_number__gte: lumisection__ls_number__gte
        :param str lumisection__ls_number__lte: lumisection__ls_number__lte
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str lumisection__ls_number__in: lumisection__ls_number__in
        :param str lumisection__run__run_number__in: lumisection__run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: LumisectionHistogram1D
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'id2', 'run2', 'lumisection2', 'title2', 'entries2', 'data2', 'x_min2', 'x_max2', 'x_bin2', 'source_data_file2', 'id2', 'run', 'lumisection', 'title2', 'entries', 'data', 'x_min', 'x_max', 'x_bin', 'source_data_file2', 'lumisection__run__run_number', 'lumisection__run__run_number__gte', 'lumisection__run__run_number__lte', 'lumisection__ls_number', 'lumisection__ls_number__gte', 'lumisection__ls_number__lte', 'entries__gte', 'entries__lte', 'source_data_file', 'title', 'lumisection__ls_number__in', 'lumisection__run__run_number__in', 'source_data_file__filepath__contains']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method partial_update_lumisection_histogram1_d" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `partial_update_lumisection_histogram1_d`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lumisection__run__run_number' in params:
            query_params.append(('lumisection__run__run_number', params['lumisection__run__run_number']))  # noqa: E501
        if 'lumisection__run__run_number__gte' in params:
            query_params.append(('lumisection__run__run_number__gte', params['lumisection__run__run_number__gte']))  # noqa: E501
        if 'lumisection__run__run_number__lte' in params:
            query_params.append(('lumisection__run__run_number__lte', params['lumisection__run__run_number__lte']))  # noqa: E501
        if 'lumisection__ls_number' in params:
            query_params.append(('lumisection__ls_number', params['lumisection__ls_number']))  # noqa: E501
        if 'lumisection__ls_number__gte' in params:
            query_params.append(('lumisection__ls_number__gte', params['lumisection__ls_number__gte']))  # noqa: E501
        if 'lumisection__ls_number__lte' in params:
            query_params.append(('lumisection__ls_number__lte', params['lumisection__ls_number__lte']))  # noqa: E501
        if 'entries__gte' in params:
            query_params.append(('entries__gte', params['entries__gte']))  # noqa: E501
        if 'entries__lte' in params:
            query_params.append(('entries__lte', params['entries__lte']))  # noqa: E501
        if 'source_data_file' in params:
            query_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'title' in params:
            query_params.append(('title', params['title']))  # noqa: E501
        if 'lumisection__ls_number__in' in params:
            query_params.append(('lumisection__ls_number__in', params['lumisection__ls_number__in']))  # noqa: E501
        if 'lumisection__run__run_number__in' in params:
            query_params.append(('lumisection__run__run_number__in', params['lumisection__run__run_number__in']))  # noqa: E501
        if 'source_data_file__filepath__contains' in params:
            query_params.append(('source_data_file__filepath__contains', params['source_data_file__filepath__contains']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501
        if 'x_min' in params:
            form_params.append(('x_min', params['x_min']))  # noqa: E501
        if 'x_max' in params:
            form_params.append(('x_max', params['x_max']))  # noqa: E501
        if 'x_bin' in params:
            form_params.append(('x_bin', params['x_bin']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501
        if 'x_min' in params:
            form_params.append(('x_min', params['x_min']))  # noqa: E501
        if 'x_max' in params:
            form_params.append(('x_max', params['x_max']))  # noqa: E501
        if 'x_bin' in params:
            form_params.append(('x_bin', params['x_bin']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisection_histograms_1d/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LumisectionHistogram1D',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def partial_update_lumisection_histogram1_d(self, id, **kwargs):  # noqa: E501
        """partial_update_lumisection_histogram1_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_lumisection_histogram1_d(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection histogram1d. (required)
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param str title2:
        :param int entries2:
        :param list[float] data2:
        :param float x_min2:
        :param float x_max2:
        :param int x_bin2:
        :param int source_data_file2:
        :param int id2:
        :param int run:
        :param int lumisection:
        :param str title2:
        :param int entries:
        :param list[float] data:
        :param float x_min:
        :param float x_max:
        :param int x_bin:
        :param int source_data_file2:
        :param str lumisection__run__run_number: lumisection__run__run_number
        :param str lumisection__run__run_number__gte: lumisection__run__run_number__gte
        :param str lumisection__run__run_number__lte: lumisection__run__run_number__lte
        :param str lumisection__ls_number: lumisection__ls_number
        :param str lumisection__ls_number__gte: lumisection__ls_number__gte
        :param str lumisection__ls_number__lte: lumisection__ls_number__lte
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str lumisection__ls_number__in: lumisection__ls_number__in
        :param str lumisection__run__run_number__in: lumisection__run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: LumisectionHistogram1D
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.partial_update_lumisection_histogram1_d_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.partial_update_lumisection_histogram1_d_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def partial_update_lumisection_histogram1_d_with_http_info(self, id, **kwargs):  # noqa: E501
        """partial_update_lumisection_histogram1_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_lumisection_histogram1_d_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection histogram1d. (required)
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param str title2:
        :param int entries2:
        :param list[float] data2:
        :param float x_min2:
        :param float x_max2:
        :param int x_bin2:
        :param int source_data_file2:
        :param int id2:
        :param int run:
        :param int lumisection:
        :param str title2:
        :param int entries:
        :param list[float] data:
        :param float x_min:
        :param float x_max:
        :param int x_bin:
        :param int source_data_file2:
        :param str lumisection__run__run_number: lumisection__run__run_number
        :param str lumisection__run__run_number__gte: lumisection__run__run_number__gte
        :param str lumisection__run__run_number__lte: lumisection__run__run_number__lte
        :param str lumisection__ls_number: lumisection__ls_number
        :param str lumisection__ls_number__gte: lumisection__ls_number__gte
        :param str lumisection__ls_number__lte: lumisection__ls_number__lte
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str lumisection__ls_number__in: lumisection__ls_number__in
        :param str lumisection__run__run_number__in: lumisection__run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: LumisectionHistogram1D
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'id2', 'run2', 'lumisection2', 'title2', 'entries2', 'data2', 'x_min2', 'x_max2', 'x_bin2', 'source_data_file2', 'id2', 'run', 'lumisection', 'title2', 'entries', 'data', 'x_min', 'x_max', 'x_bin', 'source_data_file2', 'lumisection__run__run_number', 'lumisection__run__run_number__gte', 'lumisection__run__run_number__lte', 'lumisection__ls_number', 'lumisection__ls_number__gte', 'lumisection__ls_number__lte', 'entries__gte', 'entries__lte', 'source_data_file', 'title', 'lumisection__ls_number__in', 'lumisection__run__run_number__in', 'source_data_file__filepath__contains']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method partial_update_lumisection_histogram1_d" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `partial_update_lumisection_histogram1_d`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lumisection__run__run_number' in params:
            query_params.append(('lumisection__run__run_number', params['lumisection__run__run_number']))  # noqa: E501
        if 'lumisection__run__run_number__gte' in params:
            query_params.append(('lumisection__run__run_number__gte', params['lumisection__run__run_number__gte']))  # noqa: E501
        if 'lumisection__run__run_number__lte' in params:
            query_params.append(('lumisection__run__run_number__lte', params['lumisection__run__run_number__lte']))  # noqa: E501
        if 'lumisection__ls_number' in params:
            query_params.append(('lumisection__ls_number', params['lumisection__ls_number']))  # noqa: E501
        if 'lumisection__ls_number__gte' in params:
            query_params.append(('lumisection__ls_number__gte', params['lumisection__ls_number__gte']))  # noqa: E501
        if 'lumisection__ls_number__lte' in params:
            query_params.append(('lumisection__ls_number__lte', params['lumisection__ls_number__lte']))  # noqa: E501
        if 'entries__gte' in params:
            query_params.append(('entries__gte', params['entries__gte']))  # noqa: E501
        if 'entries__lte' in params:
            query_params.append(('entries__lte', params['entries__lte']))  # noqa: E501
        if 'source_data_file' in params:
            query_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'title' in params:
            query_params.append(('title', params['title']))  # noqa: E501
        if 'lumisection__ls_number__in' in params:
            query_params.append(('lumisection__ls_number__in', params['lumisection__ls_number__in']))  # noqa: E501
        if 'lumisection__run__run_number__in' in params:
            query_params.append(('lumisection__run__run_number__in', params['lumisection__run__run_number__in']))  # noqa: E501
        if 'source_data_file__filepath__contains' in params:
            query_params.append(('source_data_file__filepath__contains', params['source_data_file__filepath__contains']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501
        if 'x_min' in params:
            form_params.append(('x_min', params['x_min']))  # noqa: E501
        if 'x_max' in params:
            form_params.append(('x_max', params['x_max']))  # noqa: E501
        if 'x_bin' in params:
            form_params.append(('x_bin', params['x_bin']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501
        if 'x_min' in params:
            form_params.append(('x_min', params['x_min']))  # noqa: E501
        if 'x_max' in params:
            form_params.append(('x_max', params['x_max']))  # noqa: E501
        if 'x_bin' in params:
            form_params.append(('x_bin', params['x_bin']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisection_histograms_1d/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LumisectionHistogram1D',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def partial_update_lumisection_histogram2_d(self, id, **kwargs):  # noqa: E501
        """partial_update_lumisection_histogram2_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_lumisection_histogram2_d(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection histogram2d. (required)
        :param LumisectionHistogram2D body:
        :param str lumisection__run__run_number: lumisection__run__run_number
        :param str lumisection__run__run_number__gte: lumisection__run__run_number__gte
        :param str lumisection__run__run_number__lte: lumisection__run__run_number__lte
        :param str lumisection__ls_number: lumisection__ls_number
        :param str lumisection__ls_number__gte: lumisection__ls_number__gte
        :param str lumisection__ls_number__lte: lumisection__ls_number__lte
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str lumisection__ls_number__in: lumisection__ls_number__in
        :param str lumisection__run__run_number__in: lumisection__run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: LumisectionHistogram2D
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.partial_update_lumisection_histogram2_d_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.partial_update_lumisection_histogram2_d_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def partial_update_lumisection_histogram2_d_with_http_info(self, id, **kwargs):  # noqa: E501
        """partial_update_lumisection_histogram2_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_lumisection_histogram2_d_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection histogram2d. (required)
        :param LumisectionHistogram2D body:
        :param str lumisection__run__run_number: lumisection__run__run_number
        :param str lumisection__run__run_number__gte: lumisection__run__run_number__gte
        :param str lumisection__run__run_number__lte: lumisection__run__run_number__lte
        :param str lumisection__ls_number: lumisection__ls_number
        :param str lumisection__ls_number__gte: lumisection__ls_number__gte
        :param str lumisection__ls_number__lte: lumisection__ls_number__lte
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str lumisection__ls_number__in: lumisection__ls_number__in
        :param str lumisection__run__run_number__in: lumisection__run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: LumisectionHistogram2D
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'lumisection__run__run_number', 'lumisection__run__run_number__gte', 'lumisection__run__run_number__lte', 'lumisection__ls_number', 'lumisection__ls_number__gte', 'lumisection__ls_number__lte', 'entries__gte', 'entries__lte', 'source_data_file', 'title', 'lumisection__ls_number__in', 'lumisection__run__run_number__in', 'source_data_file__filepath__contains']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method partial_update_lumisection_histogram2_d" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `partial_update_lumisection_histogram2_d`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lumisection__run__run_number' in params:
            query_params.append(('lumisection__run__run_number', params['lumisection__run__run_number']))  # noqa: E501
        if 'lumisection__run__run_number__gte' in params:
            query_params.append(('lumisection__run__run_number__gte', params['lumisection__run__run_number__gte']))  # noqa: E501
        if 'lumisection__run__run_number__lte' in params:
            query_params.append(('lumisection__run__run_number__lte', params['lumisection__run__run_number__lte']))  # noqa: E501
        if 'lumisection__ls_number' in params:
            query_params.append(('lumisection__ls_number', params['lumisection__ls_number']))  # noqa: E501
        if 'lumisection__ls_number__gte' in params:
            query_params.append(('lumisection__ls_number__gte', params['lumisection__ls_number__gte']))  # noqa: E501
        if 'lumisection__ls_number__lte' in params:
            query_params.append(('lumisection__ls_number__lte', params['lumisection__ls_number__lte']))  # noqa: E501
        if 'entries__gte' in params:
            query_params.append(('entries__gte', params['entries__gte']))  # noqa: E501
        if 'entries__lte' in params:
            query_params.append(('entries__lte', params['entries__lte']))  # noqa: E501
        if 'source_data_file' in params:
            query_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'title' in params:
            query_params.append(('title', params['title']))  # noqa: E501
        if 'lumisection__ls_number__in' in params:
            query_params.append(('lumisection__ls_number__in', params['lumisection__ls_number__in']))  # noqa: E501
        if 'lumisection__run__run_number__in' in params:
            query_params.append(('lumisection__run__run_number__in', params['lumisection__run__run_number__in']))  # noqa: E501
        if 'source_data_file__filepath__contains' in params:
            query_params.append(('source_data_file__filepath__contains', params['source_data_file__filepath__contains']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501
        if 'x_min' in params:
            form_params.append(('x_min', params['x_min']))  # noqa: E501
        if 'x_max' in params:
            form_params.append(('x_max', params['x_max']))  # noqa: E501
        if 'x_bin' in params:
            form_params.append(('x_bin', params['x_bin']))  # noqa: E501
        if 'y_max' in params:
            form_params.append(('y_max', params['y_max']))  # noqa: E501
        if 'y_min' in params:
            form_params.append(('y_min', params['y_min']))  # noqa: E501
        if 'y_bin' in params:
            form_params.append(('y_bin', params['y_bin']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501
        if 'x_min' in params:
            form_params.append(('x_min', params['x_min']))  # noqa: E501
        if 'x_max' in params:
            form_params.append(('x_max', params['x_max']))  # noqa: E501
        if 'x_bin' in params:
            form_params.append(('x_bin', params['x_bin']))  # noqa: E501
        if 'y_max' in params:
            form_params.append(('y_max', params['y_max']))  # noqa: E501
        if 'y_min' in params:
            form_params.append(('y_min', params['y_min']))  # noqa: E501
        if 'y_bin' in params:
            form_params.append(('y_bin', params['y_bin']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisection_histograms_2d/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LumisectionHistogram2D',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def partial_update_lumisection_histogram2_d(self, id, **kwargs):  # noqa: E501
        """partial_update_lumisection_histogram2_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_lumisection_histogram2_d(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection histogram2d. (required)
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param str title2:
        :param int entries2:
        :param list[list[float]] data2:
        :param float x_min2:
        :param float x_max2:
        :param int x_bin2:
        :param float y_max2:
        :param float y_min2:
        :param int y_bin2:
        :param int source_data_file2:
        :param int id2:
        :param int run:
        :param int lumisection:
        :param str title2:
        :param int entries:
        :param list[list[float]] data:
        :param float x_min:
        :param float x_max:
        :param int x_bin:
        :param float y_max:
        :param float y_min:
        :param int y_bin:
        :param int source_data_file2:
        :param str lumisection__run__run_number: lumisection__run__run_number
        :param str lumisection__run__run_number__gte: lumisection__run__run_number__gte
        :param str lumisection__run__run_number__lte: lumisection__run__run_number__lte
        :param str lumisection__ls_number: lumisection__ls_number
        :param str lumisection__ls_number__gte: lumisection__ls_number__gte
        :param str lumisection__ls_number__lte: lumisection__ls_number__lte
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str lumisection__ls_number__in: lumisection__ls_number__in
        :param str lumisection__run__run_number__in: lumisection__run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: LumisectionHistogram2D
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.partial_update_lumisection_histogram2_d_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.partial_update_lumisection_histogram2_d_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def partial_update_lumisection_histogram2_d_with_http_info(self, id, **kwargs):  # noqa: E501
        """partial_update_lumisection_histogram2_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_lumisection_histogram2_d_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection histogram2d. (required)
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param str title2:
        :param int entries2:
        :param list[list[float]] data2:
        :param float x_min2:
        :param float x_max2:
        :param int x_bin2:
        :param float y_max2:
        :param float y_min2:
        :param int y_bin2:
        :param int source_data_file2:
        :param int id2:
        :param int run:
        :param int lumisection:
        :param str title2:
        :param int entries:
        :param list[list[float]] data:
        :param float x_min:
        :param float x_max:
        :param int x_bin:
        :param float y_max:
        :param float y_min:
        :param int y_bin:
        :param int source_data_file2:
        :param str lumisection__run__run_number: lumisection__run__run_number
        :param str lumisection__run__run_number__gte: lumisection__run__run_number__gte
        :param str lumisection__run__run_number__lte: lumisection__run__run_number__lte
        :param str lumisection__ls_number: lumisection__ls_number
        :param str lumisection__ls_number__gte: lumisection__ls_number__gte
        :param str lumisection__ls_number__lte: lumisection__ls_number__lte
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str lumisection__ls_number__in: lumisection__ls_number__in
        :param str lumisection__run__run_number__in: lumisection__run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: LumisectionHistogram2D
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'id2', 'run2', 'lumisection2', 'title2', 'entries2', 'data2', 'x_min2', 'x_max2', 'x_bin2', 'y_max2', 'y_min2', 'y_bin2', 'source_data_file2', 'id2', 'run', 'lumisection', 'title2', 'entries', 'data', 'x_min', 'x_max', 'x_bin', 'y_max', 'y_min', 'y_bin', 'source_data_file2', 'lumisection__run__run_number', 'lumisection__run__run_number__gte', 'lumisection__run__run_number__lte', 'lumisection__ls_number', 'lumisection__ls_number__gte', 'lumisection__ls_number__lte', 'entries__gte', 'entries__lte', 'source_data_file', 'title', 'lumisection__ls_number__in', 'lumisection__run__run_number__in', 'source_data_file__filepath__contains']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method partial_update_lumisection_histogram2_d" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `partial_update_lumisection_histogram2_d`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lumisection__run__run_number' in params:
            query_params.append(('lumisection__run__run_number', params['lumisection__run__run_number']))  # noqa: E501
        if 'lumisection__run__run_number__gte' in params:
            query_params.append(('lumisection__run__run_number__gte', params['lumisection__run__run_number__gte']))  # noqa: E501
        if 'lumisection__run__run_number__lte' in params:
            query_params.append(('lumisection__run__run_number__lte', params['lumisection__run__run_number__lte']))  # noqa: E501
        if 'lumisection__ls_number' in params:
            query_params.append(('lumisection__ls_number', params['lumisection__ls_number']))  # noqa: E501
        if 'lumisection__ls_number__gte' in params:
            query_params.append(('lumisection__ls_number__gte', params['lumisection__ls_number__gte']))  # noqa: E501
        if 'lumisection__ls_number__lte' in params:
            query_params.append(('lumisection__ls_number__lte', params['lumisection__ls_number__lte']))  # noqa: E501
        if 'entries__gte' in params:
            query_params.append(('entries__gte', params['entries__gte']))  # noqa: E501
        if 'entries__lte' in params:
            query_params.append(('entries__lte', params['entries__lte']))  # noqa: E501
        if 'source_data_file' in params:
            query_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'title' in params:
            query_params.append(('title', params['title']))  # noqa: E501
        if 'lumisection__ls_number__in' in params:
            query_params.append(('lumisection__ls_number__in', params['lumisection__ls_number__in']))  # noqa: E501
        if 'lumisection__run__run_number__in' in params:
            query_params.append(('lumisection__run__run_number__in', params['lumisection__run__run_number__in']))  # noqa: E501
        if 'source_data_file__filepath__contains' in params:
            query_params.append(('source_data_file__filepath__contains', params['source_data_file__filepath__contains']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501
        if 'x_min' in params:
            form_params.append(('x_min', params['x_min']))  # noqa: E501
        if 'x_max' in params:
            form_params.append(('x_max', params['x_max']))  # noqa: E501
        if 'x_bin' in params:
            form_params.append(('x_bin', params['x_bin']))  # noqa: E501
        if 'y_max' in params:
            form_params.append(('y_max', params['y_max']))  # noqa: E501
        if 'y_min' in params:
            form_params.append(('y_min', params['y_min']))  # noqa: E501
        if 'y_bin' in params:
            form_params.append(('y_bin', params['y_bin']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501
        if 'x_min' in params:
            form_params.append(('x_min', params['x_min']))  # noqa: E501
        if 'x_max' in params:
            form_params.append(('x_max', params['x_max']))  # noqa: E501
        if 'x_bin' in params:
            form_params.append(('x_bin', params['x_bin']))  # noqa: E501
        if 'y_max' in params:
            form_params.append(('y_max', params['y_max']))  # noqa: E501
        if 'y_min' in params:
            form_params.append(('y_min', params['y_min']))  # noqa: E501
        if 'y_bin' in params:
            form_params.append(('y_bin', params['y_bin']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisection_histograms_2d/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LumisectionHistogram2D',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def partial_update_lumisection_histogram2_d(self, id, **kwargs):  # noqa: E501
        """partial_update_lumisection_histogram2_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_lumisection_histogram2_d(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection histogram2d. (required)
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param str title2:
        :param int entries2:
        :param list[list[float]] data2:
        :param float x_min2:
        :param float x_max2:
        :param int x_bin2:
        :param float y_max2:
        :param float y_min2:
        :param int y_bin2:
        :param int source_data_file2:
        :param int id2:
        :param int run:
        :param int lumisection:
        :param str title2:
        :param int entries:
        :param list[list[float]] data:
        :param float x_min:
        :param float x_max:
        :param int x_bin:
        :param float y_max:
        :param float y_min:
        :param int y_bin:
        :param int source_data_file2:
        :param str lumisection__run__run_number: lumisection__run__run_number
        :param str lumisection__run__run_number__gte: lumisection__run__run_number__gte
        :param str lumisection__run__run_number__lte: lumisection__run__run_number__lte
        :param str lumisection__ls_number: lumisection__ls_number
        :param str lumisection__ls_number__gte: lumisection__ls_number__gte
        :param str lumisection__ls_number__lte: lumisection__ls_number__lte
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str lumisection__ls_number__in: lumisection__ls_number__in
        :param str lumisection__run__run_number__in: lumisection__run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: LumisectionHistogram2D
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.partial_update_lumisection_histogram2_d_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.partial_update_lumisection_histogram2_d_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def partial_update_lumisection_histogram2_d_with_http_info(self, id, **kwargs):  # noqa: E501
        """partial_update_lumisection_histogram2_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_lumisection_histogram2_d_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection histogram2d. (required)
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param str title2:
        :param int entries2:
        :param list[list[float]] data2:
        :param float x_min2:
        :param float x_max2:
        :param int x_bin2:
        :param float y_max2:
        :param float y_min2:
        :param int y_bin2:
        :param int source_data_file2:
        :param int id2:
        :param int run:
        :param int lumisection:
        :param str title2:
        :param int entries:
        :param list[list[float]] data:
        :param float x_min:
        :param float x_max:
        :param int x_bin:
        :param float y_max:
        :param float y_min:
        :param int y_bin:
        :param int source_data_file2:
        :param str lumisection__run__run_number: lumisection__run__run_number
        :param str lumisection__run__run_number__gte: lumisection__run__run_number__gte
        :param str lumisection__run__run_number__lte: lumisection__run__run_number__lte
        :param str lumisection__ls_number: lumisection__ls_number
        :param str lumisection__ls_number__gte: lumisection__ls_number__gte
        :param str lumisection__ls_number__lte: lumisection__ls_number__lte
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str lumisection__ls_number__in: lumisection__ls_number__in
        :param str lumisection__run__run_number__in: lumisection__run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: LumisectionHistogram2D
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'id2', 'run2', 'lumisection2', 'title2', 'entries2', 'data2', 'x_min2', 'x_max2', 'x_bin2', 'y_max2', 'y_min2', 'y_bin2', 'source_data_file2', 'id2', 'run', 'lumisection', 'title2', 'entries', 'data', 'x_min', 'x_max', 'x_bin', 'y_max', 'y_min', 'y_bin', 'source_data_file2', 'lumisection__run__run_number', 'lumisection__run__run_number__gte', 'lumisection__run__run_number__lte', 'lumisection__ls_number', 'lumisection__ls_number__gte', 'lumisection__ls_number__lte', 'entries__gte', 'entries__lte', 'source_data_file', 'title', 'lumisection__ls_number__in', 'lumisection__run__run_number__in', 'source_data_file__filepath__contains']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method partial_update_lumisection_histogram2_d" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `partial_update_lumisection_histogram2_d`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lumisection__run__run_number' in params:
            query_params.append(('lumisection__run__run_number', params['lumisection__run__run_number']))  # noqa: E501
        if 'lumisection__run__run_number__gte' in params:
            query_params.append(('lumisection__run__run_number__gte', params['lumisection__run__run_number__gte']))  # noqa: E501
        if 'lumisection__run__run_number__lte' in params:
            query_params.append(('lumisection__run__run_number__lte', params['lumisection__run__run_number__lte']))  # noqa: E501
        if 'lumisection__ls_number' in params:
            query_params.append(('lumisection__ls_number', params['lumisection__ls_number']))  # noqa: E501
        if 'lumisection__ls_number__gte' in params:
            query_params.append(('lumisection__ls_number__gte', params['lumisection__ls_number__gte']))  # noqa: E501
        if 'lumisection__ls_number__lte' in params:
            query_params.append(('lumisection__ls_number__lte', params['lumisection__ls_number__lte']))  # noqa: E501
        if 'entries__gte' in params:
            query_params.append(('entries__gte', params['entries__gte']))  # noqa: E501
        if 'entries__lte' in params:
            query_params.append(('entries__lte', params['entries__lte']))  # noqa: E501
        if 'source_data_file' in params:
            query_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'title' in params:
            query_params.append(('title', params['title']))  # noqa: E501
        if 'lumisection__ls_number__in' in params:
            query_params.append(('lumisection__ls_number__in', params['lumisection__ls_number__in']))  # noqa: E501
        if 'lumisection__run__run_number__in' in params:
            query_params.append(('lumisection__run__run_number__in', params['lumisection__run__run_number__in']))  # noqa: E501
        if 'source_data_file__filepath__contains' in params:
            query_params.append(('source_data_file__filepath__contains', params['source_data_file__filepath__contains']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501
        if 'x_min' in params:
            form_params.append(('x_min', params['x_min']))  # noqa: E501
        if 'x_max' in params:
            form_params.append(('x_max', params['x_max']))  # noqa: E501
        if 'x_bin' in params:
            form_params.append(('x_bin', params['x_bin']))  # noqa: E501
        if 'y_max' in params:
            form_params.append(('y_max', params['y_max']))  # noqa: E501
        if 'y_min' in params:
            form_params.append(('y_min', params['y_min']))  # noqa: E501
        if 'y_bin' in params:
            form_params.append(('y_bin', params['y_bin']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501
        if 'x_min' in params:
            form_params.append(('x_min', params['x_min']))  # noqa: E501
        if 'x_max' in params:
            form_params.append(('x_max', params['x_max']))  # noqa: E501
        if 'x_bin' in params:
            form_params.append(('x_bin', params['x_bin']))  # noqa: E501
        if 'y_max' in params:
            form_params.append(('y_max', params['y_max']))  # noqa: E501
        if 'y_min' in params:
            form_params.append(('y_min', params['y_min']))  # noqa: E501
        if 'y_bin' in params:
            form_params.append(('y_bin', params['y_bin']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisection_histograms_2d/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LumisectionHistogram2D',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def partial_update_prediction(self, id, **kwargs):  # noqa: E501
        """partial_update_prediction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_prediction(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this prediction. (required)
        :param Prediction body:
        :return: Prediction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.partial_update_prediction_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.partial_update_prediction_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def partial_update_prediction_with_http_info(self, id, **kwargs):  # noqa: E501
        """partial_update_prediction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_prediction_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this prediction. (required)
        :param Prediction body:
        :return: Prediction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method partial_update_prediction" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `partial_update_prediction`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'strategy' in params:
            form_params.append(('strategy', params['strategy']))  # noqa: E501
        if 'run_histograms' in params:
            form_params.append(('run_histograms', params['run_histograms']))  # noqa: E501
            collection_formats['run_histograms'] = 'multi'  # noqa: E501
        if 'lumisection_histograms_1d' in params:
            form_params.append(('lumisection_histograms_1d', params['lumisection_histograms_1d']))  # noqa: E501
            collection_formats['lumisection_histograms_1d'] = 'multi'  # noqa: E501
        if 'lumisection_histograms_2d' in params:
            form_params.append(('lumisection_histograms_2d', params['lumisection_histograms_2d']))  # noqa: E501
            collection_formats['lumisection_histograms_2d'] = 'multi'  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501
        if 'task' in params:
            form_params.append(('task', params['task']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'strategy' in params:
            form_params.append(('strategy', params['strategy']))  # noqa: E501
        if 'run_histograms' in params:
            form_params.append(('run_histograms', params['run_histograms']))  # noqa: E501
            collection_formats['run_histograms'] = 'multi'  # noqa: E501
        if 'lumisection_histograms_1d' in params:
            form_params.append(('lumisection_histograms_1d', params['lumisection_histograms_1d']))  # noqa: E501
            collection_formats['lumisection_histograms_1d'] = 'multi'  # noqa: E501
        if 'lumisection_histograms_2d' in params:
            form_params.append(('lumisection_histograms_2d', params['lumisection_histograms_2d']))  # noqa: E501
            collection_formats['lumisection_histograms_2d'] = 'multi'  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501
        if 'task' in params:
            form_params.append(('task', params['task']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/predictions/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Prediction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def partial_update_prediction(self, id, **kwargs):  # noqa: E501
        """partial_update_prediction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_prediction(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this prediction. (required)
        :param int id2:
        :param str strategy2:
        :param list[PredictionRunHistograms] run_histograms2:
        :param list[PredictionLumisectionHistograms1d] lumisection_histograms_1d2:
        :param list[PredictionLumisectionHistograms2d] lumisection_histograms_2d2:
        :param datetime created2:
        :param datetime modified2:
        :param int task2:
        :param int id2:
        :param str strategy:
        :param list[PredictionRunHistograms] run_histograms:
        :param list[PredictionLumisectionHistograms1d] lumisection_histograms_1d:
        :param list[PredictionLumisectionHistograms2d] lumisection_histograms_2d:
        :param datetime created:
        :param datetime modified:
        :param int task:
        :return: Prediction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.partial_update_prediction_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.partial_update_prediction_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def partial_update_prediction_with_http_info(self, id, **kwargs):  # noqa: E501
        """partial_update_prediction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_prediction_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this prediction. (required)
        :param int id2:
        :param str strategy2:
        :param list[PredictionRunHistograms] run_histograms2:
        :param list[PredictionLumisectionHistograms1d] lumisection_histograms_1d2:
        :param list[PredictionLumisectionHistograms2d] lumisection_histograms_2d2:
        :param datetime created2:
        :param datetime modified2:
        :param int task2:
        :param int id2:
        :param str strategy:
        :param list[PredictionRunHistograms] run_histograms:
        :param list[PredictionLumisectionHistograms1d] lumisection_histograms_1d:
        :param list[PredictionLumisectionHistograms2d] lumisection_histograms_2d:
        :param datetime created:
        :param datetime modified:
        :param int task:
        :return: Prediction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'id2', 'strategy2', 'run_histograms2', 'lumisection_histograms_1d2', 'lumisection_histograms_2d2', 'created2', 'modified2', 'task2', 'id2', 'strategy', 'run_histograms', 'lumisection_histograms_1d', 'lumisection_histograms_2d', 'created', 'modified', 'task']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method partial_update_prediction" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `partial_update_prediction`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'strategy' in params:
            form_params.append(('strategy', params['strategy']))  # noqa: E501
        if 'run_histograms' in params:
            form_params.append(('run_histograms', params['run_histograms']))  # noqa: E501
            collection_formats['run_histograms'] = 'multi'  # noqa: E501
        if 'lumisection_histograms_1d' in params:
            form_params.append(('lumisection_histograms_1d', params['lumisection_histograms_1d']))  # noqa: E501
            collection_formats['lumisection_histograms_1d'] = 'multi'  # noqa: E501
        if 'lumisection_histograms_2d' in params:
            form_params.append(('lumisection_histograms_2d', params['lumisection_histograms_2d']))  # noqa: E501
            collection_formats['lumisection_histograms_2d'] = 'multi'  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501
        if 'task' in params:
            form_params.append(('task', params['task']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'strategy' in params:
            form_params.append(('strategy', params['strategy']))  # noqa: E501
        if 'run_histograms' in params:
            form_params.append(('run_histograms', params['run_histograms']))  # noqa: E501
            collection_formats['run_histograms'] = 'multi'  # noqa: E501
        if 'lumisection_histograms_1d' in params:
            form_params.append(('lumisection_histograms_1d', params['lumisection_histograms_1d']))  # noqa: E501
            collection_formats['lumisection_histograms_1d'] = 'multi'  # noqa: E501
        if 'lumisection_histograms_2d' in params:
            form_params.append(('lumisection_histograms_2d', params['lumisection_histograms_2d']))  # noqa: E501
            collection_formats['lumisection_histograms_2d'] = 'multi'  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501
        if 'task' in params:
            form_params.append(('task', params['task']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/predictions/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Prediction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def partial_update_prediction(self, id, **kwargs):  # noqa: E501
        """partial_update_prediction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_prediction(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this prediction. (required)
        :param int id2:
        :param str strategy2:
        :param list[PredictionRunHistograms] run_histograms2:
        :param list[PredictionLumisectionHistograms1d] lumisection_histograms_1d2:
        :param list[PredictionLumisectionHistograms2d] lumisection_histograms_2d2:
        :param datetime created2:
        :param datetime modified2:
        :param int task2:
        :param int id2:
        :param str strategy:
        :param list[PredictionRunHistograms] run_histograms:
        :param list[PredictionLumisectionHistograms1d] lumisection_histograms_1d:
        :param list[PredictionLumisectionHistograms2d] lumisection_histograms_2d:
        :param datetime created:
        :param datetime modified:
        :param int task:
        :return: Prediction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.partial_update_prediction_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.partial_update_prediction_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def partial_update_prediction_with_http_info(self, id, **kwargs):  # noqa: E501
        """partial_update_prediction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_prediction_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this prediction. (required)
        :param int id2:
        :param str strategy2:
        :param list[PredictionRunHistograms] run_histograms2:
        :param list[PredictionLumisectionHistograms1d] lumisection_histograms_1d2:
        :param list[PredictionLumisectionHistograms2d] lumisection_histograms_2d2:
        :param datetime created2:
        :param datetime modified2:
        :param int task2:
        :param int id2:
        :param str strategy:
        :param list[PredictionRunHistograms] run_histograms:
        :param list[PredictionLumisectionHistograms1d] lumisection_histograms_1d:
        :param list[PredictionLumisectionHistograms2d] lumisection_histograms_2d:
        :param datetime created:
        :param datetime modified:
        :param int task:
        :return: Prediction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'id2', 'strategy2', 'run_histograms2', 'lumisection_histograms_1d2', 'lumisection_histograms_2d2', 'created2', 'modified2', 'task2', 'id2', 'strategy', 'run_histograms', 'lumisection_histograms_1d', 'lumisection_histograms_2d', 'created', 'modified', 'task']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method partial_update_prediction" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `partial_update_prediction`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'strategy' in params:
            form_params.append(('strategy', params['strategy']))  # noqa: E501
        if 'run_histograms' in params:
            form_params.append(('run_histograms', params['run_histograms']))  # noqa: E501
            collection_formats['run_histograms'] = 'multi'  # noqa: E501
        if 'lumisection_histograms_1d' in params:
            form_params.append(('lumisection_histograms_1d', params['lumisection_histograms_1d']))  # noqa: E501
            collection_formats['lumisection_histograms_1d'] = 'multi'  # noqa: E501
        if 'lumisection_histograms_2d' in params:
            form_params.append(('lumisection_histograms_2d', params['lumisection_histograms_2d']))  # noqa: E501
            collection_formats['lumisection_histograms_2d'] = 'multi'  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501
        if 'task' in params:
            form_params.append(('task', params['task']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'strategy' in params:
            form_params.append(('strategy', params['strategy']))  # noqa: E501
        if 'run_histograms' in params:
            form_params.append(('run_histograms', params['run_histograms']))  # noqa: E501
            collection_formats['run_histograms'] = 'multi'  # noqa: E501
        if 'lumisection_histograms_1d' in params:
            form_params.append(('lumisection_histograms_1d', params['lumisection_histograms_1d']))  # noqa: E501
            collection_formats['lumisection_histograms_1d'] = 'multi'  # noqa: E501
        if 'lumisection_histograms_2d' in params:
            form_params.append(('lumisection_histograms_2d', params['lumisection_histograms_2d']))  # noqa: E501
            collection_formats['lumisection_histograms_2d'] = 'multi'  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501
        if 'task' in params:
            form_params.append(('task', params['task']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/predictions/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Prediction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def partial_update_run(self, run_number, **kwargs):  # noqa: E501
        """partial_update_run  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_run(run_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str run_number: A unique value identifying this run. (required)
        :param Run body:
        :param str run_number2: run_number
        :param str run_date: run_date
        :param str year: year
        :param str period: period
        :param str _date: date
        :param str oms_fill: oms_fill
        :param str oms_lumisections: oms_lumisections
        :param str oms_initial_lumi: oms_initial_lumi
        :param str oms_end_lumi: oms_end_lumi
        :return: Run
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.partial_update_run_with_http_info(run_number, **kwargs)  # noqa: E501
        else:
            (data) = self.partial_update_run_with_http_info(run_number, **kwargs)  # noqa: E501
            return data

    def partial_update_run_with_http_info(self, run_number, **kwargs):  # noqa: E501
        """partial_update_run  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_run_with_http_info(run_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str run_number: A unique value identifying this run. (required)
        :param Run body:
        :param str run_number2: run_number
        :param str run_date: run_date
        :param str year: year
        :param str period: period
        :param str _date: date
        :param str oms_fill: oms_fill
        :param str oms_lumisections: oms_lumisections
        :param str oms_initial_lumi: oms_initial_lumi
        :param str oms_end_lumi: oms_end_lumi
        :return: Run
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['run_number', 'body', 'run_number2', 'run_date', 'year', 'period', '_date', 'oms_fill', 'oms_lumisections', 'oms_initial_lumi', 'oms_end_lumi']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method partial_update_run" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'run_number' is set
        if ('run_number' not in params or
                params['run_number'] is None):
            raise ValueError("Missing the required parameter `run_number` when calling `partial_update_run`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'run_number' in params:
            path_params['run_number'] = params['run_number']  # noqa: E501

        query_params = []
        if 'run_number' in params:
            query_params.append(('run_number', params['run_number']))  # noqa: E501
        if 'run_date' in params:
            query_params.append(('run_date', params['run_date']))  # noqa: E501
        if 'year' in params:
            query_params.append(('year', params['year']))  # noqa: E501
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'oms_fill' in params:
            query_params.append(('oms_fill', params['oms_fill']))  # noqa: E501
        if 'oms_lumisections' in params:
            query_params.append(('oms_lumisections', params['oms_lumisections']))  # noqa: E501
        if 'oms_initial_lumi' in params:
            query_params.append(('oms_initial_lumi', params['oms_initial_lumi']))  # noqa: E501
        if 'oms_end_lumi' in params:
            query_params.append(('oms_end_lumi', params['oms_end_lumi']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'run_number' in params:
            form_params.append(('run_number', params['run_number']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'run_number' in params:
            form_params.append(('run_number', params['run_number']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/runs/{run_number}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Run',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def partial_update_run(self, run_number, **kwargs):  # noqa: E501
        """partial_update_run  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_run(run_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str run_number: A unique value identifying this run. (required)
        :param int run_number2:
        :param datetime _date2:
        :param int run_number2:
        :param datetime _date2:
        :param str run_number2: run_number
        :param str run_date: run_date
        :param str year: year
        :param str period: period
        :param str _date: date
        :param str oms_fill: oms_fill
        :param str oms_lumisections: oms_lumisections
        :param str oms_initial_lumi: oms_initial_lumi
        :param str oms_end_lumi: oms_end_lumi
        :return: Run
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.partial_update_run_with_http_info(run_number, **kwargs)  # noqa: E501
        else:
            (data) = self.partial_update_run_with_http_info(run_number, **kwargs)  # noqa: E501
            return data

    def partial_update_run_with_http_info(self, run_number, **kwargs):  # noqa: E501
        """partial_update_run  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_run_with_http_info(run_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str run_number: A unique value identifying this run. (required)
        :param int run_number2:
        :param datetime _date2:
        :param int run_number2:
        :param datetime _date2:
        :param str run_number2: run_number
        :param str run_date: run_date
        :param str year: year
        :param str period: period
        :param str _date: date
        :param str oms_fill: oms_fill
        :param str oms_lumisections: oms_lumisections
        :param str oms_initial_lumi: oms_initial_lumi
        :param str oms_end_lumi: oms_end_lumi
        :return: Run
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['run_number', 'run_number2', '_date2', 'run_number2', '_date2', 'run_number2', 'run_date', 'year', 'period', '_date', 'oms_fill', 'oms_lumisections', 'oms_initial_lumi', 'oms_end_lumi']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method partial_update_run" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'run_number' is set
        if ('run_number' not in params or
                params['run_number'] is None):
            raise ValueError("Missing the required parameter `run_number` when calling `partial_update_run`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'run_number' in params:
            path_params['run_number'] = params['run_number']  # noqa: E501

        query_params = []
        if 'run_number' in params:
            query_params.append(('run_number', params['run_number']))  # noqa: E501
        if 'run_date' in params:
            query_params.append(('run_date', params['run_date']))  # noqa: E501
        if 'year' in params:
            query_params.append(('year', params['year']))  # noqa: E501
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'oms_fill' in params:
            query_params.append(('oms_fill', params['oms_fill']))  # noqa: E501
        if 'oms_lumisections' in params:
            query_params.append(('oms_lumisections', params['oms_lumisections']))  # noqa: E501
        if 'oms_initial_lumi' in params:
            query_params.append(('oms_initial_lumi', params['oms_initial_lumi']))  # noqa: E501
        if 'oms_end_lumi' in params:
            query_params.append(('oms_end_lumi', params['oms_end_lumi']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'run_number' in params:
            form_params.append(('run_number', params['run_number']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'run_number' in params:
            form_params.append(('run_number', params['run_number']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/runs/{run_number}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Run',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def partial_update_run(self, run_number, **kwargs):  # noqa: E501
        """partial_update_run  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_run(run_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str run_number: A unique value identifying this run. (required)
        :param int run_number2:
        :param datetime _date2:
        :param int run_number2:
        :param datetime _date2:
        :param str run_number2: run_number
        :param str run_date: run_date
        :param str year: year
        :param str period: period
        :param str _date: date
        :param str oms_fill: oms_fill
        :param str oms_lumisections: oms_lumisections
        :param str oms_initial_lumi: oms_initial_lumi
        :param str oms_end_lumi: oms_end_lumi
        :return: Run
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.partial_update_run_with_http_info(run_number, **kwargs)  # noqa: E501
        else:
            (data) = self.partial_update_run_with_http_info(run_number, **kwargs)  # noqa: E501
            return data

    def partial_update_run_with_http_info(self, run_number, **kwargs):  # noqa: E501
        """partial_update_run  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_run_with_http_info(run_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str run_number: A unique value identifying this run. (required)
        :param int run_number2:
        :param datetime _date2:
        :param int run_number2:
        :param datetime _date2:
        :param str run_number2: run_number
        :param str run_date: run_date
        :param str year: year
        :param str period: period
        :param str _date: date
        :param str oms_fill: oms_fill
        :param str oms_lumisections: oms_lumisections
        :param str oms_initial_lumi: oms_initial_lumi
        :param str oms_end_lumi: oms_end_lumi
        :return: Run
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['run_number', 'run_number2', '_date2', 'run_number2', '_date2', 'run_number2', 'run_date', 'year', 'period', '_date', 'oms_fill', 'oms_lumisections', 'oms_initial_lumi', 'oms_end_lumi']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method partial_update_run" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'run_number' is set
        if ('run_number' not in params or
                params['run_number'] is None):
            raise ValueError("Missing the required parameter `run_number` when calling `partial_update_run`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'run_number' in params:
            path_params['run_number'] = params['run_number']  # noqa: E501

        query_params = []
        if 'run_number' in params:
            query_params.append(('run_number', params['run_number']))  # noqa: E501
        if 'run_date' in params:
            query_params.append(('run_date', params['run_date']))  # noqa: E501
        if 'year' in params:
            query_params.append(('year', params['year']))  # noqa: E501
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'oms_fill' in params:
            query_params.append(('oms_fill', params['oms_fill']))  # noqa: E501
        if 'oms_lumisections' in params:
            query_params.append(('oms_lumisections', params['oms_lumisections']))  # noqa: E501
        if 'oms_initial_lumi' in params:
            query_params.append(('oms_initial_lumi', params['oms_initial_lumi']))  # noqa: E501
        if 'oms_end_lumi' in params:
            query_params.append(('oms_end_lumi', params['oms_end_lumi']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'run_number' in params:
            form_params.append(('run_number', params['run_number']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'run_number' in params:
            form_params.append(('run_number', params['run_number']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/runs/{run_number}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Run',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def partial_update_run_certification(self, id, **kwargs):  # noqa: E501
        """partial_update_run_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_run_certification(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this run certification. (required)
        :param RunCertification body:
        :param str run: run
        :param str _date: date
        :param str rr_is_pixel_good: rr_is_pixel_good
        :param str rr_is_strip_good: rr_is_strip_good
        :param str rr_is_ecal_good: rr_is_ecal_good
        :param str rr_is_hcal_good: rr_is_hcal_good
        :param str rr_is_dt_good: rr_is_dt_good
        :param str rr_is_csc_good: rr_is_csc_good
        :param str rr_is_tracking_good: rr_is_tracking_good
        :param str rr_is_muon_good: rr_is_muon_good
        :param str rr_is_egamma_good: rr_is_egamma_good
        :param str rr_is_tau_good: rr_is_tau_good
        :param str rr_is_jetmet_good: rr_is_jetmet_good
        :param str rr_is_btag_good: rr_is_btag_good
        :param str rr_frac_pixel_good: rr_frac_pixel_good
        :param str rr_frac_strip_good: rr_frac_strip_good
        :param str rr_frac_ecal_good: rr_frac_ecal_good
        :param str rr_frac_hcal_good: rr_frac_hcal_good
        :param str rr_frac_dt_good: rr_frac_dt_good
        :param str rr_frac_csc_good: rr_frac_csc_good
        :param str rr_frac_tracking_good: rr_frac_tracking_good
        :param str rr_frac_muon_good: rr_frac_muon_good
        :param str rr_frac_egamma_good: rr_frac_egamma_good
        :param str rr_frac_tau_good: rr_frac_tau_good
        :param str rr_frac_jetmet_good: rr_frac_jetmet_good
        :param str rr_frac_btag_good: rr_frac_btag_good
        :return: RunCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.partial_update_run_certification_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.partial_update_run_certification_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def partial_update_run_certification_with_http_info(self, id, **kwargs):  # noqa: E501
        """partial_update_run_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_run_certification_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this run certification. (required)
        :param RunCertification body:
        :param str run: run
        :param str _date: date
        :param str rr_is_pixel_good: rr_is_pixel_good
        :param str rr_is_strip_good: rr_is_strip_good
        :param str rr_is_ecal_good: rr_is_ecal_good
        :param str rr_is_hcal_good: rr_is_hcal_good
        :param str rr_is_dt_good: rr_is_dt_good
        :param str rr_is_csc_good: rr_is_csc_good
        :param str rr_is_tracking_good: rr_is_tracking_good
        :param str rr_is_muon_good: rr_is_muon_good
        :param str rr_is_egamma_good: rr_is_egamma_good
        :param str rr_is_tau_good: rr_is_tau_good
        :param str rr_is_jetmet_good: rr_is_jetmet_good
        :param str rr_is_btag_good: rr_is_btag_good
        :param str rr_frac_pixel_good: rr_frac_pixel_good
        :param str rr_frac_strip_good: rr_frac_strip_good
        :param str rr_frac_ecal_good: rr_frac_ecal_good
        :param str rr_frac_hcal_good: rr_frac_hcal_good
        :param str rr_frac_dt_good: rr_frac_dt_good
        :param str rr_frac_csc_good: rr_frac_csc_good
        :param str rr_frac_tracking_good: rr_frac_tracking_good
        :param str rr_frac_muon_good: rr_frac_muon_good
        :param str rr_frac_egamma_good: rr_frac_egamma_good
        :param str rr_frac_tau_good: rr_frac_tau_good
        :param str rr_frac_jetmet_good: rr_frac_jetmet_good
        :param str rr_frac_btag_good: rr_frac_btag_good
        :return: RunCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'run', '_date', 'rr_is_pixel_good', 'rr_is_strip_good', 'rr_is_ecal_good', 'rr_is_hcal_good', 'rr_is_dt_good', 'rr_is_csc_good', 'rr_is_tracking_good', 'rr_is_muon_good', 'rr_is_egamma_good', 'rr_is_tau_good', 'rr_is_jetmet_good', 'rr_is_btag_good', 'rr_frac_pixel_good', 'rr_frac_strip_good', 'rr_frac_ecal_good', 'rr_frac_hcal_good', 'rr_frac_dt_good', 'rr_frac_csc_good', 'rr_frac_tracking_good', 'rr_frac_muon_good', 'rr_frac_egamma_good', 'rr_frac_tau_good', 'rr_frac_jetmet_good', 'rr_frac_btag_good']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method partial_update_run_certification" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `partial_update_run_certification`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'run' in params:
            query_params.append(('run', params['run']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            query_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            query_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            query_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            query_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            query_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            query_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            query_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            query_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            query_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            query_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            query_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            query_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'rr_frac_pixel_good' in params:
            query_params.append(('rr_frac_pixel_good', params['rr_frac_pixel_good']))  # noqa: E501
        if 'rr_frac_strip_good' in params:
            query_params.append(('rr_frac_strip_good', params['rr_frac_strip_good']))  # noqa: E501
        if 'rr_frac_ecal_good' in params:
            query_params.append(('rr_frac_ecal_good', params['rr_frac_ecal_good']))  # noqa: E501
        if 'rr_frac_hcal_good' in params:
            query_params.append(('rr_frac_hcal_good', params['rr_frac_hcal_good']))  # noqa: E501
        if 'rr_frac_dt_good' in params:
            query_params.append(('rr_frac_dt_good', params['rr_frac_dt_good']))  # noqa: E501
        if 'rr_frac_csc_good' in params:
            query_params.append(('rr_frac_csc_good', params['rr_frac_csc_good']))  # noqa: E501
        if 'rr_frac_tracking_good' in params:
            query_params.append(('rr_frac_tracking_good', params['rr_frac_tracking_good']))  # noqa: E501
        if 'rr_frac_muon_good' in params:
            query_params.append(('rr_frac_muon_good', params['rr_frac_muon_good']))  # noqa: E501
        if 'rr_frac_egamma_good' in params:
            query_params.append(('rr_frac_egamma_good', params['rr_frac_egamma_good']))  # noqa: E501
        if 'rr_frac_tau_good' in params:
            query_params.append(('rr_frac_tau_good', params['rr_frac_tau_good']))  # noqa: E501
        if 'rr_frac_jetmet_good' in params:
            query_params.append(('rr_frac_jetmet_good', params['rr_frac_jetmet_good']))  # noqa: E501
        if 'rr_frac_btag_good' in params:
            query_params.append(('rr_frac_btag_good', params['rr_frac_btag_good']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            form_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            form_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            form_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            form_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            form_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            form_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            form_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            form_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            form_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            form_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            form_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            form_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'rr_frac_pixel_good' in params:
            form_params.append(('rr_frac_pixel_good', params['rr_frac_pixel_good']))  # noqa: E501
        if 'rr_frac_strip_good' in params:
            form_params.append(('rr_frac_strip_good', params['rr_frac_strip_good']))  # noqa: E501
        if 'rr_frac_ecal_good' in params:
            form_params.append(('rr_frac_ecal_good', params['rr_frac_ecal_good']))  # noqa: E501
        if 'rr_frac_hcal_good' in params:
            form_params.append(('rr_frac_hcal_good', params['rr_frac_hcal_good']))  # noqa: E501
        if 'rr_frac_dt_good' in params:
            form_params.append(('rr_frac_dt_good', params['rr_frac_dt_good']))  # noqa: E501
        if 'rr_frac_csc_good' in params:
            form_params.append(('rr_frac_csc_good', params['rr_frac_csc_good']))  # noqa: E501
        if 'rr_frac_tracking_good' in params:
            form_params.append(('rr_frac_tracking_good', params['rr_frac_tracking_good']))  # noqa: E501
        if 'rr_frac_muon_good' in params:
            form_params.append(('rr_frac_muon_good', params['rr_frac_muon_good']))  # noqa: E501
        if 'rr_frac_egamma_good' in params:
            form_params.append(('rr_frac_egamma_good', params['rr_frac_egamma_good']))  # noqa: E501
        if 'rr_frac_tau_good' in params:
            form_params.append(('rr_frac_tau_good', params['rr_frac_tau_good']))  # noqa: E501
        if 'rr_frac_jetmet_good' in params:
            form_params.append(('rr_frac_jetmet_good', params['rr_frac_jetmet_good']))  # noqa: E501
        if 'rr_frac_btag_good' in params:
            form_params.append(('rr_frac_btag_good', params['rr_frac_btag_good']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            form_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            form_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            form_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            form_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            form_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            form_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            form_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            form_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            form_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            form_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            form_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            form_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'rr_frac_pixel_good' in params:
            form_params.append(('rr_frac_pixel_good', params['rr_frac_pixel_good']))  # noqa: E501
        if 'rr_frac_strip_good' in params:
            form_params.append(('rr_frac_strip_good', params['rr_frac_strip_good']))  # noqa: E501
        if 'rr_frac_ecal_good' in params:
            form_params.append(('rr_frac_ecal_good', params['rr_frac_ecal_good']))  # noqa: E501
        if 'rr_frac_hcal_good' in params:
            form_params.append(('rr_frac_hcal_good', params['rr_frac_hcal_good']))  # noqa: E501
        if 'rr_frac_dt_good' in params:
            form_params.append(('rr_frac_dt_good', params['rr_frac_dt_good']))  # noqa: E501
        if 'rr_frac_csc_good' in params:
            form_params.append(('rr_frac_csc_good', params['rr_frac_csc_good']))  # noqa: E501
        if 'rr_frac_tracking_good' in params:
            form_params.append(('rr_frac_tracking_good', params['rr_frac_tracking_good']))  # noqa: E501
        if 'rr_frac_muon_good' in params:
            form_params.append(('rr_frac_muon_good', params['rr_frac_muon_good']))  # noqa: E501
        if 'rr_frac_egamma_good' in params:
            form_params.append(('rr_frac_egamma_good', params['rr_frac_egamma_good']))  # noqa: E501
        if 'rr_frac_tau_good' in params:
            form_params.append(('rr_frac_tau_good', params['rr_frac_tau_good']))  # noqa: E501
        if 'rr_frac_jetmet_good' in params:
            form_params.append(('rr_frac_jetmet_good', params['rr_frac_jetmet_good']))  # noqa: E501
        if 'rr_frac_btag_good' in params:
            form_params.append(('rr_frac_btag_good', params['rr_frac_btag_good']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/run_certifications/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RunCertification',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def partial_update_run_certification(self, id, **kwargs):  # noqa: E501
        """partial_update_run_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_run_certification(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this run certification. (required)
        :param int id2:
        :param int run2:
        :param datetime _date2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param float rr_frac_pixel_good2:
        :param float rr_frac_strip_good2:
        :param float rr_frac_ecal_good2:
        :param float rr_frac_hcal_good2:
        :param float rr_frac_dt_good2:
        :param float rr_frac_csc_good2:
        :param float rr_frac_tracking_good2:
        :param float rr_frac_muon_good2:
        :param float rr_frac_egamma_good2:
        :param float rr_frac_tau_good2:
        :param float rr_frac_jetmet_good2:
        :param float rr_frac_btag_good2:
        :param int id2:
        :param int run2:
        :param datetime _date2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param float rr_frac_pixel_good2:
        :param float rr_frac_strip_good2:
        :param float rr_frac_ecal_good2:
        :param float rr_frac_hcal_good2:
        :param float rr_frac_dt_good2:
        :param float rr_frac_csc_good2:
        :param float rr_frac_tracking_good2:
        :param float rr_frac_muon_good2:
        :param float rr_frac_egamma_good2:
        :param float rr_frac_tau_good2:
        :param float rr_frac_jetmet_good2:
        :param float rr_frac_btag_good2:
        :param str run: run
        :param str _date: date
        :param str rr_is_pixel_good: rr_is_pixel_good
        :param str rr_is_strip_good: rr_is_strip_good
        :param str rr_is_ecal_good: rr_is_ecal_good
        :param str rr_is_hcal_good: rr_is_hcal_good
        :param str rr_is_dt_good: rr_is_dt_good
        :param str rr_is_csc_good: rr_is_csc_good
        :param str rr_is_tracking_good: rr_is_tracking_good
        :param str rr_is_muon_good: rr_is_muon_good
        :param str rr_is_egamma_good: rr_is_egamma_good
        :param str rr_is_tau_good: rr_is_tau_good
        :param str rr_is_jetmet_good: rr_is_jetmet_good
        :param str rr_is_btag_good: rr_is_btag_good
        :param str rr_frac_pixel_good: rr_frac_pixel_good
        :param str rr_frac_strip_good: rr_frac_strip_good
        :param str rr_frac_ecal_good: rr_frac_ecal_good
        :param str rr_frac_hcal_good: rr_frac_hcal_good
        :param str rr_frac_dt_good: rr_frac_dt_good
        :param str rr_frac_csc_good: rr_frac_csc_good
        :param str rr_frac_tracking_good: rr_frac_tracking_good
        :param str rr_frac_muon_good: rr_frac_muon_good
        :param str rr_frac_egamma_good: rr_frac_egamma_good
        :param str rr_frac_tau_good: rr_frac_tau_good
        :param str rr_frac_jetmet_good: rr_frac_jetmet_good
        :param str rr_frac_btag_good: rr_frac_btag_good
        :return: RunCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.partial_update_run_certification_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.partial_update_run_certification_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def partial_update_run_certification_with_http_info(self, id, **kwargs):  # noqa: E501
        """partial_update_run_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_run_certification_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this run certification. (required)
        :param int id2:
        :param int run2:
        :param datetime _date2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param float rr_frac_pixel_good2:
        :param float rr_frac_strip_good2:
        :param float rr_frac_ecal_good2:
        :param float rr_frac_hcal_good2:
        :param float rr_frac_dt_good2:
        :param float rr_frac_csc_good2:
        :param float rr_frac_tracking_good2:
        :param float rr_frac_muon_good2:
        :param float rr_frac_egamma_good2:
        :param float rr_frac_tau_good2:
        :param float rr_frac_jetmet_good2:
        :param float rr_frac_btag_good2:
        :param int id2:
        :param int run2:
        :param datetime _date2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param float rr_frac_pixel_good2:
        :param float rr_frac_strip_good2:
        :param float rr_frac_ecal_good2:
        :param float rr_frac_hcal_good2:
        :param float rr_frac_dt_good2:
        :param float rr_frac_csc_good2:
        :param float rr_frac_tracking_good2:
        :param float rr_frac_muon_good2:
        :param float rr_frac_egamma_good2:
        :param float rr_frac_tau_good2:
        :param float rr_frac_jetmet_good2:
        :param float rr_frac_btag_good2:
        :param str run: run
        :param str _date: date
        :param str rr_is_pixel_good: rr_is_pixel_good
        :param str rr_is_strip_good: rr_is_strip_good
        :param str rr_is_ecal_good: rr_is_ecal_good
        :param str rr_is_hcal_good: rr_is_hcal_good
        :param str rr_is_dt_good: rr_is_dt_good
        :param str rr_is_csc_good: rr_is_csc_good
        :param str rr_is_tracking_good: rr_is_tracking_good
        :param str rr_is_muon_good: rr_is_muon_good
        :param str rr_is_egamma_good: rr_is_egamma_good
        :param str rr_is_tau_good: rr_is_tau_good
        :param str rr_is_jetmet_good: rr_is_jetmet_good
        :param str rr_is_btag_good: rr_is_btag_good
        :param str rr_frac_pixel_good: rr_frac_pixel_good
        :param str rr_frac_strip_good: rr_frac_strip_good
        :param str rr_frac_ecal_good: rr_frac_ecal_good
        :param str rr_frac_hcal_good: rr_frac_hcal_good
        :param str rr_frac_dt_good: rr_frac_dt_good
        :param str rr_frac_csc_good: rr_frac_csc_good
        :param str rr_frac_tracking_good: rr_frac_tracking_good
        :param str rr_frac_muon_good: rr_frac_muon_good
        :param str rr_frac_egamma_good: rr_frac_egamma_good
        :param str rr_frac_tau_good: rr_frac_tau_good
        :param str rr_frac_jetmet_good: rr_frac_jetmet_good
        :param str rr_frac_btag_good: rr_frac_btag_good
        :return: RunCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'id2', 'run2', '_date2', 'rr_is_pixel_good2', 'rr_is_strip_good2', 'rr_is_ecal_good2', 'rr_is_hcal_good2', 'rr_is_dt_good2', 'rr_is_csc_good2', 'rr_is_tracking_good2', 'rr_is_muon_good2', 'rr_is_egamma_good2', 'rr_is_tau_good2', 'rr_is_jetmet_good2', 'rr_is_btag_good2', 'rr_frac_pixel_good2', 'rr_frac_strip_good2', 'rr_frac_ecal_good2', 'rr_frac_hcal_good2', 'rr_frac_dt_good2', 'rr_frac_csc_good2', 'rr_frac_tracking_good2', 'rr_frac_muon_good2', 'rr_frac_egamma_good2', 'rr_frac_tau_good2', 'rr_frac_jetmet_good2', 'rr_frac_btag_good2', 'id2', 'run2', '_date2', 'rr_is_pixel_good2', 'rr_is_strip_good2', 'rr_is_ecal_good2', 'rr_is_hcal_good2', 'rr_is_dt_good2', 'rr_is_csc_good2', 'rr_is_tracking_good2', 'rr_is_muon_good2', 'rr_is_egamma_good2', 'rr_is_tau_good2', 'rr_is_jetmet_good2', 'rr_is_btag_good2', 'rr_frac_pixel_good2', 'rr_frac_strip_good2', 'rr_frac_ecal_good2', 'rr_frac_hcal_good2', 'rr_frac_dt_good2', 'rr_frac_csc_good2', 'rr_frac_tracking_good2', 'rr_frac_muon_good2', 'rr_frac_egamma_good2', 'rr_frac_tau_good2', 'rr_frac_jetmet_good2', 'rr_frac_btag_good2', 'run', '_date', 'rr_is_pixel_good', 'rr_is_strip_good', 'rr_is_ecal_good', 'rr_is_hcal_good', 'rr_is_dt_good', 'rr_is_csc_good', 'rr_is_tracking_good', 'rr_is_muon_good', 'rr_is_egamma_good', 'rr_is_tau_good', 'rr_is_jetmet_good', 'rr_is_btag_good', 'rr_frac_pixel_good', 'rr_frac_strip_good', 'rr_frac_ecal_good', 'rr_frac_hcal_good', 'rr_frac_dt_good', 'rr_frac_csc_good', 'rr_frac_tracking_good', 'rr_frac_muon_good', 'rr_frac_egamma_good', 'rr_frac_tau_good', 'rr_frac_jetmet_good', 'rr_frac_btag_good']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method partial_update_run_certification" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `partial_update_run_certification`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'run' in params:
            query_params.append(('run', params['run']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            query_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            query_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            query_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            query_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            query_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            query_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            query_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            query_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            query_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            query_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            query_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            query_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'rr_frac_pixel_good' in params:
            query_params.append(('rr_frac_pixel_good', params['rr_frac_pixel_good']))  # noqa: E501
        if 'rr_frac_strip_good' in params:
            query_params.append(('rr_frac_strip_good', params['rr_frac_strip_good']))  # noqa: E501
        if 'rr_frac_ecal_good' in params:
            query_params.append(('rr_frac_ecal_good', params['rr_frac_ecal_good']))  # noqa: E501
        if 'rr_frac_hcal_good' in params:
            query_params.append(('rr_frac_hcal_good', params['rr_frac_hcal_good']))  # noqa: E501
        if 'rr_frac_dt_good' in params:
            query_params.append(('rr_frac_dt_good', params['rr_frac_dt_good']))  # noqa: E501
        if 'rr_frac_csc_good' in params:
            query_params.append(('rr_frac_csc_good', params['rr_frac_csc_good']))  # noqa: E501
        if 'rr_frac_tracking_good' in params:
            query_params.append(('rr_frac_tracking_good', params['rr_frac_tracking_good']))  # noqa: E501
        if 'rr_frac_muon_good' in params:
            query_params.append(('rr_frac_muon_good', params['rr_frac_muon_good']))  # noqa: E501
        if 'rr_frac_egamma_good' in params:
            query_params.append(('rr_frac_egamma_good', params['rr_frac_egamma_good']))  # noqa: E501
        if 'rr_frac_tau_good' in params:
            query_params.append(('rr_frac_tau_good', params['rr_frac_tau_good']))  # noqa: E501
        if 'rr_frac_jetmet_good' in params:
            query_params.append(('rr_frac_jetmet_good', params['rr_frac_jetmet_good']))  # noqa: E501
        if 'rr_frac_btag_good' in params:
            query_params.append(('rr_frac_btag_good', params['rr_frac_btag_good']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            form_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            form_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            form_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            form_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            form_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            form_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            form_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            form_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            form_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            form_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            form_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            form_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'rr_frac_pixel_good' in params:
            form_params.append(('rr_frac_pixel_good', params['rr_frac_pixel_good']))  # noqa: E501
        if 'rr_frac_strip_good' in params:
            form_params.append(('rr_frac_strip_good', params['rr_frac_strip_good']))  # noqa: E501
        if 'rr_frac_ecal_good' in params:
            form_params.append(('rr_frac_ecal_good', params['rr_frac_ecal_good']))  # noqa: E501
        if 'rr_frac_hcal_good' in params:
            form_params.append(('rr_frac_hcal_good', params['rr_frac_hcal_good']))  # noqa: E501
        if 'rr_frac_dt_good' in params:
            form_params.append(('rr_frac_dt_good', params['rr_frac_dt_good']))  # noqa: E501
        if 'rr_frac_csc_good' in params:
            form_params.append(('rr_frac_csc_good', params['rr_frac_csc_good']))  # noqa: E501
        if 'rr_frac_tracking_good' in params:
            form_params.append(('rr_frac_tracking_good', params['rr_frac_tracking_good']))  # noqa: E501
        if 'rr_frac_muon_good' in params:
            form_params.append(('rr_frac_muon_good', params['rr_frac_muon_good']))  # noqa: E501
        if 'rr_frac_egamma_good' in params:
            form_params.append(('rr_frac_egamma_good', params['rr_frac_egamma_good']))  # noqa: E501
        if 'rr_frac_tau_good' in params:
            form_params.append(('rr_frac_tau_good', params['rr_frac_tau_good']))  # noqa: E501
        if 'rr_frac_jetmet_good' in params:
            form_params.append(('rr_frac_jetmet_good', params['rr_frac_jetmet_good']))  # noqa: E501
        if 'rr_frac_btag_good' in params:
            form_params.append(('rr_frac_btag_good', params['rr_frac_btag_good']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            form_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            form_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            form_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            form_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            form_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            form_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            form_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            form_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            form_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            form_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            form_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            form_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'rr_frac_pixel_good' in params:
            form_params.append(('rr_frac_pixel_good', params['rr_frac_pixel_good']))  # noqa: E501
        if 'rr_frac_strip_good' in params:
            form_params.append(('rr_frac_strip_good', params['rr_frac_strip_good']))  # noqa: E501
        if 'rr_frac_ecal_good' in params:
            form_params.append(('rr_frac_ecal_good', params['rr_frac_ecal_good']))  # noqa: E501
        if 'rr_frac_hcal_good' in params:
            form_params.append(('rr_frac_hcal_good', params['rr_frac_hcal_good']))  # noqa: E501
        if 'rr_frac_dt_good' in params:
            form_params.append(('rr_frac_dt_good', params['rr_frac_dt_good']))  # noqa: E501
        if 'rr_frac_csc_good' in params:
            form_params.append(('rr_frac_csc_good', params['rr_frac_csc_good']))  # noqa: E501
        if 'rr_frac_tracking_good' in params:
            form_params.append(('rr_frac_tracking_good', params['rr_frac_tracking_good']))  # noqa: E501
        if 'rr_frac_muon_good' in params:
            form_params.append(('rr_frac_muon_good', params['rr_frac_muon_good']))  # noqa: E501
        if 'rr_frac_egamma_good' in params:
            form_params.append(('rr_frac_egamma_good', params['rr_frac_egamma_good']))  # noqa: E501
        if 'rr_frac_tau_good' in params:
            form_params.append(('rr_frac_tau_good', params['rr_frac_tau_good']))  # noqa: E501
        if 'rr_frac_jetmet_good' in params:
            form_params.append(('rr_frac_jetmet_good', params['rr_frac_jetmet_good']))  # noqa: E501
        if 'rr_frac_btag_good' in params:
            form_params.append(('rr_frac_btag_good', params['rr_frac_btag_good']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/run_certifications/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RunCertification',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def partial_update_run_certification(self, id, **kwargs):  # noqa: E501
        """partial_update_run_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_run_certification(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this run certification. (required)
        :param int id2:
        :param int run2:
        :param datetime _date2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param float rr_frac_pixel_good2:
        :param float rr_frac_strip_good2:
        :param float rr_frac_ecal_good2:
        :param float rr_frac_hcal_good2:
        :param float rr_frac_dt_good2:
        :param float rr_frac_csc_good2:
        :param float rr_frac_tracking_good2:
        :param float rr_frac_muon_good2:
        :param float rr_frac_egamma_good2:
        :param float rr_frac_tau_good2:
        :param float rr_frac_jetmet_good2:
        :param float rr_frac_btag_good2:
        :param int id2:
        :param int run2:
        :param datetime _date2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param float rr_frac_pixel_good2:
        :param float rr_frac_strip_good2:
        :param float rr_frac_ecal_good2:
        :param float rr_frac_hcal_good2:
        :param float rr_frac_dt_good2:
        :param float rr_frac_csc_good2:
        :param float rr_frac_tracking_good2:
        :param float rr_frac_muon_good2:
        :param float rr_frac_egamma_good2:
        :param float rr_frac_tau_good2:
        :param float rr_frac_jetmet_good2:
        :param float rr_frac_btag_good2:
        :param str run: run
        :param str _date: date
        :param str rr_is_pixel_good: rr_is_pixel_good
        :param str rr_is_strip_good: rr_is_strip_good
        :param str rr_is_ecal_good: rr_is_ecal_good
        :param str rr_is_hcal_good: rr_is_hcal_good
        :param str rr_is_dt_good: rr_is_dt_good
        :param str rr_is_csc_good: rr_is_csc_good
        :param str rr_is_tracking_good: rr_is_tracking_good
        :param str rr_is_muon_good: rr_is_muon_good
        :param str rr_is_egamma_good: rr_is_egamma_good
        :param str rr_is_tau_good: rr_is_tau_good
        :param str rr_is_jetmet_good: rr_is_jetmet_good
        :param str rr_is_btag_good: rr_is_btag_good
        :param str rr_frac_pixel_good: rr_frac_pixel_good
        :param str rr_frac_strip_good: rr_frac_strip_good
        :param str rr_frac_ecal_good: rr_frac_ecal_good
        :param str rr_frac_hcal_good: rr_frac_hcal_good
        :param str rr_frac_dt_good: rr_frac_dt_good
        :param str rr_frac_csc_good: rr_frac_csc_good
        :param str rr_frac_tracking_good: rr_frac_tracking_good
        :param str rr_frac_muon_good: rr_frac_muon_good
        :param str rr_frac_egamma_good: rr_frac_egamma_good
        :param str rr_frac_tau_good: rr_frac_tau_good
        :param str rr_frac_jetmet_good: rr_frac_jetmet_good
        :param str rr_frac_btag_good: rr_frac_btag_good
        :return: RunCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.partial_update_run_certification_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.partial_update_run_certification_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def partial_update_run_certification_with_http_info(self, id, **kwargs):  # noqa: E501
        """partial_update_run_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_run_certification_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this run certification. (required)
        :param int id2:
        :param int run2:
        :param datetime _date2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param float rr_frac_pixel_good2:
        :param float rr_frac_strip_good2:
        :param float rr_frac_ecal_good2:
        :param float rr_frac_hcal_good2:
        :param float rr_frac_dt_good2:
        :param float rr_frac_csc_good2:
        :param float rr_frac_tracking_good2:
        :param float rr_frac_muon_good2:
        :param float rr_frac_egamma_good2:
        :param float rr_frac_tau_good2:
        :param float rr_frac_jetmet_good2:
        :param float rr_frac_btag_good2:
        :param int id2:
        :param int run2:
        :param datetime _date2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param float rr_frac_pixel_good2:
        :param float rr_frac_strip_good2:
        :param float rr_frac_ecal_good2:
        :param float rr_frac_hcal_good2:
        :param float rr_frac_dt_good2:
        :param float rr_frac_csc_good2:
        :param float rr_frac_tracking_good2:
        :param float rr_frac_muon_good2:
        :param float rr_frac_egamma_good2:
        :param float rr_frac_tau_good2:
        :param float rr_frac_jetmet_good2:
        :param float rr_frac_btag_good2:
        :param str run: run
        :param str _date: date
        :param str rr_is_pixel_good: rr_is_pixel_good
        :param str rr_is_strip_good: rr_is_strip_good
        :param str rr_is_ecal_good: rr_is_ecal_good
        :param str rr_is_hcal_good: rr_is_hcal_good
        :param str rr_is_dt_good: rr_is_dt_good
        :param str rr_is_csc_good: rr_is_csc_good
        :param str rr_is_tracking_good: rr_is_tracking_good
        :param str rr_is_muon_good: rr_is_muon_good
        :param str rr_is_egamma_good: rr_is_egamma_good
        :param str rr_is_tau_good: rr_is_tau_good
        :param str rr_is_jetmet_good: rr_is_jetmet_good
        :param str rr_is_btag_good: rr_is_btag_good
        :param str rr_frac_pixel_good: rr_frac_pixel_good
        :param str rr_frac_strip_good: rr_frac_strip_good
        :param str rr_frac_ecal_good: rr_frac_ecal_good
        :param str rr_frac_hcal_good: rr_frac_hcal_good
        :param str rr_frac_dt_good: rr_frac_dt_good
        :param str rr_frac_csc_good: rr_frac_csc_good
        :param str rr_frac_tracking_good: rr_frac_tracking_good
        :param str rr_frac_muon_good: rr_frac_muon_good
        :param str rr_frac_egamma_good: rr_frac_egamma_good
        :param str rr_frac_tau_good: rr_frac_tau_good
        :param str rr_frac_jetmet_good: rr_frac_jetmet_good
        :param str rr_frac_btag_good: rr_frac_btag_good
        :return: RunCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'id2', 'run2', '_date2', 'rr_is_pixel_good2', 'rr_is_strip_good2', 'rr_is_ecal_good2', 'rr_is_hcal_good2', 'rr_is_dt_good2', 'rr_is_csc_good2', 'rr_is_tracking_good2', 'rr_is_muon_good2', 'rr_is_egamma_good2', 'rr_is_tau_good2', 'rr_is_jetmet_good2', 'rr_is_btag_good2', 'rr_frac_pixel_good2', 'rr_frac_strip_good2', 'rr_frac_ecal_good2', 'rr_frac_hcal_good2', 'rr_frac_dt_good2', 'rr_frac_csc_good2', 'rr_frac_tracking_good2', 'rr_frac_muon_good2', 'rr_frac_egamma_good2', 'rr_frac_tau_good2', 'rr_frac_jetmet_good2', 'rr_frac_btag_good2', 'id2', 'run2', '_date2', 'rr_is_pixel_good2', 'rr_is_strip_good2', 'rr_is_ecal_good2', 'rr_is_hcal_good2', 'rr_is_dt_good2', 'rr_is_csc_good2', 'rr_is_tracking_good2', 'rr_is_muon_good2', 'rr_is_egamma_good2', 'rr_is_tau_good2', 'rr_is_jetmet_good2', 'rr_is_btag_good2', 'rr_frac_pixel_good2', 'rr_frac_strip_good2', 'rr_frac_ecal_good2', 'rr_frac_hcal_good2', 'rr_frac_dt_good2', 'rr_frac_csc_good2', 'rr_frac_tracking_good2', 'rr_frac_muon_good2', 'rr_frac_egamma_good2', 'rr_frac_tau_good2', 'rr_frac_jetmet_good2', 'rr_frac_btag_good2', 'run', '_date', 'rr_is_pixel_good', 'rr_is_strip_good', 'rr_is_ecal_good', 'rr_is_hcal_good', 'rr_is_dt_good', 'rr_is_csc_good', 'rr_is_tracking_good', 'rr_is_muon_good', 'rr_is_egamma_good', 'rr_is_tau_good', 'rr_is_jetmet_good', 'rr_is_btag_good', 'rr_frac_pixel_good', 'rr_frac_strip_good', 'rr_frac_ecal_good', 'rr_frac_hcal_good', 'rr_frac_dt_good', 'rr_frac_csc_good', 'rr_frac_tracking_good', 'rr_frac_muon_good', 'rr_frac_egamma_good', 'rr_frac_tau_good', 'rr_frac_jetmet_good', 'rr_frac_btag_good']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method partial_update_run_certification" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `partial_update_run_certification`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'run' in params:
            query_params.append(('run', params['run']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            query_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            query_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            query_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            query_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            query_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            query_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            query_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            query_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            query_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            query_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            query_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            query_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'rr_frac_pixel_good' in params:
            query_params.append(('rr_frac_pixel_good', params['rr_frac_pixel_good']))  # noqa: E501
        if 'rr_frac_strip_good' in params:
            query_params.append(('rr_frac_strip_good', params['rr_frac_strip_good']))  # noqa: E501
        if 'rr_frac_ecal_good' in params:
            query_params.append(('rr_frac_ecal_good', params['rr_frac_ecal_good']))  # noqa: E501
        if 'rr_frac_hcal_good' in params:
            query_params.append(('rr_frac_hcal_good', params['rr_frac_hcal_good']))  # noqa: E501
        if 'rr_frac_dt_good' in params:
            query_params.append(('rr_frac_dt_good', params['rr_frac_dt_good']))  # noqa: E501
        if 'rr_frac_csc_good' in params:
            query_params.append(('rr_frac_csc_good', params['rr_frac_csc_good']))  # noqa: E501
        if 'rr_frac_tracking_good' in params:
            query_params.append(('rr_frac_tracking_good', params['rr_frac_tracking_good']))  # noqa: E501
        if 'rr_frac_muon_good' in params:
            query_params.append(('rr_frac_muon_good', params['rr_frac_muon_good']))  # noqa: E501
        if 'rr_frac_egamma_good' in params:
            query_params.append(('rr_frac_egamma_good', params['rr_frac_egamma_good']))  # noqa: E501
        if 'rr_frac_tau_good' in params:
            query_params.append(('rr_frac_tau_good', params['rr_frac_tau_good']))  # noqa: E501
        if 'rr_frac_jetmet_good' in params:
            query_params.append(('rr_frac_jetmet_good', params['rr_frac_jetmet_good']))  # noqa: E501
        if 'rr_frac_btag_good' in params:
            query_params.append(('rr_frac_btag_good', params['rr_frac_btag_good']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            form_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            form_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            form_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            form_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            form_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            form_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            form_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            form_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            form_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            form_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            form_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            form_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'rr_frac_pixel_good' in params:
            form_params.append(('rr_frac_pixel_good', params['rr_frac_pixel_good']))  # noqa: E501
        if 'rr_frac_strip_good' in params:
            form_params.append(('rr_frac_strip_good', params['rr_frac_strip_good']))  # noqa: E501
        if 'rr_frac_ecal_good' in params:
            form_params.append(('rr_frac_ecal_good', params['rr_frac_ecal_good']))  # noqa: E501
        if 'rr_frac_hcal_good' in params:
            form_params.append(('rr_frac_hcal_good', params['rr_frac_hcal_good']))  # noqa: E501
        if 'rr_frac_dt_good' in params:
            form_params.append(('rr_frac_dt_good', params['rr_frac_dt_good']))  # noqa: E501
        if 'rr_frac_csc_good' in params:
            form_params.append(('rr_frac_csc_good', params['rr_frac_csc_good']))  # noqa: E501
        if 'rr_frac_tracking_good' in params:
            form_params.append(('rr_frac_tracking_good', params['rr_frac_tracking_good']))  # noqa: E501
        if 'rr_frac_muon_good' in params:
            form_params.append(('rr_frac_muon_good', params['rr_frac_muon_good']))  # noqa: E501
        if 'rr_frac_egamma_good' in params:
            form_params.append(('rr_frac_egamma_good', params['rr_frac_egamma_good']))  # noqa: E501
        if 'rr_frac_tau_good' in params:
            form_params.append(('rr_frac_tau_good', params['rr_frac_tau_good']))  # noqa: E501
        if 'rr_frac_jetmet_good' in params:
            form_params.append(('rr_frac_jetmet_good', params['rr_frac_jetmet_good']))  # noqa: E501
        if 'rr_frac_btag_good' in params:
            form_params.append(('rr_frac_btag_good', params['rr_frac_btag_good']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            form_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            form_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            form_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            form_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            form_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            form_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            form_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            form_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            form_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            form_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            form_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            form_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'rr_frac_pixel_good' in params:
            form_params.append(('rr_frac_pixel_good', params['rr_frac_pixel_good']))  # noqa: E501
        if 'rr_frac_strip_good' in params:
            form_params.append(('rr_frac_strip_good', params['rr_frac_strip_good']))  # noqa: E501
        if 'rr_frac_ecal_good' in params:
            form_params.append(('rr_frac_ecal_good', params['rr_frac_ecal_good']))  # noqa: E501
        if 'rr_frac_hcal_good' in params:
            form_params.append(('rr_frac_hcal_good', params['rr_frac_hcal_good']))  # noqa: E501
        if 'rr_frac_dt_good' in params:
            form_params.append(('rr_frac_dt_good', params['rr_frac_dt_good']))  # noqa: E501
        if 'rr_frac_csc_good' in params:
            form_params.append(('rr_frac_csc_good', params['rr_frac_csc_good']))  # noqa: E501
        if 'rr_frac_tracking_good' in params:
            form_params.append(('rr_frac_tracking_good', params['rr_frac_tracking_good']))  # noqa: E501
        if 'rr_frac_muon_good' in params:
            form_params.append(('rr_frac_muon_good', params['rr_frac_muon_good']))  # noqa: E501
        if 'rr_frac_egamma_good' in params:
            form_params.append(('rr_frac_egamma_good', params['rr_frac_egamma_good']))  # noqa: E501
        if 'rr_frac_tau_good' in params:
            form_params.append(('rr_frac_tau_good', params['rr_frac_tau_good']))  # noqa: E501
        if 'rr_frac_jetmet_good' in params:
            form_params.append(('rr_frac_jetmet_good', params['rr_frac_jetmet_good']))  # noqa: E501
        if 'rr_frac_btag_good' in params:
            form_params.append(('rr_frac_btag_good', params['rr_frac_btag_good']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/run_certifications/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RunCertification',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def partial_update_run_histogram(self, id, **kwargs):  # noqa: E501
        """partial_update_run_histogram  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_run_histogram(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this run histogram. (required)
        :param RunHistogram body:
        :param str run__run_number__gte: run__run_number__gte
        :param str run__run_number__lte: run__run_number__lte
        :param str run__run_number: run__run_number
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str mean: mean
        :param str mean__gte: mean__gte
        :param str mean__lte: mean__lte
        :param str rms: rms
        :param str rms__gte: rms__gte
        :param str rms__lte: rms__lte
        :param str skewness: skewness
        :param str skewness__gte: skewness__gte
        :param str skewness__lte: skewness__lte
        :param str kurtosis: kurtosis
        :param str kurtosis__gte: kurtosis__gte
        :param str kurtosis__lte: kurtosis__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str primary_dataset: primary_dataset
        :param str run__run_number__in: run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: RunHistogram
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.partial_update_run_histogram_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.partial_update_run_histogram_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def partial_update_run_histogram_with_http_info(self, id, **kwargs):  # noqa: E501
        """partial_update_run_histogram  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_run_histogram_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this run histogram. (required)
        :param RunHistogram body:
        :param str run__run_number__gte: run__run_number__gte
        :param str run__run_number__lte: run__run_number__lte
        :param str run__run_number: run__run_number
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str mean: mean
        :param str mean__gte: mean__gte
        :param str mean__lte: mean__lte
        :param str rms: rms
        :param str rms__gte: rms__gte
        :param str rms__lte: rms__lte
        :param str skewness: skewness
        :param str skewness__gte: skewness__gte
        :param str skewness__lte: skewness__lte
        :param str kurtosis: kurtosis
        :param str kurtosis__gte: kurtosis__gte
        :param str kurtosis__lte: kurtosis__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str primary_dataset: primary_dataset
        :param str run__run_number__in: run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: RunHistogram
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'run__run_number__gte', 'run__run_number__lte', 'run__run_number', 'entries__gte', 'entries__lte', 'mean', 'mean__gte', 'mean__lte', 'rms', 'rms__gte', 'rms__lte', 'skewness', 'skewness__gte', 'skewness__lte', 'kurtosis', 'kurtosis__gte', 'kurtosis__lte', 'source_data_file', 'title', 'primary_dataset', 'run__run_number__in', 'source_data_file__filepath__contains']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method partial_update_run_histogram" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `partial_update_run_histogram`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'run__run_number__gte' in params:
            query_params.append(('run__run_number__gte', params['run__run_number__gte']))  # noqa: E501
        if 'run__run_number__lte' in params:
            query_params.append(('run__run_number__lte', params['run__run_number__lte']))  # noqa: E501
        if 'run__run_number' in params:
            query_params.append(('run__run_number', params['run__run_number']))  # noqa: E501
        if 'entries__gte' in params:
            query_params.append(('entries__gte', params['entries__gte']))  # noqa: E501
        if 'entries__lte' in params:
            query_params.append(('entries__lte', params['entries__lte']))  # noqa: E501
        if 'mean' in params:
            query_params.append(('mean', params['mean']))  # noqa: E501
        if 'mean__gte' in params:
            query_params.append(('mean__gte', params['mean__gte']))  # noqa: E501
        if 'mean__lte' in params:
            query_params.append(('mean__lte', params['mean__lte']))  # noqa: E501
        if 'rms' in params:
            query_params.append(('rms', params['rms']))  # noqa: E501
        if 'rms__gte' in params:
            query_params.append(('rms__gte', params['rms__gte']))  # noqa: E501
        if 'rms__lte' in params:
            query_params.append(('rms__lte', params['rms__lte']))  # noqa: E501
        if 'skewness' in params:
            query_params.append(('skewness', params['skewness']))  # noqa: E501
        if 'skewness__gte' in params:
            query_params.append(('skewness__gte', params['skewness__gte']))  # noqa: E501
        if 'skewness__lte' in params:
            query_params.append(('skewness__lte', params['skewness__lte']))  # noqa: E501
        if 'kurtosis' in params:
            query_params.append(('kurtosis', params['kurtosis']))  # noqa: E501
        if 'kurtosis__gte' in params:
            query_params.append(('kurtosis__gte', params['kurtosis__gte']))  # noqa: E501
        if 'kurtosis__lte' in params:
            query_params.append(('kurtosis__lte', params['kurtosis__lte']))  # noqa: E501
        if 'source_data_file' in params:
            query_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'title' in params:
            query_params.append(('title', params['title']))  # noqa: E501
        if 'primary_dataset' in params:
            query_params.append(('primary_dataset', params['primary_dataset']))  # noqa: E501
        if 'run__run_number__in' in params:
            query_params.append(('run__run_number__in', params['run__run_number__in']))  # noqa: E501
        if 'source_data_file__filepath__contains' in params:
            query_params.append(('source_data_file__filepath__contains', params['source_data_file__filepath__contains']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'primary_dataset' in params:
            form_params.append(('primary_dataset', params['primary_dataset']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'mean' in params:
            form_params.append(('mean', params['mean']))  # noqa: E501
        if 'rms' in params:
            form_params.append(('rms', params['rms']))  # noqa: E501
        if 'skewness' in params:
            form_params.append(('skewness', params['skewness']))  # noqa: E501
        if 'kurtosis' in params:
            form_params.append(('kurtosis', params['kurtosis']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'primary_dataset' in params:
            form_params.append(('primary_dataset', params['primary_dataset']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'mean' in params:
            form_params.append(('mean', params['mean']))  # noqa: E501
        if 'rms' in params:
            form_params.append(('rms', params['rms']))  # noqa: E501
        if 'skewness' in params:
            form_params.append(('skewness', params['skewness']))  # noqa: E501
        if 'kurtosis' in params:
            form_params.append(('kurtosis', params['kurtosis']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/run_histograms/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RunHistogram',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def partial_update_run_histogram(self, id, **kwargs):  # noqa: E501
        """partial_update_run_histogram  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_run_histogram(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this run histogram. (required)
        :param int id2:
        :param int run2:
        :param str title2:
        :param str primary_dataset2:
        :param int entries2:
        :param float mean2:
        :param float rms2:
        :param float skewness2:
        :param float kurtosis2:
        :param int source_data_file2:
        :param int id2:
        :param int run:
        :param str title2:
        :param str primary_dataset2:
        :param int entries:
        :param float mean2:
        :param float rms2:
        :param float skewness2:
        :param float kurtosis2:
        :param int source_data_file2:
        :param str run__run_number__gte: run__run_number__gte
        :param str run__run_number__lte: run__run_number__lte
        :param str run__run_number: run__run_number
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str mean: mean
        :param str mean__gte: mean__gte
        :param str mean__lte: mean__lte
        :param str rms: rms
        :param str rms__gte: rms__gte
        :param str rms__lte: rms__lte
        :param str skewness: skewness
        :param str skewness__gte: skewness__gte
        :param str skewness__lte: skewness__lte
        :param str kurtosis: kurtosis
        :param str kurtosis__gte: kurtosis__gte
        :param str kurtosis__lte: kurtosis__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str primary_dataset: primary_dataset
        :param str run__run_number__in: run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: RunHistogram
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.partial_update_run_histogram_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.partial_update_run_histogram_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def partial_update_run_histogram_with_http_info(self, id, **kwargs):  # noqa: E501
        """partial_update_run_histogram  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_run_histogram_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this run histogram. (required)
        :param int id2:
        :param int run2:
        :param str title2:
        :param str primary_dataset2:
        :param int entries2:
        :param float mean2:
        :param float rms2:
        :param float skewness2:
        :param float kurtosis2:
        :param int source_data_file2:
        :param int id2:
        :param int run:
        :param str title2:
        :param str primary_dataset2:
        :param int entries:
        :param float mean2:
        :param float rms2:
        :param float skewness2:
        :param float kurtosis2:
        :param int source_data_file2:
        :param str run__run_number__gte: run__run_number__gte
        :param str run__run_number__lte: run__run_number__lte
        :param str run__run_number: run__run_number
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str mean: mean
        :param str mean__gte: mean__gte
        :param str mean__lte: mean__lte
        :param str rms: rms
        :param str rms__gte: rms__gte
        :param str rms__lte: rms__lte
        :param str skewness: skewness
        :param str skewness__gte: skewness__gte
        :param str skewness__lte: skewness__lte
        :param str kurtosis: kurtosis
        :param str kurtosis__gte: kurtosis__gte
        :param str kurtosis__lte: kurtosis__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str primary_dataset: primary_dataset
        :param str run__run_number__in: run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: RunHistogram
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'id2', 'run2', 'title2', 'primary_dataset2', 'entries2', 'mean2', 'rms2', 'skewness2', 'kurtosis2', 'source_data_file2', 'id2', 'run', 'title2', 'primary_dataset2', 'entries', 'mean2', 'rms2', 'skewness2', 'kurtosis2', 'source_data_file2', 'run__run_number__gte', 'run__run_number__lte', 'run__run_number', 'entries__gte', 'entries__lte', 'mean', 'mean__gte', 'mean__lte', 'rms', 'rms__gte', 'rms__lte', 'skewness', 'skewness__gte', 'skewness__lte', 'kurtosis', 'kurtosis__gte', 'kurtosis__lte', 'source_data_file', 'title', 'primary_dataset', 'run__run_number__in', 'source_data_file__filepath__contains']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method partial_update_run_histogram" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `partial_update_run_histogram`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'run__run_number__gte' in params:
            query_params.append(('run__run_number__gte', params['run__run_number__gte']))  # noqa: E501
        if 'run__run_number__lte' in params:
            query_params.append(('run__run_number__lte', params['run__run_number__lte']))  # noqa: E501
        if 'run__run_number' in params:
            query_params.append(('run__run_number', params['run__run_number']))  # noqa: E501
        if 'entries__gte' in params:
            query_params.append(('entries__gte', params['entries__gte']))  # noqa: E501
        if 'entries__lte' in params:
            query_params.append(('entries__lte', params['entries__lte']))  # noqa: E501
        if 'mean' in params:
            query_params.append(('mean', params['mean']))  # noqa: E501
        if 'mean__gte' in params:
            query_params.append(('mean__gte', params['mean__gte']))  # noqa: E501
        if 'mean__lte' in params:
            query_params.append(('mean__lte', params['mean__lte']))  # noqa: E501
        if 'rms' in params:
            query_params.append(('rms', params['rms']))  # noqa: E501
        if 'rms__gte' in params:
            query_params.append(('rms__gte', params['rms__gte']))  # noqa: E501
        if 'rms__lte' in params:
            query_params.append(('rms__lte', params['rms__lte']))  # noqa: E501
        if 'skewness' in params:
            query_params.append(('skewness', params['skewness']))  # noqa: E501
        if 'skewness__gte' in params:
            query_params.append(('skewness__gte', params['skewness__gte']))  # noqa: E501
        if 'skewness__lte' in params:
            query_params.append(('skewness__lte', params['skewness__lte']))  # noqa: E501
        if 'kurtosis' in params:
            query_params.append(('kurtosis', params['kurtosis']))  # noqa: E501
        if 'kurtosis__gte' in params:
            query_params.append(('kurtosis__gte', params['kurtosis__gte']))  # noqa: E501
        if 'kurtosis__lte' in params:
            query_params.append(('kurtosis__lte', params['kurtosis__lte']))  # noqa: E501
        if 'source_data_file' in params:
            query_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'title' in params:
            query_params.append(('title', params['title']))  # noqa: E501
        if 'primary_dataset' in params:
            query_params.append(('primary_dataset', params['primary_dataset']))  # noqa: E501
        if 'run__run_number__in' in params:
            query_params.append(('run__run_number__in', params['run__run_number__in']))  # noqa: E501
        if 'source_data_file__filepath__contains' in params:
            query_params.append(('source_data_file__filepath__contains', params['source_data_file__filepath__contains']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'primary_dataset' in params:
            form_params.append(('primary_dataset', params['primary_dataset']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'mean' in params:
            form_params.append(('mean', params['mean']))  # noqa: E501
        if 'rms' in params:
            form_params.append(('rms', params['rms']))  # noqa: E501
        if 'skewness' in params:
            form_params.append(('skewness', params['skewness']))  # noqa: E501
        if 'kurtosis' in params:
            form_params.append(('kurtosis', params['kurtosis']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'primary_dataset' in params:
            form_params.append(('primary_dataset', params['primary_dataset']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'mean' in params:
            form_params.append(('mean', params['mean']))  # noqa: E501
        if 'rms' in params:
            form_params.append(('rms', params['rms']))  # noqa: E501
        if 'skewness' in params:
            form_params.append(('skewness', params['skewness']))  # noqa: E501
        if 'kurtosis' in params:
            form_params.append(('kurtosis', params['kurtosis']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/run_histograms/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RunHistogram',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def partial_update_run_histogram(self, id, **kwargs):  # noqa: E501
        """partial_update_run_histogram  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_run_histogram(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this run histogram. (required)
        :param int id2:
        :param int run2:
        :param str title2:
        :param str primary_dataset2:
        :param int entries2:
        :param float mean2:
        :param float rms2:
        :param float skewness2:
        :param float kurtosis2:
        :param int source_data_file2:
        :param int id2:
        :param int run:
        :param str title2:
        :param str primary_dataset2:
        :param int entries:
        :param float mean2:
        :param float rms2:
        :param float skewness2:
        :param float kurtosis2:
        :param int source_data_file2:
        :param str run__run_number__gte: run__run_number__gte
        :param str run__run_number__lte: run__run_number__lte
        :param str run__run_number: run__run_number
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str mean: mean
        :param str mean__gte: mean__gte
        :param str mean__lte: mean__lte
        :param str rms: rms
        :param str rms__gte: rms__gte
        :param str rms__lte: rms__lte
        :param str skewness: skewness
        :param str skewness__gte: skewness__gte
        :param str skewness__lte: skewness__lte
        :param str kurtosis: kurtosis
        :param str kurtosis__gte: kurtosis__gte
        :param str kurtosis__lte: kurtosis__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str primary_dataset: primary_dataset
        :param str run__run_number__in: run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: RunHistogram
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.partial_update_run_histogram_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.partial_update_run_histogram_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def partial_update_run_histogram_with_http_info(self, id, **kwargs):  # noqa: E501
        """partial_update_run_histogram  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_run_histogram_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this run histogram. (required)
        :param int id2:
        :param int run2:
        :param str title2:
        :param str primary_dataset2:
        :param int entries2:
        :param float mean2:
        :param float rms2:
        :param float skewness2:
        :param float kurtosis2:
        :param int source_data_file2:
        :param int id2:
        :param int run:
        :param str title2:
        :param str primary_dataset2:
        :param int entries:
        :param float mean2:
        :param float rms2:
        :param float skewness2:
        :param float kurtosis2:
        :param int source_data_file2:
        :param str run__run_number__gte: run__run_number__gte
        :param str run__run_number__lte: run__run_number__lte
        :param str run__run_number: run__run_number
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str mean: mean
        :param str mean__gte: mean__gte
        :param str mean__lte: mean__lte
        :param str rms: rms
        :param str rms__gte: rms__gte
        :param str rms__lte: rms__lte
        :param str skewness: skewness
        :param str skewness__gte: skewness__gte
        :param str skewness__lte: skewness__lte
        :param str kurtosis: kurtosis
        :param str kurtosis__gte: kurtosis__gte
        :param str kurtosis__lte: kurtosis__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str primary_dataset: primary_dataset
        :param str run__run_number__in: run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: RunHistogram
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'id2', 'run2', 'title2', 'primary_dataset2', 'entries2', 'mean2', 'rms2', 'skewness2', 'kurtosis2', 'source_data_file2', 'id2', 'run', 'title2', 'primary_dataset2', 'entries', 'mean2', 'rms2', 'skewness2', 'kurtosis2', 'source_data_file2', 'run__run_number__gte', 'run__run_number__lte', 'run__run_number', 'entries__gte', 'entries__lte', 'mean', 'mean__gte', 'mean__lte', 'rms', 'rms__gte', 'rms__lte', 'skewness', 'skewness__gte', 'skewness__lte', 'kurtosis', 'kurtosis__gte', 'kurtosis__lte', 'source_data_file', 'title', 'primary_dataset', 'run__run_number__in', 'source_data_file__filepath__contains']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method partial_update_run_histogram" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `partial_update_run_histogram`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'run__run_number__gte' in params:
            query_params.append(('run__run_number__gte', params['run__run_number__gte']))  # noqa: E501
        if 'run__run_number__lte' in params:
            query_params.append(('run__run_number__lte', params['run__run_number__lte']))  # noqa: E501
        if 'run__run_number' in params:
            query_params.append(('run__run_number', params['run__run_number']))  # noqa: E501
        if 'entries__gte' in params:
            query_params.append(('entries__gte', params['entries__gte']))  # noqa: E501
        if 'entries__lte' in params:
            query_params.append(('entries__lte', params['entries__lte']))  # noqa: E501
        if 'mean' in params:
            query_params.append(('mean', params['mean']))  # noqa: E501
        if 'mean__gte' in params:
            query_params.append(('mean__gte', params['mean__gte']))  # noqa: E501
        if 'mean__lte' in params:
            query_params.append(('mean__lte', params['mean__lte']))  # noqa: E501
        if 'rms' in params:
            query_params.append(('rms', params['rms']))  # noqa: E501
        if 'rms__gte' in params:
            query_params.append(('rms__gte', params['rms__gte']))  # noqa: E501
        if 'rms__lte' in params:
            query_params.append(('rms__lte', params['rms__lte']))  # noqa: E501
        if 'skewness' in params:
            query_params.append(('skewness', params['skewness']))  # noqa: E501
        if 'skewness__gte' in params:
            query_params.append(('skewness__gte', params['skewness__gte']))  # noqa: E501
        if 'skewness__lte' in params:
            query_params.append(('skewness__lte', params['skewness__lte']))  # noqa: E501
        if 'kurtosis' in params:
            query_params.append(('kurtosis', params['kurtosis']))  # noqa: E501
        if 'kurtosis__gte' in params:
            query_params.append(('kurtosis__gte', params['kurtosis__gte']))  # noqa: E501
        if 'kurtosis__lte' in params:
            query_params.append(('kurtosis__lte', params['kurtosis__lte']))  # noqa: E501
        if 'source_data_file' in params:
            query_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'title' in params:
            query_params.append(('title', params['title']))  # noqa: E501
        if 'primary_dataset' in params:
            query_params.append(('primary_dataset', params['primary_dataset']))  # noqa: E501
        if 'run__run_number__in' in params:
            query_params.append(('run__run_number__in', params['run__run_number__in']))  # noqa: E501
        if 'source_data_file__filepath__contains' in params:
            query_params.append(('source_data_file__filepath__contains', params['source_data_file__filepath__contains']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'primary_dataset' in params:
            form_params.append(('primary_dataset', params['primary_dataset']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'mean' in params:
            form_params.append(('mean', params['mean']))  # noqa: E501
        if 'rms' in params:
            form_params.append(('rms', params['rms']))  # noqa: E501
        if 'skewness' in params:
            form_params.append(('skewness', params['skewness']))  # noqa: E501
        if 'kurtosis' in params:
            form_params.append(('kurtosis', params['kurtosis']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'primary_dataset' in params:
            form_params.append(('primary_dataset', params['primary_dataset']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'mean' in params:
            form_params.append(('mean', params['mean']))  # noqa: E501
        if 'rms' in params:
            form_params.append(('rms', params['rms']))  # noqa: E501
        if 'skewness' in params:
            form_params.append(('skewness', params['skewness']))  # noqa: E501
        if 'kurtosis' in params:
            form_params.append(('kurtosis', params['kurtosis']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/run_histograms/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RunHistogram',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def partial_update_strategy(self, id, **kwargs):  # noqa: E501
        """partial_update_strategy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_strategy(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this strategy. (required)
        :param Strategy body:
        :return: Strategy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.partial_update_strategy_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.partial_update_strategy_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def partial_update_strategy_with_http_info(self, id, **kwargs):  # noqa: E501
        """partial_update_strategy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_strategy_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this strategy. (required)
        :param Strategy body:
        :return: Strategy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method partial_update_strategy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `partial_update_strategy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'model' in params:
            form_params.append(('model', params['model']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'model' in params:
            form_params.append(('model', params['model']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/strategies/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Strategy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def partial_update_strategy(self, id, **kwargs):  # noqa: E501
        """partial_update_strategy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_strategy(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this strategy. (required)
        :param int id2:
        :param str model2:
        :param int id2:
        :param str model:
        :return: Strategy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.partial_update_strategy_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.partial_update_strategy_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def partial_update_strategy_with_http_info(self, id, **kwargs):  # noqa: E501
        """partial_update_strategy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_strategy_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this strategy. (required)
        :param int id2:
        :param str model2:
        :param int id2:
        :param str model:
        :return: Strategy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'id2', 'model2', 'id2', 'model']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method partial_update_strategy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `partial_update_strategy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'model' in params:
            form_params.append(('model', params['model']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'model' in params:
            form_params.append(('model', params['model']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/strategies/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Strategy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def partial_update_strategy(self, id, **kwargs):  # noqa: E501
        """partial_update_strategy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_strategy(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this strategy. (required)
        :param int id2:
        :param str model2:
        :param int id2:
        :param str model:
        :return: Strategy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.partial_update_strategy_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.partial_update_strategy_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def partial_update_strategy_with_http_info(self, id, **kwargs):  # noqa: E501
        """partial_update_strategy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_strategy_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this strategy. (required)
        :param int id2:
        :param str model2:
        :param int id2:
        :param str model:
        :return: Strategy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'id2', 'model2', 'id2', 'model']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method partial_update_strategy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `partial_update_strategy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'model' in params:
            form_params.append(('model', params['model']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'model' in params:
            form_params.append(('model', params['model']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/strategies/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Strategy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def partial_update_task(self, id, **kwargs):  # noqa: E501
        """partial_update_task  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_task(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this task. (required)
        :param Task body:
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.partial_update_task_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.partial_update_task_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def partial_update_task_with_http_info(self, id, **kwargs):  # noqa: E501
        """partial_update_task  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_task_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this task. (required)
        :param Task body:
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method partial_update_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `partial_update_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'training_runs' in params:
            form_params.append(('training_runs', params['training_runs']))  # noqa: E501
            collection_formats['training_runs'] = 'multi'  # noqa: E501
        if 'testing_runs' in params:
            form_params.append(('testing_runs', params['testing_runs']))  # noqa: E501
            collection_formats['testing_runs'] = 'multi'  # noqa: E501
        if 'training_lumisections' in params:
            form_params.append(('training_lumisections', params['training_lumisections']))  # noqa: E501
            collection_formats['training_lumisections'] = 'multi'  # noqa: E501
        if 'testing_lumisections' in params:
            form_params.append(('testing_lumisections', params['testing_lumisections']))  # noqa: E501
            collection_formats['testing_lumisections'] = 'multi'  # noqa: E501
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'metadata' in params:
            form_params.append(('metadata', params['metadata']))  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'training_runs' in params:
            form_params.append(('training_runs', params['training_runs']))  # noqa: E501
            collection_formats['training_runs'] = 'multi'  # noqa: E501
        if 'testing_runs' in params:
            form_params.append(('testing_runs', params['testing_runs']))  # noqa: E501
            collection_formats['testing_runs'] = 'multi'  # noqa: E501
        if 'training_lumisections' in params:
            form_params.append(('training_lumisections', params['training_lumisections']))  # noqa: E501
            collection_formats['training_lumisections'] = 'multi'  # noqa: E501
        if 'testing_lumisections' in params:
            form_params.append(('testing_lumisections', params['testing_lumisections']))  # noqa: E501
            collection_formats['testing_lumisections'] = 'multi'  # noqa: E501
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'metadata' in params:
            form_params.append(('metadata', params['metadata']))  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/tasks/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Task',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def partial_update_task(self, id, **kwargs):  # noqa: E501
        """partial_update_task  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_task(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this task. (required)
        :param int id2:
        :param list[TaskTrainingRuns] training_runs2:
        :param list[TaskTrainingRuns] testing_runs2:
        :param list[TaskTrainingLumisections] training_lumisections2:
        :param list[TaskTrainingLumisections] testing_lumisections2:
        :param str name2:
        :param str metadata2:
        :param datetime created2:
        :param datetime modified2:
        :param int id2:
        :param list[TaskTrainingRuns] training_runs:
        :param list[TaskTrainingRuns] testing_runs:
        :param list[TaskTrainingLumisections] training_lumisections:
        :param list[TaskTrainingLumisections] testing_lumisections:
        :param str name:
        :param str metadata:
        :param datetime created:
        :param datetime modified:
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.partial_update_task_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.partial_update_task_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def partial_update_task_with_http_info(self, id, **kwargs):  # noqa: E501
        """partial_update_task  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_task_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this task. (required)
        :param int id2:
        :param list[TaskTrainingRuns] training_runs2:
        :param list[TaskTrainingRuns] testing_runs2:
        :param list[TaskTrainingLumisections] training_lumisections2:
        :param list[TaskTrainingLumisections] testing_lumisections2:
        :param str name2:
        :param str metadata2:
        :param datetime created2:
        :param datetime modified2:
        :param int id2:
        :param list[TaskTrainingRuns] training_runs:
        :param list[TaskTrainingRuns] testing_runs:
        :param list[TaskTrainingLumisections] training_lumisections:
        :param list[TaskTrainingLumisections] testing_lumisections:
        :param str name:
        :param str metadata:
        :param datetime created:
        :param datetime modified:
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'id2', 'training_runs2', 'testing_runs2', 'training_lumisections2', 'testing_lumisections2', 'name2', 'metadata2', 'created2', 'modified2', 'id2', 'training_runs', 'testing_runs', 'training_lumisections', 'testing_lumisections', 'name', 'metadata', 'created', 'modified']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method partial_update_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `partial_update_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'training_runs' in params:
            form_params.append(('training_runs', params['training_runs']))  # noqa: E501
            collection_formats['training_runs'] = 'multi'  # noqa: E501
        if 'testing_runs' in params:
            form_params.append(('testing_runs', params['testing_runs']))  # noqa: E501
            collection_formats['testing_runs'] = 'multi'  # noqa: E501
        if 'training_lumisections' in params:
            form_params.append(('training_lumisections', params['training_lumisections']))  # noqa: E501
            collection_formats['training_lumisections'] = 'multi'  # noqa: E501
        if 'testing_lumisections' in params:
            form_params.append(('testing_lumisections', params['testing_lumisections']))  # noqa: E501
            collection_formats['testing_lumisections'] = 'multi'  # noqa: E501
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'metadata' in params:
            form_params.append(('metadata', params['metadata']))  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'training_runs' in params:
            form_params.append(('training_runs', params['training_runs']))  # noqa: E501
            collection_formats['training_runs'] = 'multi'  # noqa: E501
        if 'testing_runs' in params:
            form_params.append(('testing_runs', params['testing_runs']))  # noqa: E501
            collection_formats['testing_runs'] = 'multi'  # noqa: E501
        if 'training_lumisections' in params:
            form_params.append(('training_lumisections', params['training_lumisections']))  # noqa: E501
            collection_formats['training_lumisections'] = 'multi'  # noqa: E501
        if 'testing_lumisections' in params:
            form_params.append(('testing_lumisections', params['testing_lumisections']))  # noqa: E501
            collection_formats['testing_lumisections'] = 'multi'  # noqa: E501
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'metadata' in params:
            form_params.append(('metadata', params['metadata']))  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/tasks/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Task',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def partial_update_task(self, id, **kwargs):  # noqa: E501
        """partial_update_task  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_task(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this task. (required)
        :param int id2:
        :param list[TaskTrainingRuns] training_runs2:
        :param list[TaskTrainingRuns] testing_runs2:
        :param list[TaskTrainingLumisections] training_lumisections2:
        :param list[TaskTrainingLumisections] testing_lumisections2:
        :param str name2:
        :param str metadata2:
        :param datetime created2:
        :param datetime modified2:
        :param int id2:
        :param list[TaskTrainingRuns] training_runs:
        :param list[TaskTrainingRuns] testing_runs:
        :param list[TaskTrainingLumisections] training_lumisections:
        :param list[TaskTrainingLumisections] testing_lumisections:
        :param str name:
        :param str metadata:
        :param datetime created:
        :param datetime modified:
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.partial_update_task_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.partial_update_task_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def partial_update_task_with_http_info(self, id, **kwargs):  # noqa: E501
        """partial_update_task  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_task_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this task. (required)
        :param int id2:
        :param list[TaskTrainingRuns] training_runs2:
        :param list[TaskTrainingRuns] testing_runs2:
        :param list[TaskTrainingLumisections] training_lumisections2:
        :param list[TaskTrainingLumisections] testing_lumisections2:
        :param str name2:
        :param str metadata2:
        :param datetime created2:
        :param datetime modified2:
        :param int id2:
        :param list[TaskTrainingRuns] training_runs:
        :param list[TaskTrainingRuns] testing_runs:
        :param list[TaskTrainingLumisections] training_lumisections:
        :param list[TaskTrainingLumisections] testing_lumisections:
        :param str name:
        :param str metadata:
        :param datetime created:
        :param datetime modified:
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'id2', 'training_runs2', 'testing_runs2', 'training_lumisections2', 'testing_lumisections2', 'name2', 'metadata2', 'created2', 'modified2', 'id2', 'training_runs', 'testing_runs', 'training_lumisections', 'testing_lumisections', 'name', 'metadata', 'created', 'modified']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method partial_update_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `partial_update_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'training_runs' in params:
            form_params.append(('training_runs', params['training_runs']))  # noqa: E501
            collection_formats['training_runs'] = 'multi'  # noqa: E501
        if 'testing_runs' in params:
            form_params.append(('testing_runs', params['testing_runs']))  # noqa: E501
            collection_formats['testing_runs'] = 'multi'  # noqa: E501
        if 'training_lumisections' in params:
            form_params.append(('training_lumisections', params['training_lumisections']))  # noqa: E501
            collection_formats['training_lumisections'] = 'multi'  # noqa: E501
        if 'testing_lumisections' in params:
            form_params.append(('testing_lumisections', params['testing_lumisections']))  # noqa: E501
            collection_formats['testing_lumisections'] = 'multi'  # noqa: E501
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'metadata' in params:
            form_params.append(('metadata', params['metadata']))  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'training_runs' in params:
            form_params.append(('training_runs', params['training_runs']))  # noqa: E501
            collection_formats['training_runs'] = 'multi'  # noqa: E501
        if 'testing_runs' in params:
            form_params.append(('testing_runs', params['testing_runs']))  # noqa: E501
            collection_formats['testing_runs'] = 'multi'  # noqa: E501
        if 'training_lumisections' in params:
            form_params.append(('training_lumisections', params['training_lumisections']))  # noqa: E501
            collection_formats['training_lumisections'] = 'multi'  # noqa: E501
        if 'testing_lumisections' in params:
            form_params.append(('testing_lumisections', params['testing_lumisections']))  # noqa: E501
            collection_formats['testing_lumisections'] = 'multi'  # noqa: E501
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'metadata' in params:
            form_params.append(('metadata', params['metadata']))  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/tasks/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Task',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retrieve_histogram_data_file(self, id, **kwargs):  # noqa: E501
        """retrieve_histogram_data_file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_histogram_data_file(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this histogram data file. (required)
        :param str id: id
        :param str data_era: data_era
        :param str data_dimensionality: data_dimensionality
        :param str granularity: granularity
        :param str processing_complete: Processing complete
        :param str entries_total__gt: entries_total__gt
        :param str entries_total__lt: entries_total__lt
        :param str filepath__contains: filepath__contains
        :return: HistogramDataFile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retrieve_histogram_data_file_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.retrieve_histogram_data_file_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def retrieve_histogram_data_file_with_http_info(self, id, **kwargs):  # noqa: E501
        """retrieve_histogram_data_file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_histogram_data_file_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this histogram data file. (required)
        :param str id: id
        :param str data_era: data_era
        :param str data_dimensionality: data_dimensionality
        :param str granularity: granularity
        :param str processing_complete: Processing complete
        :param str entries_total__gt: entries_total__gt
        :param str entries_total__lt: entries_total__lt
        :param str filepath__contains: filepath__contains
        :return: HistogramDataFile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'id', 'data_era', 'data_dimensionality', 'granularity', 'processing_complete', 'entries_total__gt', 'entries_total__lt', 'filepath__contains']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retrieve_histogram_data_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `retrieve_histogram_data_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'data_era' in params:
            query_params.append(('data_era', params['data_era']))  # noqa: E501
        if 'data_dimensionality' in params:
            query_params.append(('data_dimensionality', params['data_dimensionality']))  # noqa: E501
        if 'granularity' in params:
            query_params.append(('granularity', params['granularity']))  # noqa: E501
        if 'processing_complete' in params:
            query_params.append(('processing_complete', params['processing_complete']))  # noqa: E501
        if 'entries_total__gt' in params:
            query_params.append(('entries_total__gt', params['entries_total__gt']))  # noqa: E501
        if 'entries_total__lt' in params:
            query_params.append(('entries_total__lt', params['entries_total__lt']))  # noqa: E501
        if 'filepath__contains' in params:
            query_params.append(('filepath__contains', params['filepath__contains']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/histogram_data_files/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HistogramDataFile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retrieve_lumisection(self, id, **kwargs):  # noqa: E501
        """retrieve_lumisection  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_lumisection(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection. (required)
        :param str run: run
        :param str ls_number: ls_number
        :param str _date: date
        :param str oms_zerobias_rate: oms_zerobias_rate
        :return: Lumisection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retrieve_lumisection_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.retrieve_lumisection_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def retrieve_lumisection_with_http_info(self, id, **kwargs):  # noqa: E501
        """retrieve_lumisection  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_lumisection_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection. (required)
        :param str run: run
        :param str ls_number: ls_number
        :param str _date: date
        :param str oms_zerobias_rate: oms_zerobias_rate
        :return: Lumisection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'run', 'ls_number', '_date', 'oms_zerobias_rate']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retrieve_lumisection" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `retrieve_lumisection`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'run' in params:
            query_params.append(('run', params['run']))  # noqa: E501
        if 'ls_number' in params:
            query_params.append(('ls_number', params['ls_number']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'oms_zerobias_rate' in params:
            query_params.append(('oms_zerobias_rate', params['oms_zerobias_rate']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisections/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Lumisection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retrieve_lumisection_certification(self, id, **kwargs):  # noqa: E501
        """retrieve_lumisection_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_lumisection_certification(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection certification. (required)
        :param str lumisection: lumisection
        :param str _date: date
        :param str rr_is_golden_json: rr_is_golden_json
        :param str rr_is_pixel_good: rr_is_pixel_good
        :param str rr_is_strip_good: rr_is_strip_good
        :param str rr_is_ecal_good: rr_is_ecal_good
        :param str rr_is_hcal_good: rr_is_hcal_good
        :param str rr_is_dt_good: rr_is_dt_good
        :param str rr_is_csc_good: rr_is_csc_good
        :param str rr_is_tracking_good: rr_is_tracking_good
        :param str rr_is_muon_good: rr_is_muon_good
        :param str rr_is_egamma_good: rr_is_egamma_good
        :param str rr_is_tau_good: rr_is_tau_good
        :param str rr_is_jetmet_good: rr_is_jetmet_good
        :param str rr_is_btag_good: rr_is_btag_good
        :param str run: run
        :return: LumisectionCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retrieve_lumisection_certification_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.retrieve_lumisection_certification_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def retrieve_lumisection_certification_with_http_info(self, id, **kwargs):  # noqa: E501
        """retrieve_lumisection_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_lumisection_certification_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection certification. (required)
        :param str lumisection: lumisection
        :param str _date: date
        :param str rr_is_golden_json: rr_is_golden_json
        :param str rr_is_pixel_good: rr_is_pixel_good
        :param str rr_is_strip_good: rr_is_strip_good
        :param str rr_is_ecal_good: rr_is_ecal_good
        :param str rr_is_hcal_good: rr_is_hcal_good
        :param str rr_is_dt_good: rr_is_dt_good
        :param str rr_is_csc_good: rr_is_csc_good
        :param str rr_is_tracking_good: rr_is_tracking_good
        :param str rr_is_muon_good: rr_is_muon_good
        :param str rr_is_egamma_good: rr_is_egamma_good
        :param str rr_is_tau_good: rr_is_tau_good
        :param str rr_is_jetmet_good: rr_is_jetmet_good
        :param str rr_is_btag_good: rr_is_btag_good
        :param str run: run
        :return: LumisectionCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'lumisection', '_date', 'rr_is_golden_json', 'rr_is_pixel_good', 'rr_is_strip_good', 'rr_is_ecal_good', 'rr_is_hcal_good', 'rr_is_dt_good', 'rr_is_csc_good', 'rr_is_tracking_good', 'rr_is_muon_good', 'rr_is_egamma_good', 'rr_is_tau_good', 'rr_is_jetmet_good', 'rr_is_btag_good', 'run']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retrieve_lumisection_certification" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `retrieve_lumisection_certification`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lumisection' in params:
            query_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_golden_json' in params:
            query_params.append(('rr_is_golden_json', params['rr_is_golden_json']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            query_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            query_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            query_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            query_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            query_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            query_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            query_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            query_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            query_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            query_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            query_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            query_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'run' in params:
            query_params.append(('run', params['run']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisection_certifications/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LumisectionCertification',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retrieve_lumisection_histogram1_d(self, id, **kwargs):  # noqa: E501
        """retrieve_lumisection_histogram1_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_lumisection_histogram1_d(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection histogram1d. (required)
        :param str lumisection__run__run_number: lumisection__run__run_number
        :param str lumisection__run__run_number__gte: lumisection__run__run_number__gte
        :param str lumisection__run__run_number__lte: lumisection__run__run_number__lte
        :param str lumisection__ls_number: lumisection__ls_number
        :param str lumisection__ls_number__gte: lumisection__ls_number__gte
        :param str lumisection__ls_number__lte: lumisection__ls_number__lte
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str lumisection__ls_number__in: lumisection__ls_number__in
        :param str lumisection__run__run_number__in: lumisection__run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: LumisectionHistogram1D
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retrieve_lumisection_histogram1_d_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.retrieve_lumisection_histogram1_d_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def retrieve_lumisection_histogram1_d_with_http_info(self, id, **kwargs):  # noqa: E501
        """retrieve_lumisection_histogram1_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_lumisection_histogram1_d_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection histogram1d. (required)
        :param str lumisection__run__run_number: lumisection__run__run_number
        :param str lumisection__run__run_number__gte: lumisection__run__run_number__gte
        :param str lumisection__run__run_number__lte: lumisection__run__run_number__lte
        :param str lumisection__ls_number: lumisection__ls_number
        :param str lumisection__ls_number__gte: lumisection__ls_number__gte
        :param str lumisection__ls_number__lte: lumisection__ls_number__lte
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str lumisection__ls_number__in: lumisection__ls_number__in
        :param str lumisection__run__run_number__in: lumisection__run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: LumisectionHistogram1D
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'lumisection__run__run_number', 'lumisection__run__run_number__gte', 'lumisection__run__run_number__lte', 'lumisection__ls_number', 'lumisection__ls_number__gte', 'lumisection__ls_number__lte', 'entries__gte', 'entries__lte', 'source_data_file', 'title', 'lumisection__ls_number__in', 'lumisection__run__run_number__in', 'source_data_file__filepath__contains']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retrieve_lumisection_histogram1_d" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `retrieve_lumisection_histogram1_d`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lumisection__run__run_number' in params:
            query_params.append(('lumisection__run__run_number', params['lumisection__run__run_number']))  # noqa: E501
        if 'lumisection__run__run_number__gte' in params:
            query_params.append(('lumisection__run__run_number__gte', params['lumisection__run__run_number__gte']))  # noqa: E501
        if 'lumisection__run__run_number__lte' in params:
            query_params.append(('lumisection__run__run_number__lte', params['lumisection__run__run_number__lte']))  # noqa: E501
        if 'lumisection__ls_number' in params:
            query_params.append(('lumisection__ls_number', params['lumisection__ls_number']))  # noqa: E501
        if 'lumisection__ls_number__gte' in params:
            query_params.append(('lumisection__ls_number__gte', params['lumisection__ls_number__gte']))  # noqa: E501
        if 'lumisection__ls_number__lte' in params:
            query_params.append(('lumisection__ls_number__lte', params['lumisection__ls_number__lte']))  # noqa: E501
        if 'entries__gte' in params:
            query_params.append(('entries__gte', params['entries__gte']))  # noqa: E501
        if 'entries__lte' in params:
            query_params.append(('entries__lte', params['entries__lte']))  # noqa: E501
        if 'source_data_file' in params:
            query_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'title' in params:
            query_params.append(('title', params['title']))  # noqa: E501
        if 'lumisection__ls_number__in' in params:
            query_params.append(('lumisection__ls_number__in', params['lumisection__ls_number__in']))  # noqa: E501
        if 'lumisection__run__run_number__in' in params:
            query_params.append(('lumisection__run__run_number__in', params['lumisection__run__run_number__in']))  # noqa: E501
        if 'source_data_file__filepath__contains' in params:
            query_params.append(('source_data_file__filepath__contains', params['source_data_file__filepath__contains']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisection_histograms_1d/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LumisectionHistogram1D',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retrieve_lumisection_histogram2_d(self, id, **kwargs):  # noqa: E501
        """retrieve_lumisection_histogram2_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_lumisection_histogram2_d(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection histogram2d. (required)
        :param str lumisection__run__run_number: lumisection__run__run_number
        :param str lumisection__run__run_number__gte: lumisection__run__run_number__gte
        :param str lumisection__run__run_number__lte: lumisection__run__run_number__lte
        :param str lumisection__ls_number: lumisection__ls_number
        :param str lumisection__ls_number__gte: lumisection__ls_number__gte
        :param str lumisection__ls_number__lte: lumisection__ls_number__lte
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str lumisection__ls_number__in: lumisection__ls_number__in
        :param str lumisection__run__run_number__in: lumisection__run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: LumisectionHistogram2D
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retrieve_lumisection_histogram2_d_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.retrieve_lumisection_histogram2_d_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def retrieve_lumisection_histogram2_d_with_http_info(self, id, **kwargs):  # noqa: E501
        """retrieve_lumisection_histogram2_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_lumisection_histogram2_d_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection histogram2d. (required)
        :param str lumisection__run__run_number: lumisection__run__run_number
        :param str lumisection__run__run_number__gte: lumisection__run__run_number__gte
        :param str lumisection__run__run_number__lte: lumisection__run__run_number__lte
        :param str lumisection__ls_number: lumisection__ls_number
        :param str lumisection__ls_number__gte: lumisection__ls_number__gte
        :param str lumisection__ls_number__lte: lumisection__ls_number__lte
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str lumisection__ls_number__in: lumisection__ls_number__in
        :param str lumisection__run__run_number__in: lumisection__run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: LumisectionHistogram2D
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'lumisection__run__run_number', 'lumisection__run__run_number__gte', 'lumisection__run__run_number__lte', 'lumisection__ls_number', 'lumisection__ls_number__gte', 'lumisection__ls_number__lte', 'entries__gte', 'entries__lte', 'source_data_file', 'title', 'lumisection__ls_number__in', 'lumisection__run__run_number__in', 'source_data_file__filepath__contains']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retrieve_lumisection_histogram2_d" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `retrieve_lumisection_histogram2_d`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lumisection__run__run_number' in params:
            query_params.append(('lumisection__run__run_number', params['lumisection__run__run_number']))  # noqa: E501
        if 'lumisection__run__run_number__gte' in params:
            query_params.append(('lumisection__run__run_number__gte', params['lumisection__run__run_number__gte']))  # noqa: E501
        if 'lumisection__run__run_number__lte' in params:
            query_params.append(('lumisection__run__run_number__lte', params['lumisection__run__run_number__lte']))  # noqa: E501
        if 'lumisection__ls_number' in params:
            query_params.append(('lumisection__ls_number', params['lumisection__ls_number']))  # noqa: E501
        if 'lumisection__ls_number__gte' in params:
            query_params.append(('lumisection__ls_number__gte', params['lumisection__ls_number__gte']))  # noqa: E501
        if 'lumisection__ls_number__lte' in params:
            query_params.append(('lumisection__ls_number__lte', params['lumisection__ls_number__lte']))  # noqa: E501
        if 'entries__gte' in params:
            query_params.append(('entries__gte', params['entries__gte']))  # noqa: E501
        if 'entries__lte' in params:
            query_params.append(('entries__lte', params['entries__lte']))  # noqa: E501
        if 'source_data_file' in params:
            query_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'title' in params:
            query_params.append(('title', params['title']))  # noqa: E501
        if 'lumisection__ls_number__in' in params:
            query_params.append(('lumisection__ls_number__in', params['lumisection__ls_number__in']))  # noqa: E501
        if 'lumisection__run__run_number__in' in params:
            query_params.append(('lumisection__run__run_number__in', params['lumisection__run__run_number__in']))  # noqa: E501
        if 'source_data_file__filepath__contains' in params:
            query_params.append(('source_data_file__filepath__contains', params['source_data_file__filepath__contains']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisection_histograms_2d/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LumisectionHistogram2D',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retrieve_prediction(self, id, **kwargs):  # noqa: E501
        """retrieve_prediction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_prediction(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this prediction. (required)
        :return: Prediction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retrieve_prediction_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.retrieve_prediction_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def retrieve_prediction_with_http_info(self, id, **kwargs):  # noqa: E501
        """retrieve_prediction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_prediction_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this prediction. (required)
        :return: Prediction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retrieve_prediction" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `retrieve_prediction`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/predictions/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Prediction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retrieve_run(self, run_number, **kwargs):  # noqa: E501
        """retrieve_run  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_run(run_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str run_number: A unique value identifying this run. (required)
        :param str run_number: run_number
        :param str run_date: run_date
        :param str year: year
        :param str period: period
        :param str _date: date
        :param str oms_fill: oms_fill
        :param str oms_lumisections: oms_lumisections
        :param str oms_initial_lumi: oms_initial_lumi
        :param str oms_end_lumi: oms_end_lumi
        :return: Run
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retrieve_run_with_http_info(run_number, **kwargs)  # noqa: E501
        else:
            (data) = self.retrieve_run_with_http_info(run_number, **kwargs)  # noqa: E501
            return data

    def retrieve_run_with_http_info(self, run_number, **kwargs):  # noqa: E501
        """retrieve_run  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_run_with_http_info(run_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str run_number: A unique value identifying this run. (required)
        :param str run_number: run_number
        :param str run_date: run_date
        :param str year: year
        :param str period: period
        :param str _date: date
        :param str oms_fill: oms_fill
        :param str oms_lumisections: oms_lumisections
        :param str oms_initial_lumi: oms_initial_lumi
        :param str oms_end_lumi: oms_end_lumi
        :return: Run
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['run_number', 'run_number', 'run_date', 'year', 'period', '_date', 'oms_fill', 'oms_lumisections', 'oms_initial_lumi', 'oms_end_lumi']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retrieve_run" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'run_number' is set
        if ('run_number' not in params or
                params['run_number'] is None):
            raise ValueError("Missing the required parameter `run_number` when calling `retrieve_run`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'run_number' in params:
            path_params['run_number'] = params['run_number']  # noqa: E501

        query_params = []
        if 'run_number' in params:
            query_params.append(('run_number', params['run_number']))  # noqa: E501
        if 'run_date' in params:
            query_params.append(('run_date', params['run_date']))  # noqa: E501
        if 'year' in params:
            query_params.append(('year', params['year']))  # noqa: E501
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'oms_fill' in params:
            query_params.append(('oms_fill', params['oms_fill']))  # noqa: E501
        if 'oms_lumisections' in params:
            query_params.append(('oms_lumisections', params['oms_lumisections']))  # noqa: E501
        if 'oms_initial_lumi' in params:
            query_params.append(('oms_initial_lumi', params['oms_initial_lumi']))  # noqa: E501
        if 'oms_end_lumi' in params:
            query_params.append(('oms_end_lumi', params['oms_end_lumi']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/runs/{run_number}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Run',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retrieve_run_certification(self, id, **kwargs):  # noqa: E501
        """retrieve_run_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_run_certification(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this run certification. (required)
        :param str run: run
        :param str _date: date
        :param str rr_is_pixel_good: rr_is_pixel_good
        :param str rr_is_strip_good: rr_is_strip_good
        :param str rr_is_ecal_good: rr_is_ecal_good
        :param str rr_is_hcal_good: rr_is_hcal_good
        :param str rr_is_dt_good: rr_is_dt_good
        :param str rr_is_csc_good: rr_is_csc_good
        :param str rr_is_tracking_good: rr_is_tracking_good
        :param str rr_is_muon_good: rr_is_muon_good
        :param str rr_is_egamma_good: rr_is_egamma_good
        :param str rr_is_tau_good: rr_is_tau_good
        :param str rr_is_jetmet_good: rr_is_jetmet_good
        :param str rr_is_btag_good: rr_is_btag_good
        :param str rr_frac_pixel_good: rr_frac_pixel_good
        :param str rr_frac_strip_good: rr_frac_strip_good
        :param str rr_frac_ecal_good: rr_frac_ecal_good
        :param str rr_frac_hcal_good: rr_frac_hcal_good
        :param str rr_frac_dt_good: rr_frac_dt_good
        :param str rr_frac_csc_good: rr_frac_csc_good
        :param str rr_frac_tracking_good: rr_frac_tracking_good
        :param str rr_frac_muon_good: rr_frac_muon_good
        :param str rr_frac_egamma_good: rr_frac_egamma_good
        :param str rr_frac_tau_good: rr_frac_tau_good
        :param str rr_frac_jetmet_good: rr_frac_jetmet_good
        :param str rr_frac_btag_good: rr_frac_btag_good
        :return: RunCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retrieve_run_certification_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.retrieve_run_certification_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def retrieve_run_certification_with_http_info(self, id, **kwargs):  # noqa: E501
        """retrieve_run_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_run_certification_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this run certification. (required)
        :param str run: run
        :param str _date: date
        :param str rr_is_pixel_good: rr_is_pixel_good
        :param str rr_is_strip_good: rr_is_strip_good
        :param str rr_is_ecal_good: rr_is_ecal_good
        :param str rr_is_hcal_good: rr_is_hcal_good
        :param str rr_is_dt_good: rr_is_dt_good
        :param str rr_is_csc_good: rr_is_csc_good
        :param str rr_is_tracking_good: rr_is_tracking_good
        :param str rr_is_muon_good: rr_is_muon_good
        :param str rr_is_egamma_good: rr_is_egamma_good
        :param str rr_is_tau_good: rr_is_tau_good
        :param str rr_is_jetmet_good: rr_is_jetmet_good
        :param str rr_is_btag_good: rr_is_btag_good
        :param str rr_frac_pixel_good: rr_frac_pixel_good
        :param str rr_frac_strip_good: rr_frac_strip_good
        :param str rr_frac_ecal_good: rr_frac_ecal_good
        :param str rr_frac_hcal_good: rr_frac_hcal_good
        :param str rr_frac_dt_good: rr_frac_dt_good
        :param str rr_frac_csc_good: rr_frac_csc_good
        :param str rr_frac_tracking_good: rr_frac_tracking_good
        :param str rr_frac_muon_good: rr_frac_muon_good
        :param str rr_frac_egamma_good: rr_frac_egamma_good
        :param str rr_frac_tau_good: rr_frac_tau_good
        :param str rr_frac_jetmet_good: rr_frac_jetmet_good
        :param str rr_frac_btag_good: rr_frac_btag_good
        :return: RunCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'run', '_date', 'rr_is_pixel_good', 'rr_is_strip_good', 'rr_is_ecal_good', 'rr_is_hcal_good', 'rr_is_dt_good', 'rr_is_csc_good', 'rr_is_tracking_good', 'rr_is_muon_good', 'rr_is_egamma_good', 'rr_is_tau_good', 'rr_is_jetmet_good', 'rr_is_btag_good', 'rr_frac_pixel_good', 'rr_frac_strip_good', 'rr_frac_ecal_good', 'rr_frac_hcal_good', 'rr_frac_dt_good', 'rr_frac_csc_good', 'rr_frac_tracking_good', 'rr_frac_muon_good', 'rr_frac_egamma_good', 'rr_frac_tau_good', 'rr_frac_jetmet_good', 'rr_frac_btag_good']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retrieve_run_certification" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `retrieve_run_certification`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'run' in params:
            query_params.append(('run', params['run']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            query_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            query_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            query_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            query_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            query_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            query_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            query_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            query_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            query_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            query_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            query_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            query_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'rr_frac_pixel_good' in params:
            query_params.append(('rr_frac_pixel_good', params['rr_frac_pixel_good']))  # noqa: E501
        if 'rr_frac_strip_good' in params:
            query_params.append(('rr_frac_strip_good', params['rr_frac_strip_good']))  # noqa: E501
        if 'rr_frac_ecal_good' in params:
            query_params.append(('rr_frac_ecal_good', params['rr_frac_ecal_good']))  # noqa: E501
        if 'rr_frac_hcal_good' in params:
            query_params.append(('rr_frac_hcal_good', params['rr_frac_hcal_good']))  # noqa: E501
        if 'rr_frac_dt_good' in params:
            query_params.append(('rr_frac_dt_good', params['rr_frac_dt_good']))  # noqa: E501
        if 'rr_frac_csc_good' in params:
            query_params.append(('rr_frac_csc_good', params['rr_frac_csc_good']))  # noqa: E501
        if 'rr_frac_tracking_good' in params:
            query_params.append(('rr_frac_tracking_good', params['rr_frac_tracking_good']))  # noqa: E501
        if 'rr_frac_muon_good' in params:
            query_params.append(('rr_frac_muon_good', params['rr_frac_muon_good']))  # noqa: E501
        if 'rr_frac_egamma_good' in params:
            query_params.append(('rr_frac_egamma_good', params['rr_frac_egamma_good']))  # noqa: E501
        if 'rr_frac_tau_good' in params:
            query_params.append(('rr_frac_tau_good', params['rr_frac_tau_good']))  # noqa: E501
        if 'rr_frac_jetmet_good' in params:
            query_params.append(('rr_frac_jetmet_good', params['rr_frac_jetmet_good']))  # noqa: E501
        if 'rr_frac_btag_good' in params:
            query_params.append(('rr_frac_btag_good', params['rr_frac_btag_good']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/run_certifications/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RunCertification',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retrieve_run_histogram(self, id, **kwargs):  # noqa: E501
        """retrieve_run_histogram  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_run_histogram(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this run histogram. (required)
        :param str run__run_number__gte: run__run_number__gte
        :param str run__run_number__lte: run__run_number__lte
        :param str run__run_number: run__run_number
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str mean: mean
        :param str mean__gte: mean__gte
        :param str mean__lte: mean__lte
        :param str rms: rms
        :param str rms__gte: rms__gte
        :param str rms__lte: rms__lte
        :param str skewness: skewness
        :param str skewness__gte: skewness__gte
        :param str skewness__lte: skewness__lte
        :param str kurtosis: kurtosis
        :param str kurtosis__gte: kurtosis__gte
        :param str kurtosis__lte: kurtosis__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str primary_dataset: primary_dataset
        :param str run__run_number__in: run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: RunHistogram
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retrieve_run_histogram_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.retrieve_run_histogram_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def retrieve_run_histogram_with_http_info(self, id, **kwargs):  # noqa: E501
        """retrieve_run_histogram  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_run_histogram_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this run histogram. (required)
        :param str run__run_number__gte: run__run_number__gte
        :param str run__run_number__lte: run__run_number__lte
        :param str run__run_number: run__run_number
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str mean: mean
        :param str mean__gte: mean__gte
        :param str mean__lte: mean__lte
        :param str rms: rms
        :param str rms__gte: rms__gte
        :param str rms__lte: rms__lte
        :param str skewness: skewness
        :param str skewness__gte: skewness__gte
        :param str skewness__lte: skewness__lte
        :param str kurtosis: kurtosis
        :param str kurtosis__gte: kurtosis__gte
        :param str kurtosis__lte: kurtosis__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str primary_dataset: primary_dataset
        :param str run__run_number__in: run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: RunHistogram
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'run__run_number__gte', 'run__run_number__lte', 'run__run_number', 'entries__gte', 'entries__lte', 'mean', 'mean__gte', 'mean__lte', 'rms', 'rms__gte', 'rms__lte', 'skewness', 'skewness__gte', 'skewness__lte', 'kurtosis', 'kurtosis__gte', 'kurtosis__lte', 'source_data_file', 'title', 'primary_dataset', 'run__run_number__in', 'source_data_file__filepath__contains']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retrieve_run_histogram" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `retrieve_run_histogram`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'run__run_number__gte' in params:
            query_params.append(('run__run_number__gte', params['run__run_number__gte']))  # noqa: E501
        if 'run__run_number__lte' in params:
            query_params.append(('run__run_number__lte', params['run__run_number__lte']))  # noqa: E501
        if 'run__run_number' in params:
            query_params.append(('run__run_number', params['run__run_number']))  # noqa: E501
        if 'entries__gte' in params:
            query_params.append(('entries__gte', params['entries__gte']))  # noqa: E501
        if 'entries__lte' in params:
            query_params.append(('entries__lte', params['entries__lte']))  # noqa: E501
        if 'mean' in params:
            query_params.append(('mean', params['mean']))  # noqa: E501
        if 'mean__gte' in params:
            query_params.append(('mean__gte', params['mean__gte']))  # noqa: E501
        if 'mean__lte' in params:
            query_params.append(('mean__lte', params['mean__lte']))  # noqa: E501
        if 'rms' in params:
            query_params.append(('rms', params['rms']))  # noqa: E501
        if 'rms__gte' in params:
            query_params.append(('rms__gte', params['rms__gte']))  # noqa: E501
        if 'rms__lte' in params:
            query_params.append(('rms__lte', params['rms__lte']))  # noqa: E501
        if 'skewness' in params:
            query_params.append(('skewness', params['skewness']))  # noqa: E501
        if 'skewness__gte' in params:
            query_params.append(('skewness__gte', params['skewness__gte']))  # noqa: E501
        if 'skewness__lte' in params:
            query_params.append(('skewness__lte', params['skewness__lte']))  # noqa: E501
        if 'kurtosis' in params:
            query_params.append(('kurtosis', params['kurtosis']))  # noqa: E501
        if 'kurtosis__gte' in params:
            query_params.append(('kurtosis__gte', params['kurtosis__gte']))  # noqa: E501
        if 'kurtosis__lte' in params:
            query_params.append(('kurtosis__lte', params['kurtosis__lte']))  # noqa: E501
        if 'source_data_file' in params:
            query_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'title' in params:
            query_params.append(('title', params['title']))  # noqa: E501
        if 'primary_dataset' in params:
            query_params.append(('primary_dataset', params['primary_dataset']))  # noqa: E501
        if 'run__run_number__in' in params:
            query_params.append(('run__run_number__in', params['run__run_number__in']))  # noqa: E501
        if 'source_data_file__filepath__contains' in params:
            query_params.append(('source_data_file__filepath__contains', params['source_data_file__filepath__contains']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/run_histograms/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RunHistogram',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retrieve_strategy(self, id, **kwargs):  # noqa: E501
        """retrieve_strategy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_strategy(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this strategy. (required)
        :return: Strategy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retrieve_strategy_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.retrieve_strategy_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def retrieve_strategy_with_http_info(self, id, **kwargs):  # noqa: E501
        """retrieve_strategy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_strategy_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this strategy. (required)
        :return: Strategy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retrieve_strategy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `retrieve_strategy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/strategies/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Strategy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retrieve_task(self, id, **kwargs):  # noqa: E501
        """retrieve_task  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_task(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this task. (required)
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retrieve_task_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.retrieve_task_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def retrieve_task_with_http_info(self, id, **kwargs):  # noqa: E501
        """retrieve_task  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_task_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this task. (required)
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retrieve_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `retrieve_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/tasks/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Task',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def start_parsing_histogram_data_file(self, id, **kwargs):  # noqa: E501
        """start_parsing_histogram_data_file  # noqa: E501

        Start parsing a specific HistogramDataFile, identified by pk  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_parsing_histogram_data_file(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this histogram data file. (required)
        :param HistogramDataFile body:
        :return: HistogramDataFile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.start_parsing_histogram_data_file_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.start_parsing_histogram_data_file_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def start_parsing_histogram_data_file_with_http_info(self, id, **kwargs):  # noqa: E501
        """start_parsing_histogram_data_file  # noqa: E501

        Start parsing a specific HistogramDataFile, identified by pk  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_parsing_histogram_data_file_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this histogram data file. (required)
        :param HistogramDataFile body:
        :return: HistogramDataFile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method start_parsing_histogram_data_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `start_parsing_histogram_data_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'filepath' in params:
            form_params.append(('filepath', params['filepath']))  # noqa: E501
        if 'filesize' in params:
            form_params.append(('filesize', params['filesize']))  # noqa: E501
        if 'data_era' in params:
            form_params.append(('data_era', params['data_era']))  # noqa: E501
        if 'entries_total' in params:
            form_params.append(('entries_total', params['entries_total']))  # noqa: E501
        if 'entries_processed' in params:
            form_params.append(('entries_processed', params['entries_processed']))  # noqa: E501
        if 'percentage_processed' in params:
            form_params.append(('percentage_processed', params['percentage_processed']))  # noqa: E501
        if 'contents' in params:
            form_params.append(('contents', params['contents']))  # noqa: E501
            collection_formats['contents'] = 'multi'  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501
        if 'run_histograms' in params:
            form_params.append(('run_histograms', params['run_histograms']))  # noqa: E501
        if 'lumisection_histograms_1d' in params:
            form_params.append(('lumisection_histograms_1d', params['lumisection_histograms_1d']))  # noqa: E501
        if 'lumisection_histograms_2d' in params:
            form_params.append(('lumisection_histograms_2d', params['lumisection_histograms_2d']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'filepath' in params:
            form_params.append(('filepath', params['filepath']))  # noqa: E501
        if 'filesize' in params:
            form_params.append(('filesize', params['filesize']))  # noqa: E501
        if 'data_era' in params:
            form_params.append(('data_era', params['data_era']))  # noqa: E501
        if 'entries_total' in params:
            form_params.append(('entries_total', params['entries_total']))  # noqa: E501
        if 'entries_processed' in params:
            form_params.append(('entries_processed', params['entries_processed']))  # noqa: E501
        if 'percentage_processed' in params:
            form_params.append(('percentage_processed', params['percentage_processed']))  # noqa: E501
        if 'contents' in params:
            form_params.append(('contents', params['contents']))  # noqa: E501
            collection_formats['contents'] = 'multi'  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501
        if 'run_histograms' in params:
            form_params.append(('run_histograms', params['run_histograms']))  # noqa: E501
        if 'lumisection_histograms_1d' in params:
            form_params.append(('lumisection_histograms_1d', params['lumisection_histograms_1d']))  # noqa: E501
        if 'lumisection_histograms_2d' in params:
            form_params.append(('lumisection_histograms_2d', params['lumisection_histograms_2d']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/histogram_data_files/{id}/start_parsing/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HistogramDataFile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def start_parsing_histogram_data_file(self, id, **kwargs):  # noqa: E501
        """start_parsing_histogram_data_file  # noqa: E501

        Start parsing a specific HistogramDataFile, identified by pk  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_parsing_histogram_data_file(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this histogram data file. (required)
        :param int id2:
        :param str filepath2:
        :param float filesize2:
        :param str data_era2:
        :param int entries_total2:
        :param int entries_processed2:
        :param str percentage_processed2:
        :param list[HistogramDataFileContents] contents2:
        :param datetime created2:
        :param datetime modified2:
        :param int run_histograms2:
        :param int lumisection_histograms_1d2:
        :param int lumisection_histograms_2d2:
        :param int id2:
        :param str filepath:
        :param float filesize:
        :param str data_era:
        :param int entries_total:
        :param int entries_processed:
        :param str percentage_processed:
        :param list[HistogramDataFileContents] contents:
        :param datetime created:
        :param datetime modified:
        :param int run_histograms:
        :param int lumisection_histograms_1d:
        :param int lumisection_histograms_2d:
        :return: HistogramDataFile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.start_parsing_histogram_data_file_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.start_parsing_histogram_data_file_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def start_parsing_histogram_data_file_with_http_info(self, id, **kwargs):  # noqa: E501
        """start_parsing_histogram_data_file  # noqa: E501

        Start parsing a specific HistogramDataFile, identified by pk  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_parsing_histogram_data_file_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this histogram data file. (required)
        :param int id2:
        :param str filepath2:
        :param float filesize2:
        :param str data_era2:
        :param int entries_total2:
        :param int entries_processed2:
        :param str percentage_processed2:
        :param list[HistogramDataFileContents] contents2:
        :param datetime created2:
        :param datetime modified2:
        :param int run_histograms2:
        :param int lumisection_histograms_1d2:
        :param int lumisection_histograms_2d2:
        :param int id2:
        :param str filepath:
        :param float filesize:
        :param str data_era:
        :param int entries_total:
        :param int entries_processed:
        :param str percentage_processed:
        :param list[HistogramDataFileContents] contents:
        :param datetime created:
        :param datetime modified:
        :param int run_histograms:
        :param int lumisection_histograms_1d:
        :param int lumisection_histograms_2d:
        :return: HistogramDataFile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'id2', 'filepath2', 'filesize2', 'data_era2', 'entries_total2', 'entries_processed2', 'percentage_processed2', 'contents2', 'created2', 'modified2', 'run_histograms2', 'lumisection_histograms_1d2', 'lumisection_histograms_2d2', 'id2', 'filepath', 'filesize', 'data_era', 'entries_total', 'entries_processed', 'percentage_processed', 'contents', 'created', 'modified', 'run_histograms', 'lumisection_histograms_1d', 'lumisection_histograms_2d']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method start_parsing_histogram_data_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `start_parsing_histogram_data_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'filepath' in params:
            form_params.append(('filepath', params['filepath']))  # noqa: E501
        if 'filesize' in params:
            form_params.append(('filesize', params['filesize']))  # noqa: E501
        if 'data_era' in params:
            form_params.append(('data_era', params['data_era']))  # noqa: E501
        if 'entries_total' in params:
            form_params.append(('entries_total', params['entries_total']))  # noqa: E501
        if 'entries_processed' in params:
            form_params.append(('entries_processed', params['entries_processed']))  # noqa: E501
        if 'percentage_processed' in params:
            form_params.append(('percentage_processed', params['percentage_processed']))  # noqa: E501
        if 'contents' in params:
            form_params.append(('contents', params['contents']))  # noqa: E501
            collection_formats['contents'] = 'multi'  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501
        if 'run_histograms' in params:
            form_params.append(('run_histograms', params['run_histograms']))  # noqa: E501
        if 'lumisection_histograms_1d' in params:
            form_params.append(('lumisection_histograms_1d', params['lumisection_histograms_1d']))  # noqa: E501
        if 'lumisection_histograms_2d' in params:
            form_params.append(('lumisection_histograms_2d', params['lumisection_histograms_2d']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'filepath' in params:
            form_params.append(('filepath', params['filepath']))  # noqa: E501
        if 'filesize' in params:
            form_params.append(('filesize', params['filesize']))  # noqa: E501
        if 'data_era' in params:
            form_params.append(('data_era', params['data_era']))  # noqa: E501
        if 'entries_total' in params:
            form_params.append(('entries_total', params['entries_total']))  # noqa: E501
        if 'entries_processed' in params:
            form_params.append(('entries_processed', params['entries_processed']))  # noqa: E501
        if 'percentage_processed' in params:
            form_params.append(('percentage_processed', params['percentage_processed']))  # noqa: E501
        if 'contents' in params:
            form_params.append(('contents', params['contents']))  # noqa: E501
            collection_formats['contents'] = 'multi'  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501
        if 'run_histograms' in params:
            form_params.append(('run_histograms', params['run_histograms']))  # noqa: E501
        if 'lumisection_histograms_1d' in params:
            form_params.append(('lumisection_histograms_1d', params['lumisection_histograms_1d']))  # noqa: E501
        if 'lumisection_histograms_2d' in params:
            form_params.append(('lumisection_histograms_2d', params['lumisection_histograms_2d']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/histogram_data_files/{id}/start_parsing/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HistogramDataFile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def start_parsing_histogram_data_file(self, id, **kwargs):  # noqa: E501
        """start_parsing_histogram_data_file  # noqa: E501

        Start parsing a specific HistogramDataFile, identified by pk  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_parsing_histogram_data_file(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this histogram data file. (required)
        :param int id2:
        :param str filepath2:
        :param float filesize2:
        :param str data_era2:
        :param int entries_total2:
        :param int entries_processed2:
        :param str percentage_processed2:
        :param list[HistogramDataFileContents] contents2:
        :param datetime created2:
        :param datetime modified2:
        :param int run_histograms2:
        :param int lumisection_histograms_1d2:
        :param int lumisection_histograms_2d2:
        :param int id2:
        :param str filepath:
        :param float filesize:
        :param str data_era:
        :param int entries_total:
        :param int entries_processed:
        :param str percentage_processed:
        :param list[HistogramDataFileContents] contents:
        :param datetime created:
        :param datetime modified:
        :param int run_histograms:
        :param int lumisection_histograms_1d:
        :param int lumisection_histograms_2d:
        :return: HistogramDataFile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.start_parsing_histogram_data_file_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.start_parsing_histogram_data_file_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def start_parsing_histogram_data_file_with_http_info(self, id, **kwargs):  # noqa: E501
        """start_parsing_histogram_data_file  # noqa: E501

        Start parsing a specific HistogramDataFile, identified by pk  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_parsing_histogram_data_file_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this histogram data file. (required)
        :param int id2:
        :param str filepath2:
        :param float filesize2:
        :param str data_era2:
        :param int entries_total2:
        :param int entries_processed2:
        :param str percentage_processed2:
        :param list[HistogramDataFileContents] contents2:
        :param datetime created2:
        :param datetime modified2:
        :param int run_histograms2:
        :param int lumisection_histograms_1d2:
        :param int lumisection_histograms_2d2:
        :param int id2:
        :param str filepath:
        :param float filesize:
        :param str data_era:
        :param int entries_total:
        :param int entries_processed:
        :param str percentage_processed:
        :param list[HistogramDataFileContents] contents:
        :param datetime created:
        :param datetime modified:
        :param int run_histograms:
        :param int lumisection_histograms_1d:
        :param int lumisection_histograms_2d:
        :return: HistogramDataFile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'id2', 'filepath2', 'filesize2', 'data_era2', 'entries_total2', 'entries_processed2', 'percentage_processed2', 'contents2', 'created2', 'modified2', 'run_histograms2', 'lumisection_histograms_1d2', 'lumisection_histograms_2d2', 'id2', 'filepath', 'filesize', 'data_era', 'entries_total', 'entries_processed', 'percentage_processed', 'contents', 'created', 'modified', 'run_histograms', 'lumisection_histograms_1d', 'lumisection_histograms_2d']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method start_parsing_histogram_data_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `start_parsing_histogram_data_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'filepath' in params:
            form_params.append(('filepath', params['filepath']))  # noqa: E501
        if 'filesize' in params:
            form_params.append(('filesize', params['filesize']))  # noqa: E501
        if 'data_era' in params:
            form_params.append(('data_era', params['data_era']))  # noqa: E501
        if 'entries_total' in params:
            form_params.append(('entries_total', params['entries_total']))  # noqa: E501
        if 'entries_processed' in params:
            form_params.append(('entries_processed', params['entries_processed']))  # noqa: E501
        if 'percentage_processed' in params:
            form_params.append(('percentage_processed', params['percentage_processed']))  # noqa: E501
        if 'contents' in params:
            form_params.append(('contents', params['contents']))  # noqa: E501
            collection_formats['contents'] = 'multi'  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501
        if 'run_histograms' in params:
            form_params.append(('run_histograms', params['run_histograms']))  # noqa: E501
        if 'lumisection_histograms_1d' in params:
            form_params.append(('lumisection_histograms_1d', params['lumisection_histograms_1d']))  # noqa: E501
        if 'lumisection_histograms_2d' in params:
            form_params.append(('lumisection_histograms_2d', params['lumisection_histograms_2d']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'filepath' in params:
            form_params.append(('filepath', params['filepath']))  # noqa: E501
        if 'filesize' in params:
            form_params.append(('filesize', params['filesize']))  # noqa: E501
        if 'data_era' in params:
            form_params.append(('data_era', params['data_era']))  # noqa: E501
        if 'entries_total' in params:
            form_params.append(('entries_total', params['entries_total']))  # noqa: E501
        if 'entries_processed' in params:
            form_params.append(('entries_processed', params['entries_processed']))  # noqa: E501
        if 'percentage_processed' in params:
            form_params.append(('percentage_processed', params['percentage_processed']))  # noqa: E501
        if 'contents' in params:
            form_params.append(('contents', params['contents']))  # noqa: E501
            collection_formats['contents'] = 'multi'  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501
        if 'run_histograms' in params:
            form_params.append(('run_histograms', params['run_histograms']))  # noqa: E501
        if 'lumisection_histograms_1d' in params:
            form_params.append(('lumisection_histograms_1d', params['lumisection_histograms_1d']))  # noqa: E501
        if 'lumisection_histograms_2d' in params:
            form_params.append(('lumisection_histograms_2d', params['lumisection_histograms_2d']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/histogram_data_files/{id}/start_parsing/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HistogramDataFile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_lumisection(self, id, **kwargs):  # noqa: E501
        """update_lumisection  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_lumisection(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection. (required)
        :param Lumisection body:
        :param str run: run
        :param str ls_number: ls_number
        :param str _date: date
        :param str oms_zerobias_rate: oms_zerobias_rate
        :return: Lumisection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_lumisection_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_lumisection_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_lumisection_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_lumisection  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_lumisection_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection. (required)
        :param Lumisection body:
        :param str run: run
        :param str ls_number: ls_number
        :param str _date: date
        :param str oms_zerobias_rate: oms_zerobias_rate
        :return: Lumisection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'run', 'ls_number', '_date', 'oms_zerobias_rate']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_lumisection" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_lumisection`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'run' in params:
            query_params.append(('run', params['run']))  # noqa: E501
        if 'ls_number' in params:
            query_params.append(('ls_number', params['ls_number']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'oms_zerobias_rate' in params:
            query_params.append(('oms_zerobias_rate', params['oms_zerobias_rate']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'ls_number' in params:
            form_params.append(('ls_number', params['ls_number']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'ls_number' in params:
            form_params.append(('ls_number', params['ls_number']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisections/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Lumisection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_lumisection(self, id, **kwargs):  # noqa: E501
        """update_lumisection  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_lumisection(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection. (required)
        :param str run2:
        :param int ls_number2:
        :param datetime _date2:
        :param str run2:
        :param int ls_number2:
        :param datetime _date2:
        :param str run: run
        :param str ls_number: ls_number
        :param str _date: date
        :param str oms_zerobias_rate: oms_zerobias_rate
        :return: Lumisection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_lumisection_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_lumisection_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_lumisection_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_lumisection  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_lumisection_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection. (required)
        :param str run2:
        :param int ls_number2:
        :param datetime _date2:
        :param str run2:
        :param int ls_number2:
        :param datetime _date2:
        :param str run: run
        :param str ls_number: ls_number
        :param str _date: date
        :param str oms_zerobias_rate: oms_zerobias_rate
        :return: Lumisection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'run2', 'ls_number2', '_date2', 'run2', 'ls_number2', '_date2', 'run', 'ls_number', '_date', 'oms_zerobias_rate']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_lumisection" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_lumisection`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'run' in params:
            query_params.append(('run', params['run']))  # noqa: E501
        if 'ls_number' in params:
            query_params.append(('ls_number', params['ls_number']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'oms_zerobias_rate' in params:
            query_params.append(('oms_zerobias_rate', params['oms_zerobias_rate']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'ls_number' in params:
            form_params.append(('ls_number', params['ls_number']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'ls_number' in params:
            form_params.append(('ls_number', params['ls_number']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisections/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Lumisection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_lumisection(self, id, **kwargs):  # noqa: E501
        """update_lumisection  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_lumisection(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection. (required)
        :param str run2:
        :param int ls_number2:
        :param datetime _date2:
        :param str run2:
        :param int ls_number2:
        :param datetime _date2:
        :param str run: run
        :param str ls_number: ls_number
        :param str _date: date
        :param str oms_zerobias_rate: oms_zerobias_rate
        :return: Lumisection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_lumisection_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_lumisection_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_lumisection_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_lumisection  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_lumisection_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection. (required)
        :param str run2:
        :param int ls_number2:
        :param datetime _date2:
        :param str run2:
        :param int ls_number2:
        :param datetime _date2:
        :param str run: run
        :param str ls_number: ls_number
        :param str _date: date
        :param str oms_zerobias_rate: oms_zerobias_rate
        :return: Lumisection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'run2', 'ls_number2', '_date2', 'run2', 'ls_number2', '_date2', 'run', 'ls_number', '_date', 'oms_zerobias_rate']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_lumisection" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_lumisection`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'run' in params:
            query_params.append(('run', params['run']))  # noqa: E501
        if 'ls_number' in params:
            query_params.append(('ls_number', params['ls_number']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'oms_zerobias_rate' in params:
            query_params.append(('oms_zerobias_rate', params['oms_zerobias_rate']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'ls_number' in params:
            form_params.append(('ls_number', params['ls_number']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'ls_number' in params:
            form_params.append(('ls_number', params['ls_number']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisections/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Lumisection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_lumisection_certification(self, id, **kwargs):  # noqa: E501
        """update_lumisection_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_lumisection_certification(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection certification. (required)
        :param LumisectionCertification body:
        :param str lumisection: lumisection
        :param str _date: date
        :param str rr_is_golden_json: rr_is_golden_json
        :param str rr_is_pixel_good: rr_is_pixel_good
        :param str rr_is_strip_good: rr_is_strip_good
        :param str rr_is_ecal_good: rr_is_ecal_good
        :param str rr_is_hcal_good: rr_is_hcal_good
        :param str rr_is_dt_good: rr_is_dt_good
        :param str rr_is_csc_good: rr_is_csc_good
        :param str rr_is_tracking_good: rr_is_tracking_good
        :param str rr_is_muon_good: rr_is_muon_good
        :param str rr_is_egamma_good: rr_is_egamma_good
        :param str rr_is_tau_good: rr_is_tau_good
        :param str rr_is_jetmet_good: rr_is_jetmet_good
        :param str rr_is_btag_good: rr_is_btag_good
        :param str run: run
        :return: LumisectionCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_lumisection_certification_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_lumisection_certification_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_lumisection_certification_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_lumisection_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_lumisection_certification_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection certification. (required)
        :param LumisectionCertification body:
        :param str lumisection: lumisection
        :param str _date: date
        :param str rr_is_golden_json: rr_is_golden_json
        :param str rr_is_pixel_good: rr_is_pixel_good
        :param str rr_is_strip_good: rr_is_strip_good
        :param str rr_is_ecal_good: rr_is_ecal_good
        :param str rr_is_hcal_good: rr_is_hcal_good
        :param str rr_is_dt_good: rr_is_dt_good
        :param str rr_is_csc_good: rr_is_csc_good
        :param str rr_is_tracking_good: rr_is_tracking_good
        :param str rr_is_muon_good: rr_is_muon_good
        :param str rr_is_egamma_good: rr_is_egamma_good
        :param str rr_is_tau_good: rr_is_tau_good
        :param str rr_is_jetmet_good: rr_is_jetmet_good
        :param str rr_is_btag_good: rr_is_btag_good
        :param str run: run
        :return: LumisectionCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'lumisection', '_date', 'rr_is_golden_json', 'rr_is_pixel_good', 'rr_is_strip_good', 'rr_is_ecal_good', 'rr_is_hcal_good', 'rr_is_dt_good', 'rr_is_csc_good', 'rr_is_tracking_good', 'rr_is_muon_good', 'rr_is_egamma_good', 'rr_is_tau_good', 'rr_is_jetmet_good', 'rr_is_btag_good', 'run']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_lumisection_certification" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_lumisection_certification`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lumisection' in params:
            query_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_golden_json' in params:
            query_params.append(('rr_is_golden_json', params['rr_is_golden_json']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            query_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            query_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            query_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            query_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            query_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            query_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            query_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            query_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            query_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            query_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            query_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            query_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'run' in params:
            query_params.append(('run', params['run']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_golden_json' in params:
            form_params.append(('rr_is_golden_json', params['rr_is_golden_json']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            form_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            form_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            form_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            form_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            form_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            form_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            form_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            form_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            form_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            form_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            form_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            form_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_golden_json' in params:
            form_params.append(('rr_is_golden_json', params['rr_is_golden_json']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            form_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            form_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            form_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            form_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            form_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            form_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            form_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            form_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            form_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            form_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            form_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            form_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisection_certifications/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LumisectionCertification',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_lumisection_certification(self, id, **kwargs):  # noqa: E501
        """update_lumisection_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_lumisection_certification(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection certification. (required)
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param datetime _date2:
        :param bool rr_is_golden_json2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param datetime _date2:
        :param bool rr_is_golden_json2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param str lumisection: lumisection
        :param str _date: date
        :param str rr_is_golden_json: rr_is_golden_json
        :param str rr_is_pixel_good: rr_is_pixel_good
        :param str rr_is_strip_good: rr_is_strip_good
        :param str rr_is_ecal_good: rr_is_ecal_good
        :param str rr_is_hcal_good: rr_is_hcal_good
        :param str rr_is_dt_good: rr_is_dt_good
        :param str rr_is_csc_good: rr_is_csc_good
        :param str rr_is_tracking_good: rr_is_tracking_good
        :param str rr_is_muon_good: rr_is_muon_good
        :param str rr_is_egamma_good: rr_is_egamma_good
        :param str rr_is_tau_good: rr_is_tau_good
        :param str rr_is_jetmet_good: rr_is_jetmet_good
        :param str rr_is_btag_good: rr_is_btag_good
        :param str run: run
        :return: LumisectionCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_lumisection_certification_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_lumisection_certification_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_lumisection_certification_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_lumisection_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_lumisection_certification_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection certification. (required)
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param datetime _date2:
        :param bool rr_is_golden_json2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param datetime _date2:
        :param bool rr_is_golden_json2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param str lumisection: lumisection
        :param str _date: date
        :param str rr_is_golden_json: rr_is_golden_json
        :param str rr_is_pixel_good: rr_is_pixel_good
        :param str rr_is_strip_good: rr_is_strip_good
        :param str rr_is_ecal_good: rr_is_ecal_good
        :param str rr_is_hcal_good: rr_is_hcal_good
        :param str rr_is_dt_good: rr_is_dt_good
        :param str rr_is_csc_good: rr_is_csc_good
        :param str rr_is_tracking_good: rr_is_tracking_good
        :param str rr_is_muon_good: rr_is_muon_good
        :param str rr_is_egamma_good: rr_is_egamma_good
        :param str rr_is_tau_good: rr_is_tau_good
        :param str rr_is_jetmet_good: rr_is_jetmet_good
        :param str rr_is_btag_good: rr_is_btag_good
        :param str run: run
        :return: LumisectionCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'id2', 'run2', 'lumisection2', '_date2', 'rr_is_golden_json2', 'rr_is_pixel_good2', 'rr_is_strip_good2', 'rr_is_ecal_good2', 'rr_is_hcal_good2', 'rr_is_dt_good2', 'rr_is_csc_good2', 'rr_is_tracking_good2', 'rr_is_muon_good2', 'rr_is_egamma_good2', 'rr_is_tau_good2', 'rr_is_jetmet_good2', 'rr_is_btag_good2', 'id2', 'run2', 'lumisection2', '_date2', 'rr_is_golden_json2', 'rr_is_pixel_good2', 'rr_is_strip_good2', 'rr_is_ecal_good2', 'rr_is_hcal_good2', 'rr_is_dt_good2', 'rr_is_csc_good2', 'rr_is_tracking_good2', 'rr_is_muon_good2', 'rr_is_egamma_good2', 'rr_is_tau_good2', 'rr_is_jetmet_good2', 'rr_is_btag_good2', 'lumisection', '_date', 'rr_is_golden_json', 'rr_is_pixel_good', 'rr_is_strip_good', 'rr_is_ecal_good', 'rr_is_hcal_good', 'rr_is_dt_good', 'rr_is_csc_good', 'rr_is_tracking_good', 'rr_is_muon_good', 'rr_is_egamma_good', 'rr_is_tau_good', 'rr_is_jetmet_good', 'rr_is_btag_good', 'run']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_lumisection_certification" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_lumisection_certification`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lumisection' in params:
            query_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_golden_json' in params:
            query_params.append(('rr_is_golden_json', params['rr_is_golden_json']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            query_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            query_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            query_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            query_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            query_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            query_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            query_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            query_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            query_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            query_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            query_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            query_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'run' in params:
            query_params.append(('run', params['run']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_golden_json' in params:
            form_params.append(('rr_is_golden_json', params['rr_is_golden_json']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            form_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            form_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            form_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            form_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            form_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            form_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            form_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            form_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            form_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            form_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            form_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            form_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_golden_json' in params:
            form_params.append(('rr_is_golden_json', params['rr_is_golden_json']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            form_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            form_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            form_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            form_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            form_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            form_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            form_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            form_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            form_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            form_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            form_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            form_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisection_certifications/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LumisectionCertification',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_lumisection_certification(self, id, **kwargs):  # noqa: E501
        """update_lumisection_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_lumisection_certification(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection certification. (required)
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param datetime _date2:
        :param bool rr_is_golden_json2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param datetime _date2:
        :param bool rr_is_golden_json2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param str lumisection: lumisection
        :param str _date: date
        :param str rr_is_golden_json: rr_is_golden_json
        :param str rr_is_pixel_good: rr_is_pixel_good
        :param str rr_is_strip_good: rr_is_strip_good
        :param str rr_is_ecal_good: rr_is_ecal_good
        :param str rr_is_hcal_good: rr_is_hcal_good
        :param str rr_is_dt_good: rr_is_dt_good
        :param str rr_is_csc_good: rr_is_csc_good
        :param str rr_is_tracking_good: rr_is_tracking_good
        :param str rr_is_muon_good: rr_is_muon_good
        :param str rr_is_egamma_good: rr_is_egamma_good
        :param str rr_is_tau_good: rr_is_tau_good
        :param str rr_is_jetmet_good: rr_is_jetmet_good
        :param str rr_is_btag_good: rr_is_btag_good
        :param str run: run
        :return: LumisectionCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_lumisection_certification_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_lumisection_certification_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_lumisection_certification_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_lumisection_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_lumisection_certification_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection certification. (required)
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param datetime _date2:
        :param bool rr_is_golden_json2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param datetime _date2:
        :param bool rr_is_golden_json2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param str lumisection: lumisection
        :param str _date: date
        :param str rr_is_golden_json: rr_is_golden_json
        :param str rr_is_pixel_good: rr_is_pixel_good
        :param str rr_is_strip_good: rr_is_strip_good
        :param str rr_is_ecal_good: rr_is_ecal_good
        :param str rr_is_hcal_good: rr_is_hcal_good
        :param str rr_is_dt_good: rr_is_dt_good
        :param str rr_is_csc_good: rr_is_csc_good
        :param str rr_is_tracking_good: rr_is_tracking_good
        :param str rr_is_muon_good: rr_is_muon_good
        :param str rr_is_egamma_good: rr_is_egamma_good
        :param str rr_is_tau_good: rr_is_tau_good
        :param str rr_is_jetmet_good: rr_is_jetmet_good
        :param str rr_is_btag_good: rr_is_btag_good
        :param str run: run
        :return: LumisectionCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'id2', 'run2', 'lumisection2', '_date2', 'rr_is_golden_json2', 'rr_is_pixel_good2', 'rr_is_strip_good2', 'rr_is_ecal_good2', 'rr_is_hcal_good2', 'rr_is_dt_good2', 'rr_is_csc_good2', 'rr_is_tracking_good2', 'rr_is_muon_good2', 'rr_is_egamma_good2', 'rr_is_tau_good2', 'rr_is_jetmet_good2', 'rr_is_btag_good2', 'id2', 'run2', 'lumisection2', '_date2', 'rr_is_golden_json2', 'rr_is_pixel_good2', 'rr_is_strip_good2', 'rr_is_ecal_good2', 'rr_is_hcal_good2', 'rr_is_dt_good2', 'rr_is_csc_good2', 'rr_is_tracking_good2', 'rr_is_muon_good2', 'rr_is_egamma_good2', 'rr_is_tau_good2', 'rr_is_jetmet_good2', 'rr_is_btag_good2', 'lumisection', '_date', 'rr_is_golden_json', 'rr_is_pixel_good', 'rr_is_strip_good', 'rr_is_ecal_good', 'rr_is_hcal_good', 'rr_is_dt_good', 'rr_is_csc_good', 'rr_is_tracking_good', 'rr_is_muon_good', 'rr_is_egamma_good', 'rr_is_tau_good', 'rr_is_jetmet_good', 'rr_is_btag_good', 'run']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_lumisection_certification" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_lumisection_certification`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lumisection' in params:
            query_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_golden_json' in params:
            query_params.append(('rr_is_golden_json', params['rr_is_golden_json']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            query_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            query_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            query_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            query_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            query_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            query_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            query_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            query_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            query_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            query_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            query_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            query_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'run' in params:
            query_params.append(('run', params['run']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_golden_json' in params:
            form_params.append(('rr_is_golden_json', params['rr_is_golden_json']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            form_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            form_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            form_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            form_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            form_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            form_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            form_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            form_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            form_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            form_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            form_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            form_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_golden_json' in params:
            form_params.append(('rr_is_golden_json', params['rr_is_golden_json']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            form_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            form_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            form_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            form_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            form_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            form_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            form_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            form_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            form_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            form_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            form_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            form_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisection_certifications/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LumisectionCertification',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_lumisection_histogram1_d(self, id, **kwargs):  # noqa: E501
        """update_lumisection_histogram1_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_lumisection_histogram1_d(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection histogram1d. (required)
        :param LumisectionHistogram1D body:
        :param str lumisection__run__run_number: lumisection__run__run_number
        :param str lumisection__run__run_number__gte: lumisection__run__run_number__gte
        :param str lumisection__run__run_number__lte: lumisection__run__run_number__lte
        :param str lumisection__ls_number: lumisection__ls_number
        :param str lumisection__ls_number__gte: lumisection__ls_number__gte
        :param str lumisection__ls_number__lte: lumisection__ls_number__lte
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str lumisection__ls_number__in: lumisection__ls_number__in
        :param str lumisection__run__run_number__in: lumisection__run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: LumisectionHistogram1D
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_lumisection_histogram1_d_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_lumisection_histogram1_d_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_lumisection_histogram1_d_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_lumisection_histogram1_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_lumisection_histogram1_d_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection histogram1d. (required)
        :param LumisectionHistogram1D body:
        :param str lumisection__run__run_number: lumisection__run__run_number
        :param str lumisection__run__run_number__gte: lumisection__run__run_number__gte
        :param str lumisection__run__run_number__lte: lumisection__run__run_number__lte
        :param str lumisection__ls_number: lumisection__ls_number
        :param str lumisection__ls_number__gte: lumisection__ls_number__gte
        :param str lumisection__ls_number__lte: lumisection__ls_number__lte
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str lumisection__ls_number__in: lumisection__ls_number__in
        :param str lumisection__run__run_number__in: lumisection__run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: LumisectionHistogram1D
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'lumisection__run__run_number', 'lumisection__run__run_number__gte', 'lumisection__run__run_number__lte', 'lumisection__ls_number', 'lumisection__ls_number__gte', 'lumisection__ls_number__lte', 'entries__gte', 'entries__lte', 'source_data_file', 'title', 'lumisection__ls_number__in', 'lumisection__run__run_number__in', 'source_data_file__filepath__contains']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_lumisection_histogram1_d" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_lumisection_histogram1_d`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lumisection__run__run_number' in params:
            query_params.append(('lumisection__run__run_number', params['lumisection__run__run_number']))  # noqa: E501
        if 'lumisection__run__run_number__gte' in params:
            query_params.append(('lumisection__run__run_number__gte', params['lumisection__run__run_number__gte']))  # noqa: E501
        if 'lumisection__run__run_number__lte' in params:
            query_params.append(('lumisection__run__run_number__lte', params['lumisection__run__run_number__lte']))  # noqa: E501
        if 'lumisection__ls_number' in params:
            query_params.append(('lumisection__ls_number', params['lumisection__ls_number']))  # noqa: E501
        if 'lumisection__ls_number__gte' in params:
            query_params.append(('lumisection__ls_number__gte', params['lumisection__ls_number__gte']))  # noqa: E501
        if 'lumisection__ls_number__lte' in params:
            query_params.append(('lumisection__ls_number__lte', params['lumisection__ls_number__lte']))  # noqa: E501
        if 'entries__gte' in params:
            query_params.append(('entries__gte', params['entries__gte']))  # noqa: E501
        if 'entries__lte' in params:
            query_params.append(('entries__lte', params['entries__lte']))  # noqa: E501
        if 'source_data_file' in params:
            query_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'title' in params:
            query_params.append(('title', params['title']))  # noqa: E501
        if 'lumisection__ls_number__in' in params:
            query_params.append(('lumisection__ls_number__in', params['lumisection__ls_number__in']))  # noqa: E501
        if 'lumisection__run__run_number__in' in params:
            query_params.append(('lumisection__run__run_number__in', params['lumisection__run__run_number__in']))  # noqa: E501
        if 'source_data_file__filepath__contains' in params:
            query_params.append(('source_data_file__filepath__contains', params['source_data_file__filepath__contains']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501
        if 'x_min' in params:
            form_params.append(('x_min', params['x_min']))  # noqa: E501
        if 'x_max' in params:
            form_params.append(('x_max', params['x_max']))  # noqa: E501
        if 'x_bin' in params:
            form_params.append(('x_bin', params['x_bin']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501
        if 'x_min' in params:
            form_params.append(('x_min', params['x_min']))  # noqa: E501
        if 'x_max' in params:
            form_params.append(('x_max', params['x_max']))  # noqa: E501
        if 'x_bin' in params:
            form_params.append(('x_bin', params['x_bin']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisection_histograms_1d/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LumisectionHistogram1D',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_lumisection_histogram1_d(self, id, **kwargs):  # noqa: E501
        """update_lumisection_histogram1_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_lumisection_histogram1_d(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection histogram1d. (required)
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param str title2:
        :param int entries2:
        :param list[float] data2:
        :param float x_min2:
        :param float x_max2:
        :param int x_bin2:
        :param int source_data_file2:
        :param int id2:
        :param int run:
        :param int lumisection:
        :param str title2:
        :param int entries:
        :param list[float] data:
        :param float x_min:
        :param float x_max:
        :param int x_bin:
        :param int source_data_file2:
        :param str lumisection__run__run_number: lumisection__run__run_number
        :param str lumisection__run__run_number__gte: lumisection__run__run_number__gte
        :param str lumisection__run__run_number__lte: lumisection__run__run_number__lte
        :param str lumisection__ls_number: lumisection__ls_number
        :param str lumisection__ls_number__gte: lumisection__ls_number__gte
        :param str lumisection__ls_number__lte: lumisection__ls_number__lte
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str lumisection__ls_number__in: lumisection__ls_number__in
        :param str lumisection__run__run_number__in: lumisection__run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: LumisectionHistogram1D
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_lumisection_histogram1_d_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_lumisection_histogram1_d_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_lumisection_histogram1_d_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_lumisection_histogram1_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_lumisection_histogram1_d_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection histogram1d. (required)
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param str title2:
        :param int entries2:
        :param list[float] data2:
        :param float x_min2:
        :param float x_max2:
        :param int x_bin2:
        :param int source_data_file2:
        :param int id2:
        :param int run:
        :param int lumisection:
        :param str title2:
        :param int entries:
        :param list[float] data:
        :param float x_min:
        :param float x_max:
        :param int x_bin:
        :param int source_data_file2:
        :param str lumisection__run__run_number: lumisection__run__run_number
        :param str lumisection__run__run_number__gte: lumisection__run__run_number__gte
        :param str lumisection__run__run_number__lte: lumisection__run__run_number__lte
        :param str lumisection__ls_number: lumisection__ls_number
        :param str lumisection__ls_number__gte: lumisection__ls_number__gte
        :param str lumisection__ls_number__lte: lumisection__ls_number__lte
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str lumisection__ls_number__in: lumisection__ls_number__in
        :param str lumisection__run__run_number__in: lumisection__run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: LumisectionHistogram1D
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'id2', 'run2', 'lumisection2', 'title2', 'entries2', 'data2', 'x_min2', 'x_max2', 'x_bin2', 'source_data_file2', 'id2', 'run', 'lumisection', 'title2', 'entries', 'data', 'x_min', 'x_max', 'x_bin', 'source_data_file2', 'lumisection__run__run_number', 'lumisection__run__run_number__gte', 'lumisection__run__run_number__lte', 'lumisection__ls_number', 'lumisection__ls_number__gte', 'lumisection__ls_number__lte', 'entries__gte', 'entries__lte', 'source_data_file', 'title', 'lumisection__ls_number__in', 'lumisection__run__run_number__in', 'source_data_file__filepath__contains']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_lumisection_histogram1_d" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_lumisection_histogram1_d`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lumisection__run__run_number' in params:
            query_params.append(('lumisection__run__run_number', params['lumisection__run__run_number']))  # noqa: E501
        if 'lumisection__run__run_number__gte' in params:
            query_params.append(('lumisection__run__run_number__gte', params['lumisection__run__run_number__gte']))  # noqa: E501
        if 'lumisection__run__run_number__lte' in params:
            query_params.append(('lumisection__run__run_number__lte', params['lumisection__run__run_number__lte']))  # noqa: E501
        if 'lumisection__ls_number' in params:
            query_params.append(('lumisection__ls_number', params['lumisection__ls_number']))  # noqa: E501
        if 'lumisection__ls_number__gte' in params:
            query_params.append(('lumisection__ls_number__gte', params['lumisection__ls_number__gte']))  # noqa: E501
        if 'lumisection__ls_number__lte' in params:
            query_params.append(('lumisection__ls_number__lte', params['lumisection__ls_number__lte']))  # noqa: E501
        if 'entries__gte' in params:
            query_params.append(('entries__gte', params['entries__gte']))  # noqa: E501
        if 'entries__lte' in params:
            query_params.append(('entries__lte', params['entries__lte']))  # noqa: E501
        if 'source_data_file' in params:
            query_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'title' in params:
            query_params.append(('title', params['title']))  # noqa: E501
        if 'lumisection__ls_number__in' in params:
            query_params.append(('lumisection__ls_number__in', params['lumisection__ls_number__in']))  # noqa: E501
        if 'lumisection__run__run_number__in' in params:
            query_params.append(('lumisection__run__run_number__in', params['lumisection__run__run_number__in']))  # noqa: E501
        if 'source_data_file__filepath__contains' in params:
            query_params.append(('source_data_file__filepath__contains', params['source_data_file__filepath__contains']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501
        if 'x_min' in params:
            form_params.append(('x_min', params['x_min']))  # noqa: E501
        if 'x_max' in params:
            form_params.append(('x_max', params['x_max']))  # noqa: E501
        if 'x_bin' in params:
            form_params.append(('x_bin', params['x_bin']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501
        if 'x_min' in params:
            form_params.append(('x_min', params['x_min']))  # noqa: E501
        if 'x_max' in params:
            form_params.append(('x_max', params['x_max']))  # noqa: E501
        if 'x_bin' in params:
            form_params.append(('x_bin', params['x_bin']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisection_histograms_1d/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LumisectionHistogram1D',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_lumisection_histogram1_d(self, id, **kwargs):  # noqa: E501
        """update_lumisection_histogram1_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_lumisection_histogram1_d(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection histogram1d. (required)
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param str title2:
        :param int entries2:
        :param list[float] data2:
        :param float x_min2:
        :param float x_max2:
        :param int x_bin2:
        :param int source_data_file2:
        :param int id2:
        :param int run:
        :param int lumisection:
        :param str title2:
        :param int entries:
        :param list[float] data:
        :param float x_min:
        :param float x_max:
        :param int x_bin:
        :param int source_data_file2:
        :param str lumisection__run__run_number: lumisection__run__run_number
        :param str lumisection__run__run_number__gte: lumisection__run__run_number__gte
        :param str lumisection__run__run_number__lte: lumisection__run__run_number__lte
        :param str lumisection__ls_number: lumisection__ls_number
        :param str lumisection__ls_number__gte: lumisection__ls_number__gte
        :param str lumisection__ls_number__lte: lumisection__ls_number__lte
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str lumisection__ls_number__in: lumisection__ls_number__in
        :param str lumisection__run__run_number__in: lumisection__run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: LumisectionHistogram1D
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_lumisection_histogram1_d_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_lumisection_histogram1_d_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_lumisection_histogram1_d_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_lumisection_histogram1_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_lumisection_histogram1_d_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection histogram1d. (required)
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param str title2:
        :param int entries2:
        :param list[float] data2:
        :param float x_min2:
        :param float x_max2:
        :param int x_bin2:
        :param int source_data_file2:
        :param int id2:
        :param int run:
        :param int lumisection:
        :param str title2:
        :param int entries:
        :param list[float] data:
        :param float x_min:
        :param float x_max:
        :param int x_bin:
        :param int source_data_file2:
        :param str lumisection__run__run_number: lumisection__run__run_number
        :param str lumisection__run__run_number__gte: lumisection__run__run_number__gte
        :param str lumisection__run__run_number__lte: lumisection__run__run_number__lte
        :param str lumisection__ls_number: lumisection__ls_number
        :param str lumisection__ls_number__gte: lumisection__ls_number__gte
        :param str lumisection__ls_number__lte: lumisection__ls_number__lte
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str lumisection__ls_number__in: lumisection__ls_number__in
        :param str lumisection__run__run_number__in: lumisection__run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: LumisectionHistogram1D
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'id2', 'run2', 'lumisection2', 'title2', 'entries2', 'data2', 'x_min2', 'x_max2', 'x_bin2', 'source_data_file2', 'id2', 'run', 'lumisection', 'title2', 'entries', 'data', 'x_min', 'x_max', 'x_bin', 'source_data_file2', 'lumisection__run__run_number', 'lumisection__run__run_number__gte', 'lumisection__run__run_number__lte', 'lumisection__ls_number', 'lumisection__ls_number__gte', 'lumisection__ls_number__lte', 'entries__gte', 'entries__lte', 'source_data_file', 'title', 'lumisection__ls_number__in', 'lumisection__run__run_number__in', 'source_data_file__filepath__contains']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_lumisection_histogram1_d" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_lumisection_histogram1_d`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lumisection__run__run_number' in params:
            query_params.append(('lumisection__run__run_number', params['lumisection__run__run_number']))  # noqa: E501
        if 'lumisection__run__run_number__gte' in params:
            query_params.append(('lumisection__run__run_number__gte', params['lumisection__run__run_number__gte']))  # noqa: E501
        if 'lumisection__run__run_number__lte' in params:
            query_params.append(('lumisection__run__run_number__lte', params['lumisection__run__run_number__lte']))  # noqa: E501
        if 'lumisection__ls_number' in params:
            query_params.append(('lumisection__ls_number', params['lumisection__ls_number']))  # noqa: E501
        if 'lumisection__ls_number__gte' in params:
            query_params.append(('lumisection__ls_number__gte', params['lumisection__ls_number__gte']))  # noqa: E501
        if 'lumisection__ls_number__lte' in params:
            query_params.append(('lumisection__ls_number__lte', params['lumisection__ls_number__lte']))  # noqa: E501
        if 'entries__gte' in params:
            query_params.append(('entries__gte', params['entries__gte']))  # noqa: E501
        if 'entries__lte' in params:
            query_params.append(('entries__lte', params['entries__lte']))  # noqa: E501
        if 'source_data_file' in params:
            query_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'title' in params:
            query_params.append(('title', params['title']))  # noqa: E501
        if 'lumisection__ls_number__in' in params:
            query_params.append(('lumisection__ls_number__in', params['lumisection__ls_number__in']))  # noqa: E501
        if 'lumisection__run__run_number__in' in params:
            query_params.append(('lumisection__run__run_number__in', params['lumisection__run__run_number__in']))  # noqa: E501
        if 'source_data_file__filepath__contains' in params:
            query_params.append(('source_data_file__filepath__contains', params['source_data_file__filepath__contains']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501
        if 'x_min' in params:
            form_params.append(('x_min', params['x_min']))  # noqa: E501
        if 'x_max' in params:
            form_params.append(('x_max', params['x_max']))  # noqa: E501
        if 'x_bin' in params:
            form_params.append(('x_bin', params['x_bin']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501
        if 'x_min' in params:
            form_params.append(('x_min', params['x_min']))  # noqa: E501
        if 'x_max' in params:
            form_params.append(('x_max', params['x_max']))  # noqa: E501
        if 'x_bin' in params:
            form_params.append(('x_bin', params['x_bin']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisection_histograms_1d/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LumisectionHistogram1D',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_lumisection_histogram2_d(self, id, **kwargs):  # noqa: E501
        """update_lumisection_histogram2_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_lumisection_histogram2_d(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection histogram2d. (required)
        :param LumisectionHistogram2D body:
        :param str lumisection__run__run_number: lumisection__run__run_number
        :param str lumisection__run__run_number__gte: lumisection__run__run_number__gte
        :param str lumisection__run__run_number__lte: lumisection__run__run_number__lte
        :param str lumisection__ls_number: lumisection__ls_number
        :param str lumisection__ls_number__gte: lumisection__ls_number__gte
        :param str lumisection__ls_number__lte: lumisection__ls_number__lte
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str lumisection__ls_number__in: lumisection__ls_number__in
        :param str lumisection__run__run_number__in: lumisection__run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: LumisectionHistogram2D
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_lumisection_histogram2_d_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_lumisection_histogram2_d_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_lumisection_histogram2_d_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_lumisection_histogram2_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_lumisection_histogram2_d_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection histogram2d. (required)
        :param LumisectionHistogram2D body:
        :param str lumisection__run__run_number: lumisection__run__run_number
        :param str lumisection__run__run_number__gte: lumisection__run__run_number__gte
        :param str lumisection__run__run_number__lte: lumisection__run__run_number__lte
        :param str lumisection__ls_number: lumisection__ls_number
        :param str lumisection__ls_number__gte: lumisection__ls_number__gte
        :param str lumisection__ls_number__lte: lumisection__ls_number__lte
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str lumisection__ls_number__in: lumisection__ls_number__in
        :param str lumisection__run__run_number__in: lumisection__run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: LumisectionHistogram2D
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'lumisection__run__run_number', 'lumisection__run__run_number__gte', 'lumisection__run__run_number__lte', 'lumisection__ls_number', 'lumisection__ls_number__gte', 'lumisection__ls_number__lte', 'entries__gte', 'entries__lte', 'source_data_file', 'title', 'lumisection__ls_number__in', 'lumisection__run__run_number__in', 'source_data_file__filepath__contains']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_lumisection_histogram2_d" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_lumisection_histogram2_d`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lumisection__run__run_number' in params:
            query_params.append(('lumisection__run__run_number', params['lumisection__run__run_number']))  # noqa: E501
        if 'lumisection__run__run_number__gte' in params:
            query_params.append(('lumisection__run__run_number__gte', params['lumisection__run__run_number__gte']))  # noqa: E501
        if 'lumisection__run__run_number__lte' in params:
            query_params.append(('lumisection__run__run_number__lte', params['lumisection__run__run_number__lte']))  # noqa: E501
        if 'lumisection__ls_number' in params:
            query_params.append(('lumisection__ls_number', params['lumisection__ls_number']))  # noqa: E501
        if 'lumisection__ls_number__gte' in params:
            query_params.append(('lumisection__ls_number__gte', params['lumisection__ls_number__gte']))  # noqa: E501
        if 'lumisection__ls_number__lte' in params:
            query_params.append(('lumisection__ls_number__lte', params['lumisection__ls_number__lte']))  # noqa: E501
        if 'entries__gte' in params:
            query_params.append(('entries__gte', params['entries__gte']))  # noqa: E501
        if 'entries__lte' in params:
            query_params.append(('entries__lte', params['entries__lte']))  # noqa: E501
        if 'source_data_file' in params:
            query_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'title' in params:
            query_params.append(('title', params['title']))  # noqa: E501
        if 'lumisection__ls_number__in' in params:
            query_params.append(('lumisection__ls_number__in', params['lumisection__ls_number__in']))  # noqa: E501
        if 'lumisection__run__run_number__in' in params:
            query_params.append(('lumisection__run__run_number__in', params['lumisection__run__run_number__in']))  # noqa: E501
        if 'source_data_file__filepath__contains' in params:
            query_params.append(('source_data_file__filepath__contains', params['source_data_file__filepath__contains']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501
        if 'x_min' in params:
            form_params.append(('x_min', params['x_min']))  # noqa: E501
        if 'x_max' in params:
            form_params.append(('x_max', params['x_max']))  # noqa: E501
        if 'x_bin' in params:
            form_params.append(('x_bin', params['x_bin']))  # noqa: E501
        if 'y_max' in params:
            form_params.append(('y_max', params['y_max']))  # noqa: E501
        if 'y_min' in params:
            form_params.append(('y_min', params['y_min']))  # noqa: E501
        if 'y_bin' in params:
            form_params.append(('y_bin', params['y_bin']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501
        if 'x_min' in params:
            form_params.append(('x_min', params['x_min']))  # noqa: E501
        if 'x_max' in params:
            form_params.append(('x_max', params['x_max']))  # noqa: E501
        if 'x_bin' in params:
            form_params.append(('x_bin', params['x_bin']))  # noqa: E501
        if 'y_max' in params:
            form_params.append(('y_max', params['y_max']))  # noqa: E501
        if 'y_min' in params:
            form_params.append(('y_min', params['y_min']))  # noqa: E501
        if 'y_bin' in params:
            form_params.append(('y_bin', params['y_bin']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisection_histograms_2d/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LumisectionHistogram2D',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_lumisection_histogram2_d(self, id, **kwargs):  # noqa: E501
        """update_lumisection_histogram2_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_lumisection_histogram2_d(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection histogram2d. (required)
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param str title2:
        :param int entries2:
        :param list[list[float]] data2:
        :param float x_min2:
        :param float x_max2:
        :param int x_bin2:
        :param float y_max2:
        :param float y_min2:
        :param int y_bin2:
        :param int source_data_file2:
        :param int id2:
        :param int run:
        :param int lumisection:
        :param str title2:
        :param int entries:
        :param list[list[float]] data:
        :param float x_min:
        :param float x_max:
        :param int x_bin:
        :param float y_max:
        :param float y_min:
        :param int y_bin:
        :param int source_data_file2:
        :param str lumisection__run__run_number: lumisection__run__run_number
        :param str lumisection__run__run_number__gte: lumisection__run__run_number__gte
        :param str lumisection__run__run_number__lte: lumisection__run__run_number__lte
        :param str lumisection__ls_number: lumisection__ls_number
        :param str lumisection__ls_number__gte: lumisection__ls_number__gte
        :param str lumisection__ls_number__lte: lumisection__ls_number__lte
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str lumisection__ls_number__in: lumisection__ls_number__in
        :param str lumisection__run__run_number__in: lumisection__run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: LumisectionHistogram2D
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_lumisection_histogram2_d_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_lumisection_histogram2_d_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_lumisection_histogram2_d_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_lumisection_histogram2_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_lumisection_histogram2_d_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection histogram2d. (required)
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param str title2:
        :param int entries2:
        :param list[list[float]] data2:
        :param float x_min2:
        :param float x_max2:
        :param int x_bin2:
        :param float y_max2:
        :param float y_min2:
        :param int y_bin2:
        :param int source_data_file2:
        :param int id2:
        :param int run:
        :param int lumisection:
        :param str title2:
        :param int entries:
        :param list[list[float]] data:
        :param float x_min:
        :param float x_max:
        :param int x_bin:
        :param float y_max:
        :param float y_min:
        :param int y_bin:
        :param int source_data_file2:
        :param str lumisection__run__run_number: lumisection__run__run_number
        :param str lumisection__run__run_number__gte: lumisection__run__run_number__gte
        :param str lumisection__run__run_number__lte: lumisection__run__run_number__lte
        :param str lumisection__ls_number: lumisection__ls_number
        :param str lumisection__ls_number__gte: lumisection__ls_number__gte
        :param str lumisection__ls_number__lte: lumisection__ls_number__lte
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str lumisection__ls_number__in: lumisection__ls_number__in
        :param str lumisection__run__run_number__in: lumisection__run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: LumisectionHistogram2D
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'id2', 'run2', 'lumisection2', 'title2', 'entries2', 'data2', 'x_min2', 'x_max2', 'x_bin2', 'y_max2', 'y_min2', 'y_bin2', 'source_data_file2', 'id2', 'run', 'lumisection', 'title2', 'entries', 'data', 'x_min', 'x_max', 'x_bin', 'y_max', 'y_min', 'y_bin', 'source_data_file2', 'lumisection__run__run_number', 'lumisection__run__run_number__gte', 'lumisection__run__run_number__lte', 'lumisection__ls_number', 'lumisection__ls_number__gte', 'lumisection__ls_number__lte', 'entries__gte', 'entries__lte', 'source_data_file', 'title', 'lumisection__ls_number__in', 'lumisection__run__run_number__in', 'source_data_file__filepath__contains']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_lumisection_histogram2_d" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_lumisection_histogram2_d`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lumisection__run__run_number' in params:
            query_params.append(('lumisection__run__run_number', params['lumisection__run__run_number']))  # noqa: E501
        if 'lumisection__run__run_number__gte' in params:
            query_params.append(('lumisection__run__run_number__gte', params['lumisection__run__run_number__gte']))  # noqa: E501
        if 'lumisection__run__run_number__lte' in params:
            query_params.append(('lumisection__run__run_number__lte', params['lumisection__run__run_number__lte']))  # noqa: E501
        if 'lumisection__ls_number' in params:
            query_params.append(('lumisection__ls_number', params['lumisection__ls_number']))  # noqa: E501
        if 'lumisection__ls_number__gte' in params:
            query_params.append(('lumisection__ls_number__gte', params['lumisection__ls_number__gte']))  # noqa: E501
        if 'lumisection__ls_number__lte' in params:
            query_params.append(('lumisection__ls_number__lte', params['lumisection__ls_number__lte']))  # noqa: E501
        if 'entries__gte' in params:
            query_params.append(('entries__gte', params['entries__gte']))  # noqa: E501
        if 'entries__lte' in params:
            query_params.append(('entries__lte', params['entries__lte']))  # noqa: E501
        if 'source_data_file' in params:
            query_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'title' in params:
            query_params.append(('title', params['title']))  # noqa: E501
        if 'lumisection__ls_number__in' in params:
            query_params.append(('lumisection__ls_number__in', params['lumisection__ls_number__in']))  # noqa: E501
        if 'lumisection__run__run_number__in' in params:
            query_params.append(('lumisection__run__run_number__in', params['lumisection__run__run_number__in']))  # noqa: E501
        if 'source_data_file__filepath__contains' in params:
            query_params.append(('source_data_file__filepath__contains', params['source_data_file__filepath__contains']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501
        if 'x_min' in params:
            form_params.append(('x_min', params['x_min']))  # noqa: E501
        if 'x_max' in params:
            form_params.append(('x_max', params['x_max']))  # noqa: E501
        if 'x_bin' in params:
            form_params.append(('x_bin', params['x_bin']))  # noqa: E501
        if 'y_max' in params:
            form_params.append(('y_max', params['y_max']))  # noqa: E501
        if 'y_min' in params:
            form_params.append(('y_min', params['y_min']))  # noqa: E501
        if 'y_bin' in params:
            form_params.append(('y_bin', params['y_bin']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501
        if 'x_min' in params:
            form_params.append(('x_min', params['x_min']))  # noqa: E501
        if 'x_max' in params:
            form_params.append(('x_max', params['x_max']))  # noqa: E501
        if 'x_bin' in params:
            form_params.append(('x_bin', params['x_bin']))  # noqa: E501
        if 'y_max' in params:
            form_params.append(('y_max', params['y_max']))  # noqa: E501
        if 'y_min' in params:
            form_params.append(('y_min', params['y_min']))  # noqa: E501
        if 'y_bin' in params:
            form_params.append(('y_bin', params['y_bin']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisection_histograms_2d/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LumisectionHistogram2D',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_lumisection_histogram2_d(self, id, **kwargs):  # noqa: E501
        """update_lumisection_histogram2_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_lumisection_histogram2_d(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection histogram2d. (required)
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param str title2:
        :param int entries2:
        :param list[list[float]] data2:
        :param float x_min2:
        :param float x_max2:
        :param int x_bin2:
        :param float y_max2:
        :param float y_min2:
        :param int y_bin2:
        :param int source_data_file2:
        :param int id2:
        :param int run:
        :param int lumisection:
        :param str title2:
        :param int entries:
        :param list[list[float]] data:
        :param float x_min:
        :param float x_max:
        :param int x_bin:
        :param float y_max:
        :param float y_min:
        :param int y_bin:
        :param int source_data_file2:
        :param str lumisection__run__run_number: lumisection__run__run_number
        :param str lumisection__run__run_number__gte: lumisection__run__run_number__gte
        :param str lumisection__run__run_number__lte: lumisection__run__run_number__lte
        :param str lumisection__ls_number: lumisection__ls_number
        :param str lumisection__ls_number__gte: lumisection__ls_number__gte
        :param str lumisection__ls_number__lte: lumisection__ls_number__lte
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str lumisection__ls_number__in: lumisection__ls_number__in
        :param str lumisection__run__run_number__in: lumisection__run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: LumisectionHistogram2D
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_lumisection_histogram2_d_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_lumisection_histogram2_d_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_lumisection_histogram2_d_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_lumisection_histogram2_d  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_lumisection_histogram2_d_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this lumisection histogram2d. (required)
        :param int id2:
        :param int run2:
        :param int lumisection2:
        :param str title2:
        :param int entries2:
        :param list[list[float]] data2:
        :param float x_min2:
        :param float x_max2:
        :param int x_bin2:
        :param float y_max2:
        :param float y_min2:
        :param int y_bin2:
        :param int source_data_file2:
        :param int id2:
        :param int run:
        :param int lumisection:
        :param str title2:
        :param int entries:
        :param list[list[float]] data:
        :param float x_min:
        :param float x_max:
        :param int x_bin:
        :param float y_max:
        :param float y_min:
        :param int y_bin:
        :param int source_data_file2:
        :param str lumisection__run__run_number: lumisection__run__run_number
        :param str lumisection__run__run_number__gte: lumisection__run__run_number__gte
        :param str lumisection__run__run_number__lte: lumisection__run__run_number__lte
        :param str lumisection__ls_number: lumisection__ls_number
        :param str lumisection__ls_number__gte: lumisection__ls_number__gte
        :param str lumisection__ls_number__lte: lumisection__ls_number__lte
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str lumisection__ls_number__in: lumisection__ls_number__in
        :param str lumisection__run__run_number__in: lumisection__run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: LumisectionHistogram2D
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'id2', 'run2', 'lumisection2', 'title2', 'entries2', 'data2', 'x_min2', 'x_max2', 'x_bin2', 'y_max2', 'y_min2', 'y_bin2', 'source_data_file2', 'id2', 'run', 'lumisection', 'title2', 'entries', 'data', 'x_min', 'x_max', 'x_bin', 'y_max', 'y_min', 'y_bin', 'source_data_file2', 'lumisection__run__run_number', 'lumisection__run__run_number__gte', 'lumisection__run__run_number__lte', 'lumisection__ls_number', 'lumisection__ls_number__gte', 'lumisection__ls_number__lte', 'entries__gte', 'entries__lte', 'source_data_file', 'title', 'lumisection__ls_number__in', 'lumisection__run__run_number__in', 'source_data_file__filepath__contains']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_lumisection_histogram2_d" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_lumisection_histogram2_d`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lumisection__run__run_number' in params:
            query_params.append(('lumisection__run__run_number', params['lumisection__run__run_number']))  # noqa: E501
        if 'lumisection__run__run_number__gte' in params:
            query_params.append(('lumisection__run__run_number__gte', params['lumisection__run__run_number__gte']))  # noqa: E501
        if 'lumisection__run__run_number__lte' in params:
            query_params.append(('lumisection__run__run_number__lte', params['lumisection__run__run_number__lte']))  # noqa: E501
        if 'lumisection__ls_number' in params:
            query_params.append(('lumisection__ls_number', params['lumisection__ls_number']))  # noqa: E501
        if 'lumisection__ls_number__gte' in params:
            query_params.append(('lumisection__ls_number__gte', params['lumisection__ls_number__gte']))  # noqa: E501
        if 'lumisection__ls_number__lte' in params:
            query_params.append(('lumisection__ls_number__lte', params['lumisection__ls_number__lte']))  # noqa: E501
        if 'entries__gte' in params:
            query_params.append(('entries__gte', params['entries__gte']))  # noqa: E501
        if 'entries__lte' in params:
            query_params.append(('entries__lte', params['entries__lte']))  # noqa: E501
        if 'source_data_file' in params:
            query_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'title' in params:
            query_params.append(('title', params['title']))  # noqa: E501
        if 'lumisection__ls_number__in' in params:
            query_params.append(('lumisection__ls_number__in', params['lumisection__ls_number__in']))  # noqa: E501
        if 'lumisection__run__run_number__in' in params:
            query_params.append(('lumisection__run__run_number__in', params['lumisection__run__run_number__in']))  # noqa: E501
        if 'source_data_file__filepath__contains' in params:
            query_params.append(('source_data_file__filepath__contains', params['source_data_file__filepath__contains']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501
        if 'x_min' in params:
            form_params.append(('x_min', params['x_min']))  # noqa: E501
        if 'x_max' in params:
            form_params.append(('x_max', params['x_max']))  # noqa: E501
        if 'x_bin' in params:
            form_params.append(('x_bin', params['x_bin']))  # noqa: E501
        if 'y_max' in params:
            form_params.append(('y_max', params['y_max']))  # noqa: E501
        if 'y_min' in params:
            form_params.append(('y_min', params['y_min']))  # noqa: E501
        if 'y_bin' in params:
            form_params.append(('y_bin', params['y_bin']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'lumisection' in params:
            form_params.append(('lumisection', params['lumisection']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501
        if 'x_min' in params:
            form_params.append(('x_min', params['x_min']))  # noqa: E501
        if 'x_max' in params:
            form_params.append(('x_max', params['x_max']))  # noqa: E501
        if 'x_bin' in params:
            form_params.append(('x_bin', params['x_bin']))  # noqa: E501
        if 'y_max' in params:
            form_params.append(('y_max', params['y_max']))  # noqa: E501
        if 'y_min' in params:
            form_params.append(('y_min', params['y_min']))  # noqa: E501
        if 'y_bin' in params:
            form_params.append(('y_bin', params['y_bin']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/lumisection_histograms_2d/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LumisectionHistogram2D',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_prediction(self, id, **kwargs):  # noqa: E501
        """update_prediction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_prediction(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this prediction. (required)
        :param Prediction body:
        :return: Prediction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_prediction_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_prediction_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_prediction_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_prediction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_prediction_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this prediction. (required)
        :param Prediction body:
        :return: Prediction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_prediction" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_prediction`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'strategy' in params:
            form_params.append(('strategy', params['strategy']))  # noqa: E501
        if 'run_histograms' in params:
            form_params.append(('run_histograms', params['run_histograms']))  # noqa: E501
            collection_formats['run_histograms'] = 'multi'  # noqa: E501
        if 'lumisection_histograms_1d' in params:
            form_params.append(('lumisection_histograms_1d', params['lumisection_histograms_1d']))  # noqa: E501
            collection_formats['lumisection_histograms_1d'] = 'multi'  # noqa: E501
        if 'lumisection_histograms_2d' in params:
            form_params.append(('lumisection_histograms_2d', params['lumisection_histograms_2d']))  # noqa: E501
            collection_formats['lumisection_histograms_2d'] = 'multi'  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501
        if 'task' in params:
            form_params.append(('task', params['task']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'strategy' in params:
            form_params.append(('strategy', params['strategy']))  # noqa: E501
        if 'run_histograms' in params:
            form_params.append(('run_histograms', params['run_histograms']))  # noqa: E501
            collection_formats['run_histograms'] = 'multi'  # noqa: E501
        if 'lumisection_histograms_1d' in params:
            form_params.append(('lumisection_histograms_1d', params['lumisection_histograms_1d']))  # noqa: E501
            collection_formats['lumisection_histograms_1d'] = 'multi'  # noqa: E501
        if 'lumisection_histograms_2d' in params:
            form_params.append(('lumisection_histograms_2d', params['lumisection_histograms_2d']))  # noqa: E501
            collection_formats['lumisection_histograms_2d'] = 'multi'  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501
        if 'task' in params:
            form_params.append(('task', params['task']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/predictions/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Prediction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_prediction(self, id, **kwargs):  # noqa: E501
        """update_prediction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_prediction(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this prediction. (required)
        :param int id2:
        :param str strategy2:
        :param list[PredictionRunHistograms] run_histograms2:
        :param list[PredictionLumisectionHistograms1d] lumisection_histograms_1d2:
        :param list[PredictionLumisectionHistograms2d] lumisection_histograms_2d2:
        :param datetime created2:
        :param datetime modified2:
        :param int task2:
        :param int id2:
        :param str strategy:
        :param list[PredictionRunHistograms] run_histograms:
        :param list[PredictionLumisectionHistograms1d] lumisection_histograms_1d:
        :param list[PredictionLumisectionHistograms2d] lumisection_histograms_2d:
        :param datetime created:
        :param datetime modified:
        :param int task:
        :return: Prediction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_prediction_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_prediction_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_prediction_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_prediction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_prediction_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this prediction. (required)
        :param int id2:
        :param str strategy2:
        :param list[PredictionRunHistograms] run_histograms2:
        :param list[PredictionLumisectionHistograms1d] lumisection_histograms_1d2:
        :param list[PredictionLumisectionHistograms2d] lumisection_histograms_2d2:
        :param datetime created2:
        :param datetime modified2:
        :param int task2:
        :param int id2:
        :param str strategy:
        :param list[PredictionRunHistograms] run_histograms:
        :param list[PredictionLumisectionHistograms1d] lumisection_histograms_1d:
        :param list[PredictionLumisectionHistograms2d] lumisection_histograms_2d:
        :param datetime created:
        :param datetime modified:
        :param int task:
        :return: Prediction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'id2', 'strategy2', 'run_histograms2', 'lumisection_histograms_1d2', 'lumisection_histograms_2d2', 'created2', 'modified2', 'task2', 'id2', 'strategy', 'run_histograms', 'lumisection_histograms_1d', 'lumisection_histograms_2d', 'created', 'modified', 'task']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_prediction" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_prediction`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'strategy' in params:
            form_params.append(('strategy', params['strategy']))  # noqa: E501
        if 'run_histograms' in params:
            form_params.append(('run_histograms', params['run_histograms']))  # noqa: E501
            collection_formats['run_histograms'] = 'multi'  # noqa: E501
        if 'lumisection_histograms_1d' in params:
            form_params.append(('lumisection_histograms_1d', params['lumisection_histograms_1d']))  # noqa: E501
            collection_formats['lumisection_histograms_1d'] = 'multi'  # noqa: E501
        if 'lumisection_histograms_2d' in params:
            form_params.append(('lumisection_histograms_2d', params['lumisection_histograms_2d']))  # noqa: E501
            collection_formats['lumisection_histograms_2d'] = 'multi'  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501
        if 'task' in params:
            form_params.append(('task', params['task']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'strategy' in params:
            form_params.append(('strategy', params['strategy']))  # noqa: E501
        if 'run_histograms' in params:
            form_params.append(('run_histograms', params['run_histograms']))  # noqa: E501
            collection_formats['run_histograms'] = 'multi'  # noqa: E501
        if 'lumisection_histograms_1d' in params:
            form_params.append(('lumisection_histograms_1d', params['lumisection_histograms_1d']))  # noqa: E501
            collection_formats['lumisection_histograms_1d'] = 'multi'  # noqa: E501
        if 'lumisection_histograms_2d' in params:
            form_params.append(('lumisection_histograms_2d', params['lumisection_histograms_2d']))  # noqa: E501
            collection_formats['lumisection_histograms_2d'] = 'multi'  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501
        if 'task' in params:
            form_params.append(('task', params['task']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/predictions/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Prediction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_prediction(self, id, **kwargs):  # noqa: E501
        """update_prediction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_prediction(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this prediction. (required)
        :param int id2:
        :param str strategy2:
        :param list[PredictionRunHistograms] run_histograms2:
        :param list[PredictionLumisectionHistograms1d] lumisection_histograms_1d2:
        :param list[PredictionLumisectionHistograms2d] lumisection_histograms_2d2:
        :param datetime created2:
        :param datetime modified2:
        :param int task2:
        :param int id2:
        :param str strategy:
        :param list[PredictionRunHistograms] run_histograms:
        :param list[PredictionLumisectionHistograms1d] lumisection_histograms_1d:
        :param list[PredictionLumisectionHistograms2d] lumisection_histograms_2d:
        :param datetime created:
        :param datetime modified:
        :param int task:
        :return: Prediction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_prediction_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_prediction_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_prediction_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_prediction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_prediction_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this prediction. (required)
        :param int id2:
        :param str strategy2:
        :param list[PredictionRunHistograms] run_histograms2:
        :param list[PredictionLumisectionHistograms1d] lumisection_histograms_1d2:
        :param list[PredictionLumisectionHistograms2d] lumisection_histograms_2d2:
        :param datetime created2:
        :param datetime modified2:
        :param int task2:
        :param int id2:
        :param str strategy:
        :param list[PredictionRunHistograms] run_histograms:
        :param list[PredictionLumisectionHistograms1d] lumisection_histograms_1d:
        :param list[PredictionLumisectionHistograms2d] lumisection_histograms_2d:
        :param datetime created:
        :param datetime modified:
        :param int task:
        :return: Prediction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'id2', 'strategy2', 'run_histograms2', 'lumisection_histograms_1d2', 'lumisection_histograms_2d2', 'created2', 'modified2', 'task2', 'id2', 'strategy', 'run_histograms', 'lumisection_histograms_1d', 'lumisection_histograms_2d', 'created', 'modified', 'task']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_prediction" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_prediction`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'strategy' in params:
            form_params.append(('strategy', params['strategy']))  # noqa: E501
        if 'run_histograms' in params:
            form_params.append(('run_histograms', params['run_histograms']))  # noqa: E501
            collection_formats['run_histograms'] = 'multi'  # noqa: E501
        if 'lumisection_histograms_1d' in params:
            form_params.append(('lumisection_histograms_1d', params['lumisection_histograms_1d']))  # noqa: E501
            collection_formats['lumisection_histograms_1d'] = 'multi'  # noqa: E501
        if 'lumisection_histograms_2d' in params:
            form_params.append(('lumisection_histograms_2d', params['lumisection_histograms_2d']))  # noqa: E501
            collection_formats['lumisection_histograms_2d'] = 'multi'  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501
        if 'task' in params:
            form_params.append(('task', params['task']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'strategy' in params:
            form_params.append(('strategy', params['strategy']))  # noqa: E501
        if 'run_histograms' in params:
            form_params.append(('run_histograms', params['run_histograms']))  # noqa: E501
            collection_formats['run_histograms'] = 'multi'  # noqa: E501
        if 'lumisection_histograms_1d' in params:
            form_params.append(('lumisection_histograms_1d', params['lumisection_histograms_1d']))  # noqa: E501
            collection_formats['lumisection_histograms_1d'] = 'multi'  # noqa: E501
        if 'lumisection_histograms_2d' in params:
            form_params.append(('lumisection_histograms_2d', params['lumisection_histograms_2d']))  # noqa: E501
            collection_formats['lumisection_histograms_2d'] = 'multi'  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501
        if 'task' in params:
            form_params.append(('task', params['task']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/predictions/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Prediction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_run(self, run_number, **kwargs):  # noqa: E501
        """update_run  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_run(run_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str run_number: A unique value identifying this run. (required)
        :param Run body:
        :param str run_number2: run_number
        :param str run_date: run_date
        :param str year: year
        :param str period: period
        :param str _date: date
        :param str oms_fill: oms_fill
        :param str oms_lumisections: oms_lumisections
        :param str oms_initial_lumi: oms_initial_lumi
        :param str oms_end_lumi: oms_end_lumi
        :return: Run
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_run_with_http_info(run_number, **kwargs)  # noqa: E501
        else:
            (data) = self.update_run_with_http_info(run_number, **kwargs)  # noqa: E501
            return data

    def update_run_with_http_info(self, run_number, **kwargs):  # noqa: E501
        """update_run  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_run_with_http_info(run_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str run_number: A unique value identifying this run. (required)
        :param Run body:
        :param str run_number2: run_number
        :param str run_date: run_date
        :param str year: year
        :param str period: period
        :param str _date: date
        :param str oms_fill: oms_fill
        :param str oms_lumisections: oms_lumisections
        :param str oms_initial_lumi: oms_initial_lumi
        :param str oms_end_lumi: oms_end_lumi
        :return: Run
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['run_number', 'body', 'run_number2', 'run_date', 'year', 'period', '_date', 'oms_fill', 'oms_lumisections', 'oms_initial_lumi', 'oms_end_lumi']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_run" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'run_number' is set
        if ('run_number' not in params or
                params['run_number'] is None):
            raise ValueError("Missing the required parameter `run_number` when calling `update_run`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'run_number' in params:
            path_params['run_number'] = params['run_number']  # noqa: E501

        query_params = []
        if 'run_number' in params:
            query_params.append(('run_number', params['run_number']))  # noqa: E501
        if 'run_date' in params:
            query_params.append(('run_date', params['run_date']))  # noqa: E501
        if 'year' in params:
            query_params.append(('year', params['year']))  # noqa: E501
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'oms_fill' in params:
            query_params.append(('oms_fill', params['oms_fill']))  # noqa: E501
        if 'oms_lumisections' in params:
            query_params.append(('oms_lumisections', params['oms_lumisections']))  # noqa: E501
        if 'oms_initial_lumi' in params:
            query_params.append(('oms_initial_lumi', params['oms_initial_lumi']))  # noqa: E501
        if 'oms_end_lumi' in params:
            query_params.append(('oms_end_lumi', params['oms_end_lumi']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'run_number' in params:
            form_params.append(('run_number', params['run_number']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'run_number' in params:
            form_params.append(('run_number', params['run_number']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/runs/{run_number}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Run',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_run(self, run_number, **kwargs):  # noqa: E501
        """update_run  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_run(run_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str run_number: A unique value identifying this run. (required)
        :param int run_number2:
        :param datetime _date2:
        :param int run_number2:
        :param datetime _date2:
        :param str run_number2: run_number
        :param str run_date: run_date
        :param str year: year
        :param str period: period
        :param str _date: date
        :param str oms_fill: oms_fill
        :param str oms_lumisections: oms_lumisections
        :param str oms_initial_lumi: oms_initial_lumi
        :param str oms_end_lumi: oms_end_lumi
        :return: Run
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_run_with_http_info(run_number, **kwargs)  # noqa: E501
        else:
            (data) = self.update_run_with_http_info(run_number, **kwargs)  # noqa: E501
            return data

    def update_run_with_http_info(self, run_number, **kwargs):  # noqa: E501
        """update_run  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_run_with_http_info(run_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str run_number: A unique value identifying this run. (required)
        :param int run_number2:
        :param datetime _date2:
        :param int run_number2:
        :param datetime _date2:
        :param str run_number2: run_number
        :param str run_date: run_date
        :param str year: year
        :param str period: period
        :param str _date: date
        :param str oms_fill: oms_fill
        :param str oms_lumisections: oms_lumisections
        :param str oms_initial_lumi: oms_initial_lumi
        :param str oms_end_lumi: oms_end_lumi
        :return: Run
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['run_number', 'run_number2', '_date2', 'run_number2', '_date2', 'run_number2', 'run_date', 'year', 'period', '_date', 'oms_fill', 'oms_lumisections', 'oms_initial_lumi', 'oms_end_lumi']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_run" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'run_number' is set
        if ('run_number' not in params or
                params['run_number'] is None):
            raise ValueError("Missing the required parameter `run_number` when calling `update_run`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'run_number' in params:
            path_params['run_number'] = params['run_number']  # noqa: E501

        query_params = []
        if 'run_number' in params:
            query_params.append(('run_number', params['run_number']))  # noqa: E501
        if 'run_date' in params:
            query_params.append(('run_date', params['run_date']))  # noqa: E501
        if 'year' in params:
            query_params.append(('year', params['year']))  # noqa: E501
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'oms_fill' in params:
            query_params.append(('oms_fill', params['oms_fill']))  # noqa: E501
        if 'oms_lumisections' in params:
            query_params.append(('oms_lumisections', params['oms_lumisections']))  # noqa: E501
        if 'oms_initial_lumi' in params:
            query_params.append(('oms_initial_lumi', params['oms_initial_lumi']))  # noqa: E501
        if 'oms_end_lumi' in params:
            query_params.append(('oms_end_lumi', params['oms_end_lumi']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'run_number' in params:
            form_params.append(('run_number', params['run_number']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'run_number' in params:
            form_params.append(('run_number', params['run_number']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/runs/{run_number}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Run',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_run(self, run_number, **kwargs):  # noqa: E501
        """update_run  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_run(run_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str run_number: A unique value identifying this run. (required)
        :param int run_number2:
        :param datetime _date2:
        :param int run_number2:
        :param datetime _date2:
        :param str run_number2: run_number
        :param str run_date: run_date
        :param str year: year
        :param str period: period
        :param str _date: date
        :param str oms_fill: oms_fill
        :param str oms_lumisections: oms_lumisections
        :param str oms_initial_lumi: oms_initial_lumi
        :param str oms_end_lumi: oms_end_lumi
        :return: Run
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_run_with_http_info(run_number, **kwargs)  # noqa: E501
        else:
            (data) = self.update_run_with_http_info(run_number, **kwargs)  # noqa: E501
            return data

    def update_run_with_http_info(self, run_number, **kwargs):  # noqa: E501
        """update_run  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_run_with_http_info(run_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str run_number: A unique value identifying this run. (required)
        :param int run_number2:
        :param datetime _date2:
        :param int run_number2:
        :param datetime _date2:
        :param str run_number2: run_number
        :param str run_date: run_date
        :param str year: year
        :param str period: period
        :param str _date: date
        :param str oms_fill: oms_fill
        :param str oms_lumisections: oms_lumisections
        :param str oms_initial_lumi: oms_initial_lumi
        :param str oms_end_lumi: oms_end_lumi
        :return: Run
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['run_number', 'run_number2', '_date2', 'run_number2', '_date2', 'run_number2', 'run_date', 'year', 'period', '_date', 'oms_fill', 'oms_lumisections', 'oms_initial_lumi', 'oms_end_lumi']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_run" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'run_number' is set
        if ('run_number' not in params or
                params['run_number'] is None):
            raise ValueError("Missing the required parameter `run_number` when calling `update_run`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'run_number' in params:
            path_params['run_number'] = params['run_number']  # noqa: E501

        query_params = []
        if 'run_number' in params:
            query_params.append(('run_number', params['run_number']))  # noqa: E501
        if 'run_date' in params:
            query_params.append(('run_date', params['run_date']))  # noqa: E501
        if 'year' in params:
            query_params.append(('year', params['year']))  # noqa: E501
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'oms_fill' in params:
            query_params.append(('oms_fill', params['oms_fill']))  # noqa: E501
        if 'oms_lumisections' in params:
            query_params.append(('oms_lumisections', params['oms_lumisections']))  # noqa: E501
        if 'oms_initial_lumi' in params:
            query_params.append(('oms_initial_lumi', params['oms_initial_lumi']))  # noqa: E501
        if 'oms_end_lumi' in params:
            query_params.append(('oms_end_lumi', params['oms_end_lumi']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'run_number' in params:
            form_params.append(('run_number', params['run_number']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'run_number' in params:
            form_params.append(('run_number', params['run_number']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/runs/{run_number}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Run',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_run_certification(self, id, **kwargs):  # noqa: E501
        """update_run_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_run_certification(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this run certification. (required)
        :param RunCertification body:
        :param str run: run
        :param str _date: date
        :param str rr_is_pixel_good: rr_is_pixel_good
        :param str rr_is_strip_good: rr_is_strip_good
        :param str rr_is_ecal_good: rr_is_ecal_good
        :param str rr_is_hcal_good: rr_is_hcal_good
        :param str rr_is_dt_good: rr_is_dt_good
        :param str rr_is_csc_good: rr_is_csc_good
        :param str rr_is_tracking_good: rr_is_tracking_good
        :param str rr_is_muon_good: rr_is_muon_good
        :param str rr_is_egamma_good: rr_is_egamma_good
        :param str rr_is_tau_good: rr_is_tau_good
        :param str rr_is_jetmet_good: rr_is_jetmet_good
        :param str rr_is_btag_good: rr_is_btag_good
        :param str rr_frac_pixel_good: rr_frac_pixel_good
        :param str rr_frac_strip_good: rr_frac_strip_good
        :param str rr_frac_ecal_good: rr_frac_ecal_good
        :param str rr_frac_hcal_good: rr_frac_hcal_good
        :param str rr_frac_dt_good: rr_frac_dt_good
        :param str rr_frac_csc_good: rr_frac_csc_good
        :param str rr_frac_tracking_good: rr_frac_tracking_good
        :param str rr_frac_muon_good: rr_frac_muon_good
        :param str rr_frac_egamma_good: rr_frac_egamma_good
        :param str rr_frac_tau_good: rr_frac_tau_good
        :param str rr_frac_jetmet_good: rr_frac_jetmet_good
        :param str rr_frac_btag_good: rr_frac_btag_good
        :return: RunCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_run_certification_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_run_certification_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_run_certification_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_run_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_run_certification_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this run certification. (required)
        :param RunCertification body:
        :param str run: run
        :param str _date: date
        :param str rr_is_pixel_good: rr_is_pixel_good
        :param str rr_is_strip_good: rr_is_strip_good
        :param str rr_is_ecal_good: rr_is_ecal_good
        :param str rr_is_hcal_good: rr_is_hcal_good
        :param str rr_is_dt_good: rr_is_dt_good
        :param str rr_is_csc_good: rr_is_csc_good
        :param str rr_is_tracking_good: rr_is_tracking_good
        :param str rr_is_muon_good: rr_is_muon_good
        :param str rr_is_egamma_good: rr_is_egamma_good
        :param str rr_is_tau_good: rr_is_tau_good
        :param str rr_is_jetmet_good: rr_is_jetmet_good
        :param str rr_is_btag_good: rr_is_btag_good
        :param str rr_frac_pixel_good: rr_frac_pixel_good
        :param str rr_frac_strip_good: rr_frac_strip_good
        :param str rr_frac_ecal_good: rr_frac_ecal_good
        :param str rr_frac_hcal_good: rr_frac_hcal_good
        :param str rr_frac_dt_good: rr_frac_dt_good
        :param str rr_frac_csc_good: rr_frac_csc_good
        :param str rr_frac_tracking_good: rr_frac_tracking_good
        :param str rr_frac_muon_good: rr_frac_muon_good
        :param str rr_frac_egamma_good: rr_frac_egamma_good
        :param str rr_frac_tau_good: rr_frac_tau_good
        :param str rr_frac_jetmet_good: rr_frac_jetmet_good
        :param str rr_frac_btag_good: rr_frac_btag_good
        :return: RunCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'run', '_date', 'rr_is_pixel_good', 'rr_is_strip_good', 'rr_is_ecal_good', 'rr_is_hcal_good', 'rr_is_dt_good', 'rr_is_csc_good', 'rr_is_tracking_good', 'rr_is_muon_good', 'rr_is_egamma_good', 'rr_is_tau_good', 'rr_is_jetmet_good', 'rr_is_btag_good', 'rr_frac_pixel_good', 'rr_frac_strip_good', 'rr_frac_ecal_good', 'rr_frac_hcal_good', 'rr_frac_dt_good', 'rr_frac_csc_good', 'rr_frac_tracking_good', 'rr_frac_muon_good', 'rr_frac_egamma_good', 'rr_frac_tau_good', 'rr_frac_jetmet_good', 'rr_frac_btag_good']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_run_certification" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_run_certification`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'run' in params:
            query_params.append(('run', params['run']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            query_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            query_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            query_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            query_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            query_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            query_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            query_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            query_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            query_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            query_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            query_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            query_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'rr_frac_pixel_good' in params:
            query_params.append(('rr_frac_pixel_good', params['rr_frac_pixel_good']))  # noqa: E501
        if 'rr_frac_strip_good' in params:
            query_params.append(('rr_frac_strip_good', params['rr_frac_strip_good']))  # noqa: E501
        if 'rr_frac_ecal_good' in params:
            query_params.append(('rr_frac_ecal_good', params['rr_frac_ecal_good']))  # noqa: E501
        if 'rr_frac_hcal_good' in params:
            query_params.append(('rr_frac_hcal_good', params['rr_frac_hcal_good']))  # noqa: E501
        if 'rr_frac_dt_good' in params:
            query_params.append(('rr_frac_dt_good', params['rr_frac_dt_good']))  # noqa: E501
        if 'rr_frac_csc_good' in params:
            query_params.append(('rr_frac_csc_good', params['rr_frac_csc_good']))  # noqa: E501
        if 'rr_frac_tracking_good' in params:
            query_params.append(('rr_frac_tracking_good', params['rr_frac_tracking_good']))  # noqa: E501
        if 'rr_frac_muon_good' in params:
            query_params.append(('rr_frac_muon_good', params['rr_frac_muon_good']))  # noqa: E501
        if 'rr_frac_egamma_good' in params:
            query_params.append(('rr_frac_egamma_good', params['rr_frac_egamma_good']))  # noqa: E501
        if 'rr_frac_tau_good' in params:
            query_params.append(('rr_frac_tau_good', params['rr_frac_tau_good']))  # noqa: E501
        if 'rr_frac_jetmet_good' in params:
            query_params.append(('rr_frac_jetmet_good', params['rr_frac_jetmet_good']))  # noqa: E501
        if 'rr_frac_btag_good' in params:
            query_params.append(('rr_frac_btag_good', params['rr_frac_btag_good']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            form_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            form_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            form_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            form_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            form_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            form_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            form_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            form_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            form_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            form_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            form_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            form_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'rr_frac_pixel_good' in params:
            form_params.append(('rr_frac_pixel_good', params['rr_frac_pixel_good']))  # noqa: E501
        if 'rr_frac_strip_good' in params:
            form_params.append(('rr_frac_strip_good', params['rr_frac_strip_good']))  # noqa: E501
        if 'rr_frac_ecal_good' in params:
            form_params.append(('rr_frac_ecal_good', params['rr_frac_ecal_good']))  # noqa: E501
        if 'rr_frac_hcal_good' in params:
            form_params.append(('rr_frac_hcal_good', params['rr_frac_hcal_good']))  # noqa: E501
        if 'rr_frac_dt_good' in params:
            form_params.append(('rr_frac_dt_good', params['rr_frac_dt_good']))  # noqa: E501
        if 'rr_frac_csc_good' in params:
            form_params.append(('rr_frac_csc_good', params['rr_frac_csc_good']))  # noqa: E501
        if 'rr_frac_tracking_good' in params:
            form_params.append(('rr_frac_tracking_good', params['rr_frac_tracking_good']))  # noqa: E501
        if 'rr_frac_muon_good' in params:
            form_params.append(('rr_frac_muon_good', params['rr_frac_muon_good']))  # noqa: E501
        if 'rr_frac_egamma_good' in params:
            form_params.append(('rr_frac_egamma_good', params['rr_frac_egamma_good']))  # noqa: E501
        if 'rr_frac_tau_good' in params:
            form_params.append(('rr_frac_tau_good', params['rr_frac_tau_good']))  # noqa: E501
        if 'rr_frac_jetmet_good' in params:
            form_params.append(('rr_frac_jetmet_good', params['rr_frac_jetmet_good']))  # noqa: E501
        if 'rr_frac_btag_good' in params:
            form_params.append(('rr_frac_btag_good', params['rr_frac_btag_good']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            form_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            form_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            form_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            form_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            form_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            form_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            form_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            form_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            form_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            form_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            form_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            form_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'rr_frac_pixel_good' in params:
            form_params.append(('rr_frac_pixel_good', params['rr_frac_pixel_good']))  # noqa: E501
        if 'rr_frac_strip_good' in params:
            form_params.append(('rr_frac_strip_good', params['rr_frac_strip_good']))  # noqa: E501
        if 'rr_frac_ecal_good' in params:
            form_params.append(('rr_frac_ecal_good', params['rr_frac_ecal_good']))  # noqa: E501
        if 'rr_frac_hcal_good' in params:
            form_params.append(('rr_frac_hcal_good', params['rr_frac_hcal_good']))  # noqa: E501
        if 'rr_frac_dt_good' in params:
            form_params.append(('rr_frac_dt_good', params['rr_frac_dt_good']))  # noqa: E501
        if 'rr_frac_csc_good' in params:
            form_params.append(('rr_frac_csc_good', params['rr_frac_csc_good']))  # noqa: E501
        if 'rr_frac_tracking_good' in params:
            form_params.append(('rr_frac_tracking_good', params['rr_frac_tracking_good']))  # noqa: E501
        if 'rr_frac_muon_good' in params:
            form_params.append(('rr_frac_muon_good', params['rr_frac_muon_good']))  # noqa: E501
        if 'rr_frac_egamma_good' in params:
            form_params.append(('rr_frac_egamma_good', params['rr_frac_egamma_good']))  # noqa: E501
        if 'rr_frac_tau_good' in params:
            form_params.append(('rr_frac_tau_good', params['rr_frac_tau_good']))  # noqa: E501
        if 'rr_frac_jetmet_good' in params:
            form_params.append(('rr_frac_jetmet_good', params['rr_frac_jetmet_good']))  # noqa: E501
        if 'rr_frac_btag_good' in params:
            form_params.append(('rr_frac_btag_good', params['rr_frac_btag_good']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/run_certifications/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RunCertification',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_run_certification(self, id, **kwargs):  # noqa: E501
        """update_run_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_run_certification(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this run certification. (required)
        :param int id2:
        :param int run2:
        :param datetime _date2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param float rr_frac_pixel_good2:
        :param float rr_frac_strip_good2:
        :param float rr_frac_ecal_good2:
        :param float rr_frac_hcal_good2:
        :param float rr_frac_dt_good2:
        :param float rr_frac_csc_good2:
        :param float rr_frac_tracking_good2:
        :param float rr_frac_muon_good2:
        :param float rr_frac_egamma_good2:
        :param float rr_frac_tau_good2:
        :param float rr_frac_jetmet_good2:
        :param float rr_frac_btag_good2:
        :param int id2:
        :param int run2:
        :param datetime _date2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param float rr_frac_pixel_good2:
        :param float rr_frac_strip_good2:
        :param float rr_frac_ecal_good2:
        :param float rr_frac_hcal_good2:
        :param float rr_frac_dt_good2:
        :param float rr_frac_csc_good2:
        :param float rr_frac_tracking_good2:
        :param float rr_frac_muon_good2:
        :param float rr_frac_egamma_good2:
        :param float rr_frac_tau_good2:
        :param float rr_frac_jetmet_good2:
        :param float rr_frac_btag_good2:
        :param str run: run
        :param str _date: date
        :param str rr_is_pixel_good: rr_is_pixel_good
        :param str rr_is_strip_good: rr_is_strip_good
        :param str rr_is_ecal_good: rr_is_ecal_good
        :param str rr_is_hcal_good: rr_is_hcal_good
        :param str rr_is_dt_good: rr_is_dt_good
        :param str rr_is_csc_good: rr_is_csc_good
        :param str rr_is_tracking_good: rr_is_tracking_good
        :param str rr_is_muon_good: rr_is_muon_good
        :param str rr_is_egamma_good: rr_is_egamma_good
        :param str rr_is_tau_good: rr_is_tau_good
        :param str rr_is_jetmet_good: rr_is_jetmet_good
        :param str rr_is_btag_good: rr_is_btag_good
        :param str rr_frac_pixel_good: rr_frac_pixel_good
        :param str rr_frac_strip_good: rr_frac_strip_good
        :param str rr_frac_ecal_good: rr_frac_ecal_good
        :param str rr_frac_hcal_good: rr_frac_hcal_good
        :param str rr_frac_dt_good: rr_frac_dt_good
        :param str rr_frac_csc_good: rr_frac_csc_good
        :param str rr_frac_tracking_good: rr_frac_tracking_good
        :param str rr_frac_muon_good: rr_frac_muon_good
        :param str rr_frac_egamma_good: rr_frac_egamma_good
        :param str rr_frac_tau_good: rr_frac_tau_good
        :param str rr_frac_jetmet_good: rr_frac_jetmet_good
        :param str rr_frac_btag_good: rr_frac_btag_good
        :return: RunCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_run_certification_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_run_certification_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_run_certification_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_run_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_run_certification_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this run certification. (required)
        :param int id2:
        :param int run2:
        :param datetime _date2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param float rr_frac_pixel_good2:
        :param float rr_frac_strip_good2:
        :param float rr_frac_ecal_good2:
        :param float rr_frac_hcal_good2:
        :param float rr_frac_dt_good2:
        :param float rr_frac_csc_good2:
        :param float rr_frac_tracking_good2:
        :param float rr_frac_muon_good2:
        :param float rr_frac_egamma_good2:
        :param float rr_frac_tau_good2:
        :param float rr_frac_jetmet_good2:
        :param float rr_frac_btag_good2:
        :param int id2:
        :param int run2:
        :param datetime _date2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param float rr_frac_pixel_good2:
        :param float rr_frac_strip_good2:
        :param float rr_frac_ecal_good2:
        :param float rr_frac_hcal_good2:
        :param float rr_frac_dt_good2:
        :param float rr_frac_csc_good2:
        :param float rr_frac_tracking_good2:
        :param float rr_frac_muon_good2:
        :param float rr_frac_egamma_good2:
        :param float rr_frac_tau_good2:
        :param float rr_frac_jetmet_good2:
        :param float rr_frac_btag_good2:
        :param str run: run
        :param str _date: date
        :param str rr_is_pixel_good: rr_is_pixel_good
        :param str rr_is_strip_good: rr_is_strip_good
        :param str rr_is_ecal_good: rr_is_ecal_good
        :param str rr_is_hcal_good: rr_is_hcal_good
        :param str rr_is_dt_good: rr_is_dt_good
        :param str rr_is_csc_good: rr_is_csc_good
        :param str rr_is_tracking_good: rr_is_tracking_good
        :param str rr_is_muon_good: rr_is_muon_good
        :param str rr_is_egamma_good: rr_is_egamma_good
        :param str rr_is_tau_good: rr_is_tau_good
        :param str rr_is_jetmet_good: rr_is_jetmet_good
        :param str rr_is_btag_good: rr_is_btag_good
        :param str rr_frac_pixel_good: rr_frac_pixel_good
        :param str rr_frac_strip_good: rr_frac_strip_good
        :param str rr_frac_ecal_good: rr_frac_ecal_good
        :param str rr_frac_hcal_good: rr_frac_hcal_good
        :param str rr_frac_dt_good: rr_frac_dt_good
        :param str rr_frac_csc_good: rr_frac_csc_good
        :param str rr_frac_tracking_good: rr_frac_tracking_good
        :param str rr_frac_muon_good: rr_frac_muon_good
        :param str rr_frac_egamma_good: rr_frac_egamma_good
        :param str rr_frac_tau_good: rr_frac_tau_good
        :param str rr_frac_jetmet_good: rr_frac_jetmet_good
        :param str rr_frac_btag_good: rr_frac_btag_good
        :return: RunCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'id2', 'run2', '_date2', 'rr_is_pixel_good2', 'rr_is_strip_good2', 'rr_is_ecal_good2', 'rr_is_hcal_good2', 'rr_is_dt_good2', 'rr_is_csc_good2', 'rr_is_tracking_good2', 'rr_is_muon_good2', 'rr_is_egamma_good2', 'rr_is_tau_good2', 'rr_is_jetmet_good2', 'rr_is_btag_good2', 'rr_frac_pixel_good2', 'rr_frac_strip_good2', 'rr_frac_ecal_good2', 'rr_frac_hcal_good2', 'rr_frac_dt_good2', 'rr_frac_csc_good2', 'rr_frac_tracking_good2', 'rr_frac_muon_good2', 'rr_frac_egamma_good2', 'rr_frac_tau_good2', 'rr_frac_jetmet_good2', 'rr_frac_btag_good2', 'id2', 'run2', '_date2', 'rr_is_pixel_good2', 'rr_is_strip_good2', 'rr_is_ecal_good2', 'rr_is_hcal_good2', 'rr_is_dt_good2', 'rr_is_csc_good2', 'rr_is_tracking_good2', 'rr_is_muon_good2', 'rr_is_egamma_good2', 'rr_is_tau_good2', 'rr_is_jetmet_good2', 'rr_is_btag_good2', 'rr_frac_pixel_good2', 'rr_frac_strip_good2', 'rr_frac_ecal_good2', 'rr_frac_hcal_good2', 'rr_frac_dt_good2', 'rr_frac_csc_good2', 'rr_frac_tracking_good2', 'rr_frac_muon_good2', 'rr_frac_egamma_good2', 'rr_frac_tau_good2', 'rr_frac_jetmet_good2', 'rr_frac_btag_good2', 'run', '_date', 'rr_is_pixel_good', 'rr_is_strip_good', 'rr_is_ecal_good', 'rr_is_hcal_good', 'rr_is_dt_good', 'rr_is_csc_good', 'rr_is_tracking_good', 'rr_is_muon_good', 'rr_is_egamma_good', 'rr_is_tau_good', 'rr_is_jetmet_good', 'rr_is_btag_good', 'rr_frac_pixel_good', 'rr_frac_strip_good', 'rr_frac_ecal_good', 'rr_frac_hcal_good', 'rr_frac_dt_good', 'rr_frac_csc_good', 'rr_frac_tracking_good', 'rr_frac_muon_good', 'rr_frac_egamma_good', 'rr_frac_tau_good', 'rr_frac_jetmet_good', 'rr_frac_btag_good']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_run_certification" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_run_certification`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'run' in params:
            query_params.append(('run', params['run']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            query_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            query_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            query_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            query_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            query_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            query_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            query_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            query_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            query_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            query_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            query_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            query_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'rr_frac_pixel_good' in params:
            query_params.append(('rr_frac_pixel_good', params['rr_frac_pixel_good']))  # noqa: E501
        if 'rr_frac_strip_good' in params:
            query_params.append(('rr_frac_strip_good', params['rr_frac_strip_good']))  # noqa: E501
        if 'rr_frac_ecal_good' in params:
            query_params.append(('rr_frac_ecal_good', params['rr_frac_ecal_good']))  # noqa: E501
        if 'rr_frac_hcal_good' in params:
            query_params.append(('rr_frac_hcal_good', params['rr_frac_hcal_good']))  # noqa: E501
        if 'rr_frac_dt_good' in params:
            query_params.append(('rr_frac_dt_good', params['rr_frac_dt_good']))  # noqa: E501
        if 'rr_frac_csc_good' in params:
            query_params.append(('rr_frac_csc_good', params['rr_frac_csc_good']))  # noqa: E501
        if 'rr_frac_tracking_good' in params:
            query_params.append(('rr_frac_tracking_good', params['rr_frac_tracking_good']))  # noqa: E501
        if 'rr_frac_muon_good' in params:
            query_params.append(('rr_frac_muon_good', params['rr_frac_muon_good']))  # noqa: E501
        if 'rr_frac_egamma_good' in params:
            query_params.append(('rr_frac_egamma_good', params['rr_frac_egamma_good']))  # noqa: E501
        if 'rr_frac_tau_good' in params:
            query_params.append(('rr_frac_tau_good', params['rr_frac_tau_good']))  # noqa: E501
        if 'rr_frac_jetmet_good' in params:
            query_params.append(('rr_frac_jetmet_good', params['rr_frac_jetmet_good']))  # noqa: E501
        if 'rr_frac_btag_good' in params:
            query_params.append(('rr_frac_btag_good', params['rr_frac_btag_good']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            form_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            form_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            form_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            form_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            form_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            form_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            form_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            form_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            form_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            form_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            form_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            form_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'rr_frac_pixel_good' in params:
            form_params.append(('rr_frac_pixel_good', params['rr_frac_pixel_good']))  # noqa: E501
        if 'rr_frac_strip_good' in params:
            form_params.append(('rr_frac_strip_good', params['rr_frac_strip_good']))  # noqa: E501
        if 'rr_frac_ecal_good' in params:
            form_params.append(('rr_frac_ecal_good', params['rr_frac_ecal_good']))  # noqa: E501
        if 'rr_frac_hcal_good' in params:
            form_params.append(('rr_frac_hcal_good', params['rr_frac_hcal_good']))  # noqa: E501
        if 'rr_frac_dt_good' in params:
            form_params.append(('rr_frac_dt_good', params['rr_frac_dt_good']))  # noqa: E501
        if 'rr_frac_csc_good' in params:
            form_params.append(('rr_frac_csc_good', params['rr_frac_csc_good']))  # noqa: E501
        if 'rr_frac_tracking_good' in params:
            form_params.append(('rr_frac_tracking_good', params['rr_frac_tracking_good']))  # noqa: E501
        if 'rr_frac_muon_good' in params:
            form_params.append(('rr_frac_muon_good', params['rr_frac_muon_good']))  # noqa: E501
        if 'rr_frac_egamma_good' in params:
            form_params.append(('rr_frac_egamma_good', params['rr_frac_egamma_good']))  # noqa: E501
        if 'rr_frac_tau_good' in params:
            form_params.append(('rr_frac_tau_good', params['rr_frac_tau_good']))  # noqa: E501
        if 'rr_frac_jetmet_good' in params:
            form_params.append(('rr_frac_jetmet_good', params['rr_frac_jetmet_good']))  # noqa: E501
        if 'rr_frac_btag_good' in params:
            form_params.append(('rr_frac_btag_good', params['rr_frac_btag_good']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            form_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            form_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            form_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            form_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            form_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            form_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            form_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            form_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            form_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            form_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            form_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            form_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'rr_frac_pixel_good' in params:
            form_params.append(('rr_frac_pixel_good', params['rr_frac_pixel_good']))  # noqa: E501
        if 'rr_frac_strip_good' in params:
            form_params.append(('rr_frac_strip_good', params['rr_frac_strip_good']))  # noqa: E501
        if 'rr_frac_ecal_good' in params:
            form_params.append(('rr_frac_ecal_good', params['rr_frac_ecal_good']))  # noqa: E501
        if 'rr_frac_hcal_good' in params:
            form_params.append(('rr_frac_hcal_good', params['rr_frac_hcal_good']))  # noqa: E501
        if 'rr_frac_dt_good' in params:
            form_params.append(('rr_frac_dt_good', params['rr_frac_dt_good']))  # noqa: E501
        if 'rr_frac_csc_good' in params:
            form_params.append(('rr_frac_csc_good', params['rr_frac_csc_good']))  # noqa: E501
        if 'rr_frac_tracking_good' in params:
            form_params.append(('rr_frac_tracking_good', params['rr_frac_tracking_good']))  # noqa: E501
        if 'rr_frac_muon_good' in params:
            form_params.append(('rr_frac_muon_good', params['rr_frac_muon_good']))  # noqa: E501
        if 'rr_frac_egamma_good' in params:
            form_params.append(('rr_frac_egamma_good', params['rr_frac_egamma_good']))  # noqa: E501
        if 'rr_frac_tau_good' in params:
            form_params.append(('rr_frac_tau_good', params['rr_frac_tau_good']))  # noqa: E501
        if 'rr_frac_jetmet_good' in params:
            form_params.append(('rr_frac_jetmet_good', params['rr_frac_jetmet_good']))  # noqa: E501
        if 'rr_frac_btag_good' in params:
            form_params.append(('rr_frac_btag_good', params['rr_frac_btag_good']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/run_certifications/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RunCertification',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_run_certification(self, id, **kwargs):  # noqa: E501
        """update_run_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_run_certification(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this run certification. (required)
        :param int id2:
        :param int run2:
        :param datetime _date2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param float rr_frac_pixel_good2:
        :param float rr_frac_strip_good2:
        :param float rr_frac_ecal_good2:
        :param float rr_frac_hcal_good2:
        :param float rr_frac_dt_good2:
        :param float rr_frac_csc_good2:
        :param float rr_frac_tracking_good2:
        :param float rr_frac_muon_good2:
        :param float rr_frac_egamma_good2:
        :param float rr_frac_tau_good2:
        :param float rr_frac_jetmet_good2:
        :param float rr_frac_btag_good2:
        :param int id2:
        :param int run2:
        :param datetime _date2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param float rr_frac_pixel_good2:
        :param float rr_frac_strip_good2:
        :param float rr_frac_ecal_good2:
        :param float rr_frac_hcal_good2:
        :param float rr_frac_dt_good2:
        :param float rr_frac_csc_good2:
        :param float rr_frac_tracking_good2:
        :param float rr_frac_muon_good2:
        :param float rr_frac_egamma_good2:
        :param float rr_frac_tau_good2:
        :param float rr_frac_jetmet_good2:
        :param float rr_frac_btag_good2:
        :param str run: run
        :param str _date: date
        :param str rr_is_pixel_good: rr_is_pixel_good
        :param str rr_is_strip_good: rr_is_strip_good
        :param str rr_is_ecal_good: rr_is_ecal_good
        :param str rr_is_hcal_good: rr_is_hcal_good
        :param str rr_is_dt_good: rr_is_dt_good
        :param str rr_is_csc_good: rr_is_csc_good
        :param str rr_is_tracking_good: rr_is_tracking_good
        :param str rr_is_muon_good: rr_is_muon_good
        :param str rr_is_egamma_good: rr_is_egamma_good
        :param str rr_is_tau_good: rr_is_tau_good
        :param str rr_is_jetmet_good: rr_is_jetmet_good
        :param str rr_is_btag_good: rr_is_btag_good
        :param str rr_frac_pixel_good: rr_frac_pixel_good
        :param str rr_frac_strip_good: rr_frac_strip_good
        :param str rr_frac_ecal_good: rr_frac_ecal_good
        :param str rr_frac_hcal_good: rr_frac_hcal_good
        :param str rr_frac_dt_good: rr_frac_dt_good
        :param str rr_frac_csc_good: rr_frac_csc_good
        :param str rr_frac_tracking_good: rr_frac_tracking_good
        :param str rr_frac_muon_good: rr_frac_muon_good
        :param str rr_frac_egamma_good: rr_frac_egamma_good
        :param str rr_frac_tau_good: rr_frac_tau_good
        :param str rr_frac_jetmet_good: rr_frac_jetmet_good
        :param str rr_frac_btag_good: rr_frac_btag_good
        :return: RunCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_run_certification_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_run_certification_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_run_certification_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_run_certification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_run_certification_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this run certification. (required)
        :param int id2:
        :param int run2:
        :param datetime _date2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param float rr_frac_pixel_good2:
        :param float rr_frac_strip_good2:
        :param float rr_frac_ecal_good2:
        :param float rr_frac_hcal_good2:
        :param float rr_frac_dt_good2:
        :param float rr_frac_csc_good2:
        :param float rr_frac_tracking_good2:
        :param float rr_frac_muon_good2:
        :param float rr_frac_egamma_good2:
        :param float rr_frac_tau_good2:
        :param float rr_frac_jetmet_good2:
        :param float rr_frac_btag_good2:
        :param int id2:
        :param int run2:
        :param datetime _date2:
        :param bool rr_is_pixel_good2:
        :param bool rr_is_strip_good2:
        :param bool rr_is_ecal_good2:
        :param bool rr_is_hcal_good2:
        :param bool rr_is_dt_good2:
        :param bool rr_is_csc_good2:
        :param bool rr_is_tracking_good2:
        :param bool rr_is_muon_good2:
        :param bool rr_is_egamma_good2:
        :param bool rr_is_tau_good2:
        :param bool rr_is_jetmet_good2:
        :param bool rr_is_btag_good2:
        :param float rr_frac_pixel_good2:
        :param float rr_frac_strip_good2:
        :param float rr_frac_ecal_good2:
        :param float rr_frac_hcal_good2:
        :param float rr_frac_dt_good2:
        :param float rr_frac_csc_good2:
        :param float rr_frac_tracking_good2:
        :param float rr_frac_muon_good2:
        :param float rr_frac_egamma_good2:
        :param float rr_frac_tau_good2:
        :param float rr_frac_jetmet_good2:
        :param float rr_frac_btag_good2:
        :param str run: run
        :param str _date: date
        :param str rr_is_pixel_good: rr_is_pixel_good
        :param str rr_is_strip_good: rr_is_strip_good
        :param str rr_is_ecal_good: rr_is_ecal_good
        :param str rr_is_hcal_good: rr_is_hcal_good
        :param str rr_is_dt_good: rr_is_dt_good
        :param str rr_is_csc_good: rr_is_csc_good
        :param str rr_is_tracking_good: rr_is_tracking_good
        :param str rr_is_muon_good: rr_is_muon_good
        :param str rr_is_egamma_good: rr_is_egamma_good
        :param str rr_is_tau_good: rr_is_tau_good
        :param str rr_is_jetmet_good: rr_is_jetmet_good
        :param str rr_is_btag_good: rr_is_btag_good
        :param str rr_frac_pixel_good: rr_frac_pixel_good
        :param str rr_frac_strip_good: rr_frac_strip_good
        :param str rr_frac_ecal_good: rr_frac_ecal_good
        :param str rr_frac_hcal_good: rr_frac_hcal_good
        :param str rr_frac_dt_good: rr_frac_dt_good
        :param str rr_frac_csc_good: rr_frac_csc_good
        :param str rr_frac_tracking_good: rr_frac_tracking_good
        :param str rr_frac_muon_good: rr_frac_muon_good
        :param str rr_frac_egamma_good: rr_frac_egamma_good
        :param str rr_frac_tau_good: rr_frac_tau_good
        :param str rr_frac_jetmet_good: rr_frac_jetmet_good
        :param str rr_frac_btag_good: rr_frac_btag_good
        :return: RunCertification
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'id2', 'run2', '_date2', 'rr_is_pixel_good2', 'rr_is_strip_good2', 'rr_is_ecal_good2', 'rr_is_hcal_good2', 'rr_is_dt_good2', 'rr_is_csc_good2', 'rr_is_tracking_good2', 'rr_is_muon_good2', 'rr_is_egamma_good2', 'rr_is_tau_good2', 'rr_is_jetmet_good2', 'rr_is_btag_good2', 'rr_frac_pixel_good2', 'rr_frac_strip_good2', 'rr_frac_ecal_good2', 'rr_frac_hcal_good2', 'rr_frac_dt_good2', 'rr_frac_csc_good2', 'rr_frac_tracking_good2', 'rr_frac_muon_good2', 'rr_frac_egamma_good2', 'rr_frac_tau_good2', 'rr_frac_jetmet_good2', 'rr_frac_btag_good2', 'id2', 'run2', '_date2', 'rr_is_pixel_good2', 'rr_is_strip_good2', 'rr_is_ecal_good2', 'rr_is_hcal_good2', 'rr_is_dt_good2', 'rr_is_csc_good2', 'rr_is_tracking_good2', 'rr_is_muon_good2', 'rr_is_egamma_good2', 'rr_is_tau_good2', 'rr_is_jetmet_good2', 'rr_is_btag_good2', 'rr_frac_pixel_good2', 'rr_frac_strip_good2', 'rr_frac_ecal_good2', 'rr_frac_hcal_good2', 'rr_frac_dt_good2', 'rr_frac_csc_good2', 'rr_frac_tracking_good2', 'rr_frac_muon_good2', 'rr_frac_egamma_good2', 'rr_frac_tau_good2', 'rr_frac_jetmet_good2', 'rr_frac_btag_good2', 'run', '_date', 'rr_is_pixel_good', 'rr_is_strip_good', 'rr_is_ecal_good', 'rr_is_hcal_good', 'rr_is_dt_good', 'rr_is_csc_good', 'rr_is_tracking_good', 'rr_is_muon_good', 'rr_is_egamma_good', 'rr_is_tau_good', 'rr_is_jetmet_good', 'rr_is_btag_good', 'rr_frac_pixel_good', 'rr_frac_strip_good', 'rr_frac_ecal_good', 'rr_frac_hcal_good', 'rr_frac_dt_good', 'rr_frac_csc_good', 'rr_frac_tracking_good', 'rr_frac_muon_good', 'rr_frac_egamma_good', 'rr_frac_tau_good', 'rr_frac_jetmet_good', 'rr_frac_btag_good']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_run_certification" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_run_certification`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'run' in params:
            query_params.append(('run', params['run']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            query_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            query_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            query_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            query_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            query_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            query_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            query_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            query_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            query_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            query_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            query_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            query_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'rr_frac_pixel_good' in params:
            query_params.append(('rr_frac_pixel_good', params['rr_frac_pixel_good']))  # noqa: E501
        if 'rr_frac_strip_good' in params:
            query_params.append(('rr_frac_strip_good', params['rr_frac_strip_good']))  # noqa: E501
        if 'rr_frac_ecal_good' in params:
            query_params.append(('rr_frac_ecal_good', params['rr_frac_ecal_good']))  # noqa: E501
        if 'rr_frac_hcal_good' in params:
            query_params.append(('rr_frac_hcal_good', params['rr_frac_hcal_good']))  # noqa: E501
        if 'rr_frac_dt_good' in params:
            query_params.append(('rr_frac_dt_good', params['rr_frac_dt_good']))  # noqa: E501
        if 'rr_frac_csc_good' in params:
            query_params.append(('rr_frac_csc_good', params['rr_frac_csc_good']))  # noqa: E501
        if 'rr_frac_tracking_good' in params:
            query_params.append(('rr_frac_tracking_good', params['rr_frac_tracking_good']))  # noqa: E501
        if 'rr_frac_muon_good' in params:
            query_params.append(('rr_frac_muon_good', params['rr_frac_muon_good']))  # noqa: E501
        if 'rr_frac_egamma_good' in params:
            query_params.append(('rr_frac_egamma_good', params['rr_frac_egamma_good']))  # noqa: E501
        if 'rr_frac_tau_good' in params:
            query_params.append(('rr_frac_tau_good', params['rr_frac_tau_good']))  # noqa: E501
        if 'rr_frac_jetmet_good' in params:
            query_params.append(('rr_frac_jetmet_good', params['rr_frac_jetmet_good']))  # noqa: E501
        if 'rr_frac_btag_good' in params:
            query_params.append(('rr_frac_btag_good', params['rr_frac_btag_good']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            form_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            form_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            form_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            form_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            form_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            form_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            form_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            form_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            form_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            form_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            form_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            form_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'rr_frac_pixel_good' in params:
            form_params.append(('rr_frac_pixel_good', params['rr_frac_pixel_good']))  # noqa: E501
        if 'rr_frac_strip_good' in params:
            form_params.append(('rr_frac_strip_good', params['rr_frac_strip_good']))  # noqa: E501
        if 'rr_frac_ecal_good' in params:
            form_params.append(('rr_frac_ecal_good', params['rr_frac_ecal_good']))  # noqa: E501
        if 'rr_frac_hcal_good' in params:
            form_params.append(('rr_frac_hcal_good', params['rr_frac_hcal_good']))  # noqa: E501
        if 'rr_frac_dt_good' in params:
            form_params.append(('rr_frac_dt_good', params['rr_frac_dt_good']))  # noqa: E501
        if 'rr_frac_csc_good' in params:
            form_params.append(('rr_frac_csc_good', params['rr_frac_csc_good']))  # noqa: E501
        if 'rr_frac_tracking_good' in params:
            form_params.append(('rr_frac_tracking_good', params['rr_frac_tracking_good']))  # noqa: E501
        if 'rr_frac_muon_good' in params:
            form_params.append(('rr_frac_muon_good', params['rr_frac_muon_good']))  # noqa: E501
        if 'rr_frac_egamma_good' in params:
            form_params.append(('rr_frac_egamma_good', params['rr_frac_egamma_good']))  # noqa: E501
        if 'rr_frac_tau_good' in params:
            form_params.append(('rr_frac_tau_good', params['rr_frac_tau_good']))  # noqa: E501
        if 'rr_frac_jetmet_good' in params:
            form_params.append(('rr_frac_jetmet_good', params['rr_frac_jetmet_good']))  # noqa: E501
        if 'rr_frac_btag_good' in params:
            form_params.append(('rr_frac_btag_good', params['rr_frac_btag_good']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if '_date' in params:
            form_params.append(('date', params['_date']))  # noqa: E501
        if 'rr_is_pixel_good' in params:
            form_params.append(('rr_is_pixel_good', params['rr_is_pixel_good']))  # noqa: E501
        if 'rr_is_strip_good' in params:
            form_params.append(('rr_is_strip_good', params['rr_is_strip_good']))  # noqa: E501
        if 'rr_is_ecal_good' in params:
            form_params.append(('rr_is_ecal_good', params['rr_is_ecal_good']))  # noqa: E501
        if 'rr_is_hcal_good' in params:
            form_params.append(('rr_is_hcal_good', params['rr_is_hcal_good']))  # noqa: E501
        if 'rr_is_dt_good' in params:
            form_params.append(('rr_is_dt_good', params['rr_is_dt_good']))  # noqa: E501
        if 'rr_is_csc_good' in params:
            form_params.append(('rr_is_csc_good', params['rr_is_csc_good']))  # noqa: E501
        if 'rr_is_tracking_good' in params:
            form_params.append(('rr_is_tracking_good', params['rr_is_tracking_good']))  # noqa: E501
        if 'rr_is_muon_good' in params:
            form_params.append(('rr_is_muon_good', params['rr_is_muon_good']))  # noqa: E501
        if 'rr_is_egamma_good' in params:
            form_params.append(('rr_is_egamma_good', params['rr_is_egamma_good']))  # noqa: E501
        if 'rr_is_tau_good' in params:
            form_params.append(('rr_is_tau_good', params['rr_is_tau_good']))  # noqa: E501
        if 'rr_is_jetmet_good' in params:
            form_params.append(('rr_is_jetmet_good', params['rr_is_jetmet_good']))  # noqa: E501
        if 'rr_is_btag_good' in params:
            form_params.append(('rr_is_btag_good', params['rr_is_btag_good']))  # noqa: E501
        if 'rr_frac_pixel_good' in params:
            form_params.append(('rr_frac_pixel_good', params['rr_frac_pixel_good']))  # noqa: E501
        if 'rr_frac_strip_good' in params:
            form_params.append(('rr_frac_strip_good', params['rr_frac_strip_good']))  # noqa: E501
        if 'rr_frac_ecal_good' in params:
            form_params.append(('rr_frac_ecal_good', params['rr_frac_ecal_good']))  # noqa: E501
        if 'rr_frac_hcal_good' in params:
            form_params.append(('rr_frac_hcal_good', params['rr_frac_hcal_good']))  # noqa: E501
        if 'rr_frac_dt_good' in params:
            form_params.append(('rr_frac_dt_good', params['rr_frac_dt_good']))  # noqa: E501
        if 'rr_frac_csc_good' in params:
            form_params.append(('rr_frac_csc_good', params['rr_frac_csc_good']))  # noqa: E501
        if 'rr_frac_tracking_good' in params:
            form_params.append(('rr_frac_tracking_good', params['rr_frac_tracking_good']))  # noqa: E501
        if 'rr_frac_muon_good' in params:
            form_params.append(('rr_frac_muon_good', params['rr_frac_muon_good']))  # noqa: E501
        if 'rr_frac_egamma_good' in params:
            form_params.append(('rr_frac_egamma_good', params['rr_frac_egamma_good']))  # noqa: E501
        if 'rr_frac_tau_good' in params:
            form_params.append(('rr_frac_tau_good', params['rr_frac_tau_good']))  # noqa: E501
        if 'rr_frac_jetmet_good' in params:
            form_params.append(('rr_frac_jetmet_good', params['rr_frac_jetmet_good']))  # noqa: E501
        if 'rr_frac_btag_good' in params:
            form_params.append(('rr_frac_btag_good', params['rr_frac_btag_good']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/run_certifications/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RunCertification',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_run_histogram(self, id, **kwargs):  # noqa: E501
        """update_run_histogram  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_run_histogram(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this run histogram. (required)
        :param RunHistogram body:
        :param str run__run_number__gte: run__run_number__gte
        :param str run__run_number__lte: run__run_number__lte
        :param str run__run_number: run__run_number
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str mean: mean
        :param str mean__gte: mean__gte
        :param str mean__lte: mean__lte
        :param str rms: rms
        :param str rms__gte: rms__gte
        :param str rms__lte: rms__lte
        :param str skewness: skewness
        :param str skewness__gte: skewness__gte
        :param str skewness__lte: skewness__lte
        :param str kurtosis: kurtosis
        :param str kurtosis__gte: kurtosis__gte
        :param str kurtosis__lte: kurtosis__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str primary_dataset: primary_dataset
        :param str run__run_number__in: run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: RunHistogram
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_run_histogram_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_run_histogram_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_run_histogram_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_run_histogram  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_run_histogram_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this run histogram. (required)
        :param RunHistogram body:
        :param str run__run_number__gte: run__run_number__gte
        :param str run__run_number__lte: run__run_number__lte
        :param str run__run_number: run__run_number
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str mean: mean
        :param str mean__gte: mean__gte
        :param str mean__lte: mean__lte
        :param str rms: rms
        :param str rms__gte: rms__gte
        :param str rms__lte: rms__lte
        :param str skewness: skewness
        :param str skewness__gte: skewness__gte
        :param str skewness__lte: skewness__lte
        :param str kurtosis: kurtosis
        :param str kurtosis__gte: kurtosis__gte
        :param str kurtosis__lte: kurtosis__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str primary_dataset: primary_dataset
        :param str run__run_number__in: run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: RunHistogram
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'run__run_number__gte', 'run__run_number__lte', 'run__run_number', 'entries__gte', 'entries__lte', 'mean', 'mean__gte', 'mean__lte', 'rms', 'rms__gte', 'rms__lte', 'skewness', 'skewness__gte', 'skewness__lte', 'kurtosis', 'kurtosis__gte', 'kurtosis__lte', 'source_data_file', 'title', 'primary_dataset', 'run__run_number__in', 'source_data_file__filepath__contains']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_run_histogram" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_run_histogram`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'run__run_number__gte' in params:
            query_params.append(('run__run_number__gte', params['run__run_number__gte']))  # noqa: E501
        if 'run__run_number__lte' in params:
            query_params.append(('run__run_number__lte', params['run__run_number__lte']))  # noqa: E501
        if 'run__run_number' in params:
            query_params.append(('run__run_number', params['run__run_number']))  # noqa: E501
        if 'entries__gte' in params:
            query_params.append(('entries__gte', params['entries__gte']))  # noqa: E501
        if 'entries__lte' in params:
            query_params.append(('entries__lte', params['entries__lte']))  # noqa: E501
        if 'mean' in params:
            query_params.append(('mean', params['mean']))  # noqa: E501
        if 'mean__gte' in params:
            query_params.append(('mean__gte', params['mean__gte']))  # noqa: E501
        if 'mean__lte' in params:
            query_params.append(('mean__lte', params['mean__lte']))  # noqa: E501
        if 'rms' in params:
            query_params.append(('rms', params['rms']))  # noqa: E501
        if 'rms__gte' in params:
            query_params.append(('rms__gte', params['rms__gte']))  # noqa: E501
        if 'rms__lte' in params:
            query_params.append(('rms__lte', params['rms__lte']))  # noqa: E501
        if 'skewness' in params:
            query_params.append(('skewness', params['skewness']))  # noqa: E501
        if 'skewness__gte' in params:
            query_params.append(('skewness__gte', params['skewness__gte']))  # noqa: E501
        if 'skewness__lte' in params:
            query_params.append(('skewness__lte', params['skewness__lte']))  # noqa: E501
        if 'kurtosis' in params:
            query_params.append(('kurtosis', params['kurtosis']))  # noqa: E501
        if 'kurtosis__gte' in params:
            query_params.append(('kurtosis__gte', params['kurtosis__gte']))  # noqa: E501
        if 'kurtosis__lte' in params:
            query_params.append(('kurtosis__lte', params['kurtosis__lte']))  # noqa: E501
        if 'source_data_file' in params:
            query_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'title' in params:
            query_params.append(('title', params['title']))  # noqa: E501
        if 'primary_dataset' in params:
            query_params.append(('primary_dataset', params['primary_dataset']))  # noqa: E501
        if 'run__run_number__in' in params:
            query_params.append(('run__run_number__in', params['run__run_number__in']))  # noqa: E501
        if 'source_data_file__filepath__contains' in params:
            query_params.append(('source_data_file__filepath__contains', params['source_data_file__filepath__contains']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'primary_dataset' in params:
            form_params.append(('primary_dataset', params['primary_dataset']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'mean' in params:
            form_params.append(('mean', params['mean']))  # noqa: E501
        if 'rms' in params:
            form_params.append(('rms', params['rms']))  # noqa: E501
        if 'skewness' in params:
            form_params.append(('skewness', params['skewness']))  # noqa: E501
        if 'kurtosis' in params:
            form_params.append(('kurtosis', params['kurtosis']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'primary_dataset' in params:
            form_params.append(('primary_dataset', params['primary_dataset']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'mean' in params:
            form_params.append(('mean', params['mean']))  # noqa: E501
        if 'rms' in params:
            form_params.append(('rms', params['rms']))  # noqa: E501
        if 'skewness' in params:
            form_params.append(('skewness', params['skewness']))  # noqa: E501
        if 'kurtosis' in params:
            form_params.append(('kurtosis', params['kurtosis']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/run_histograms/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RunHistogram',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_run_histogram(self, id, **kwargs):  # noqa: E501
        """update_run_histogram  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_run_histogram(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this run histogram. (required)
        :param int id2:
        :param int run2:
        :param str title2:
        :param str primary_dataset2:
        :param int entries2:
        :param float mean2:
        :param float rms2:
        :param float skewness2:
        :param float kurtosis2:
        :param int source_data_file2:
        :param int id2:
        :param int run:
        :param str title2:
        :param str primary_dataset2:
        :param int entries:
        :param float mean2:
        :param float rms2:
        :param float skewness2:
        :param float kurtosis2:
        :param int source_data_file2:
        :param str run__run_number__gte: run__run_number__gte
        :param str run__run_number__lte: run__run_number__lte
        :param str run__run_number: run__run_number
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str mean: mean
        :param str mean__gte: mean__gte
        :param str mean__lte: mean__lte
        :param str rms: rms
        :param str rms__gte: rms__gte
        :param str rms__lte: rms__lte
        :param str skewness: skewness
        :param str skewness__gte: skewness__gte
        :param str skewness__lte: skewness__lte
        :param str kurtosis: kurtosis
        :param str kurtosis__gte: kurtosis__gte
        :param str kurtosis__lte: kurtosis__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str primary_dataset: primary_dataset
        :param str run__run_number__in: run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: RunHistogram
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_run_histogram_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_run_histogram_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_run_histogram_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_run_histogram  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_run_histogram_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this run histogram. (required)
        :param int id2:
        :param int run2:
        :param str title2:
        :param str primary_dataset2:
        :param int entries2:
        :param float mean2:
        :param float rms2:
        :param float skewness2:
        :param float kurtosis2:
        :param int source_data_file2:
        :param int id2:
        :param int run:
        :param str title2:
        :param str primary_dataset2:
        :param int entries:
        :param float mean2:
        :param float rms2:
        :param float skewness2:
        :param float kurtosis2:
        :param int source_data_file2:
        :param str run__run_number__gte: run__run_number__gte
        :param str run__run_number__lte: run__run_number__lte
        :param str run__run_number: run__run_number
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str mean: mean
        :param str mean__gte: mean__gte
        :param str mean__lte: mean__lte
        :param str rms: rms
        :param str rms__gte: rms__gte
        :param str rms__lte: rms__lte
        :param str skewness: skewness
        :param str skewness__gte: skewness__gte
        :param str skewness__lte: skewness__lte
        :param str kurtosis: kurtosis
        :param str kurtosis__gte: kurtosis__gte
        :param str kurtosis__lte: kurtosis__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str primary_dataset: primary_dataset
        :param str run__run_number__in: run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: RunHistogram
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'id2', 'run2', 'title2', 'primary_dataset2', 'entries2', 'mean2', 'rms2', 'skewness2', 'kurtosis2', 'source_data_file2', 'id2', 'run', 'title2', 'primary_dataset2', 'entries', 'mean2', 'rms2', 'skewness2', 'kurtosis2', 'source_data_file2', 'run__run_number__gte', 'run__run_number__lte', 'run__run_number', 'entries__gte', 'entries__lte', 'mean', 'mean__gte', 'mean__lte', 'rms', 'rms__gte', 'rms__lte', 'skewness', 'skewness__gte', 'skewness__lte', 'kurtosis', 'kurtosis__gte', 'kurtosis__lte', 'source_data_file', 'title', 'primary_dataset', 'run__run_number__in', 'source_data_file__filepath__contains']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_run_histogram" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_run_histogram`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'run__run_number__gte' in params:
            query_params.append(('run__run_number__gte', params['run__run_number__gte']))  # noqa: E501
        if 'run__run_number__lte' in params:
            query_params.append(('run__run_number__lte', params['run__run_number__lte']))  # noqa: E501
        if 'run__run_number' in params:
            query_params.append(('run__run_number', params['run__run_number']))  # noqa: E501
        if 'entries__gte' in params:
            query_params.append(('entries__gte', params['entries__gte']))  # noqa: E501
        if 'entries__lte' in params:
            query_params.append(('entries__lte', params['entries__lte']))  # noqa: E501
        if 'mean' in params:
            query_params.append(('mean', params['mean']))  # noqa: E501
        if 'mean__gte' in params:
            query_params.append(('mean__gte', params['mean__gte']))  # noqa: E501
        if 'mean__lte' in params:
            query_params.append(('mean__lte', params['mean__lte']))  # noqa: E501
        if 'rms' in params:
            query_params.append(('rms', params['rms']))  # noqa: E501
        if 'rms__gte' in params:
            query_params.append(('rms__gte', params['rms__gte']))  # noqa: E501
        if 'rms__lte' in params:
            query_params.append(('rms__lte', params['rms__lte']))  # noqa: E501
        if 'skewness' in params:
            query_params.append(('skewness', params['skewness']))  # noqa: E501
        if 'skewness__gte' in params:
            query_params.append(('skewness__gte', params['skewness__gte']))  # noqa: E501
        if 'skewness__lte' in params:
            query_params.append(('skewness__lte', params['skewness__lte']))  # noqa: E501
        if 'kurtosis' in params:
            query_params.append(('kurtosis', params['kurtosis']))  # noqa: E501
        if 'kurtosis__gte' in params:
            query_params.append(('kurtosis__gte', params['kurtosis__gte']))  # noqa: E501
        if 'kurtosis__lte' in params:
            query_params.append(('kurtosis__lte', params['kurtosis__lte']))  # noqa: E501
        if 'source_data_file' in params:
            query_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'title' in params:
            query_params.append(('title', params['title']))  # noqa: E501
        if 'primary_dataset' in params:
            query_params.append(('primary_dataset', params['primary_dataset']))  # noqa: E501
        if 'run__run_number__in' in params:
            query_params.append(('run__run_number__in', params['run__run_number__in']))  # noqa: E501
        if 'source_data_file__filepath__contains' in params:
            query_params.append(('source_data_file__filepath__contains', params['source_data_file__filepath__contains']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'primary_dataset' in params:
            form_params.append(('primary_dataset', params['primary_dataset']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'mean' in params:
            form_params.append(('mean', params['mean']))  # noqa: E501
        if 'rms' in params:
            form_params.append(('rms', params['rms']))  # noqa: E501
        if 'skewness' in params:
            form_params.append(('skewness', params['skewness']))  # noqa: E501
        if 'kurtosis' in params:
            form_params.append(('kurtosis', params['kurtosis']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'primary_dataset' in params:
            form_params.append(('primary_dataset', params['primary_dataset']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'mean' in params:
            form_params.append(('mean', params['mean']))  # noqa: E501
        if 'rms' in params:
            form_params.append(('rms', params['rms']))  # noqa: E501
        if 'skewness' in params:
            form_params.append(('skewness', params['skewness']))  # noqa: E501
        if 'kurtosis' in params:
            form_params.append(('kurtosis', params['kurtosis']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/run_histograms/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RunHistogram',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_run_histogram(self, id, **kwargs):  # noqa: E501
        """update_run_histogram  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_run_histogram(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this run histogram. (required)
        :param int id2:
        :param int run2:
        :param str title2:
        :param str primary_dataset2:
        :param int entries2:
        :param float mean2:
        :param float rms2:
        :param float skewness2:
        :param float kurtosis2:
        :param int source_data_file2:
        :param int id2:
        :param int run:
        :param str title2:
        :param str primary_dataset2:
        :param int entries:
        :param float mean2:
        :param float rms2:
        :param float skewness2:
        :param float kurtosis2:
        :param int source_data_file2:
        :param str run__run_number__gte: run__run_number__gte
        :param str run__run_number__lte: run__run_number__lte
        :param str run__run_number: run__run_number
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str mean: mean
        :param str mean__gte: mean__gte
        :param str mean__lte: mean__lte
        :param str rms: rms
        :param str rms__gte: rms__gte
        :param str rms__lte: rms__lte
        :param str skewness: skewness
        :param str skewness__gte: skewness__gte
        :param str skewness__lte: skewness__lte
        :param str kurtosis: kurtosis
        :param str kurtosis__gte: kurtosis__gte
        :param str kurtosis__lte: kurtosis__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str primary_dataset: primary_dataset
        :param str run__run_number__in: run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: RunHistogram
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_run_histogram_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_run_histogram_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_run_histogram_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_run_histogram  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_run_histogram_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this run histogram. (required)
        :param int id2:
        :param int run2:
        :param str title2:
        :param str primary_dataset2:
        :param int entries2:
        :param float mean2:
        :param float rms2:
        :param float skewness2:
        :param float kurtosis2:
        :param int source_data_file2:
        :param int id2:
        :param int run:
        :param str title2:
        :param str primary_dataset2:
        :param int entries:
        :param float mean2:
        :param float rms2:
        :param float skewness2:
        :param float kurtosis2:
        :param int source_data_file2:
        :param str run__run_number__gte: run__run_number__gte
        :param str run__run_number__lte: run__run_number__lte
        :param str run__run_number: run__run_number
        :param str entries__gte: entries__gte
        :param str entries__lte: entries__lte
        :param str mean: mean
        :param str mean__gte: mean__gte
        :param str mean__lte: mean__lte
        :param str rms: rms
        :param str rms__gte: rms__gte
        :param str rms__lte: rms__lte
        :param str skewness: skewness
        :param str skewness__gte: skewness__gte
        :param str skewness__lte: skewness__lte
        :param str kurtosis: kurtosis
        :param str kurtosis__gte: kurtosis__gte
        :param str kurtosis__lte: kurtosis__lte
        :param str source_data_file: source_data_file
        :param str title: title
        :param str primary_dataset: primary_dataset
        :param str run__run_number__in: run__run_number__in
        :param str source_data_file__filepath__contains: source_data_file__filepath__contains
        :return: RunHistogram
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'id2', 'run2', 'title2', 'primary_dataset2', 'entries2', 'mean2', 'rms2', 'skewness2', 'kurtosis2', 'source_data_file2', 'id2', 'run', 'title2', 'primary_dataset2', 'entries', 'mean2', 'rms2', 'skewness2', 'kurtosis2', 'source_data_file2', 'run__run_number__gte', 'run__run_number__lte', 'run__run_number', 'entries__gte', 'entries__lte', 'mean', 'mean__gte', 'mean__lte', 'rms', 'rms__gte', 'rms__lte', 'skewness', 'skewness__gte', 'skewness__lte', 'kurtosis', 'kurtosis__gte', 'kurtosis__lte', 'source_data_file', 'title', 'primary_dataset', 'run__run_number__in', 'source_data_file__filepath__contains']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_run_histogram" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_run_histogram`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'run__run_number__gte' in params:
            query_params.append(('run__run_number__gte', params['run__run_number__gte']))  # noqa: E501
        if 'run__run_number__lte' in params:
            query_params.append(('run__run_number__lte', params['run__run_number__lte']))  # noqa: E501
        if 'run__run_number' in params:
            query_params.append(('run__run_number', params['run__run_number']))  # noqa: E501
        if 'entries__gte' in params:
            query_params.append(('entries__gte', params['entries__gte']))  # noqa: E501
        if 'entries__lte' in params:
            query_params.append(('entries__lte', params['entries__lte']))  # noqa: E501
        if 'mean' in params:
            query_params.append(('mean', params['mean']))  # noqa: E501
        if 'mean__gte' in params:
            query_params.append(('mean__gte', params['mean__gte']))  # noqa: E501
        if 'mean__lte' in params:
            query_params.append(('mean__lte', params['mean__lte']))  # noqa: E501
        if 'rms' in params:
            query_params.append(('rms', params['rms']))  # noqa: E501
        if 'rms__gte' in params:
            query_params.append(('rms__gte', params['rms__gte']))  # noqa: E501
        if 'rms__lte' in params:
            query_params.append(('rms__lte', params['rms__lte']))  # noqa: E501
        if 'skewness' in params:
            query_params.append(('skewness', params['skewness']))  # noqa: E501
        if 'skewness__gte' in params:
            query_params.append(('skewness__gte', params['skewness__gte']))  # noqa: E501
        if 'skewness__lte' in params:
            query_params.append(('skewness__lte', params['skewness__lte']))  # noqa: E501
        if 'kurtosis' in params:
            query_params.append(('kurtosis', params['kurtosis']))  # noqa: E501
        if 'kurtosis__gte' in params:
            query_params.append(('kurtosis__gte', params['kurtosis__gte']))  # noqa: E501
        if 'kurtosis__lte' in params:
            query_params.append(('kurtosis__lte', params['kurtosis__lte']))  # noqa: E501
        if 'source_data_file' in params:
            query_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'title' in params:
            query_params.append(('title', params['title']))  # noqa: E501
        if 'primary_dataset' in params:
            query_params.append(('primary_dataset', params['primary_dataset']))  # noqa: E501
        if 'run__run_number__in' in params:
            query_params.append(('run__run_number__in', params['run__run_number__in']))  # noqa: E501
        if 'source_data_file__filepath__contains' in params:
            query_params.append(('source_data_file__filepath__contains', params['source_data_file__filepath__contains']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'primary_dataset' in params:
            form_params.append(('primary_dataset', params['primary_dataset']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'mean' in params:
            form_params.append(('mean', params['mean']))  # noqa: E501
        if 'rms' in params:
            form_params.append(('rms', params['rms']))  # noqa: E501
        if 'skewness' in params:
            form_params.append(('skewness', params['skewness']))  # noqa: E501
        if 'kurtosis' in params:
            form_params.append(('kurtosis', params['kurtosis']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'run' in params:
            form_params.append(('run', params['run']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'primary_dataset' in params:
            form_params.append(('primary_dataset', params['primary_dataset']))  # noqa: E501
        if 'entries' in params:
            form_params.append(('entries', params['entries']))  # noqa: E501
        if 'mean' in params:
            form_params.append(('mean', params['mean']))  # noqa: E501
        if 'rms' in params:
            form_params.append(('rms', params['rms']))  # noqa: E501
        if 'skewness' in params:
            form_params.append(('skewness', params['skewness']))  # noqa: E501
        if 'kurtosis' in params:
            form_params.append(('kurtosis', params['kurtosis']))  # noqa: E501
        if 'source_data_file' in params:
            form_params.append(('source_data_file', params['source_data_file']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/run_histograms/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RunHistogram',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_strategy(self, id, **kwargs):  # noqa: E501
        """update_strategy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_strategy(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this strategy. (required)
        :param Strategy body:
        :return: Strategy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_strategy_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_strategy_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_strategy_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_strategy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_strategy_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this strategy. (required)
        :param Strategy body:
        :return: Strategy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_strategy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_strategy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'model' in params:
            form_params.append(('model', params['model']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'model' in params:
            form_params.append(('model', params['model']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/strategies/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Strategy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_strategy(self, id, **kwargs):  # noqa: E501
        """update_strategy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_strategy(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this strategy. (required)
        :param int id2:
        :param str model2:
        :param int id2:
        :param str model:
        :return: Strategy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_strategy_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_strategy_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_strategy_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_strategy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_strategy_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this strategy. (required)
        :param int id2:
        :param str model2:
        :param int id2:
        :param str model:
        :return: Strategy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'id2', 'model2', 'id2', 'model']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_strategy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_strategy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'model' in params:
            form_params.append(('model', params['model']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'model' in params:
            form_params.append(('model', params['model']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/strategies/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Strategy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_strategy(self, id, **kwargs):  # noqa: E501
        """update_strategy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_strategy(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this strategy. (required)
        :param int id2:
        :param str model2:
        :param int id2:
        :param str model:
        :return: Strategy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_strategy_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_strategy_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_strategy_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_strategy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_strategy_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this strategy. (required)
        :param int id2:
        :param str model2:
        :param int id2:
        :param str model:
        :return: Strategy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'id2', 'model2', 'id2', 'model']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_strategy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_strategy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'model' in params:
            form_params.append(('model', params['model']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'model' in params:
            form_params.append(('model', params['model']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/strategies/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Strategy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_task(self, id, **kwargs):  # noqa: E501
        """update_task  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_task(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this task. (required)
        :param Task body:
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_task_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_task_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_task_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_task  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_task_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this task. (required)
        :param Task body:
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'training_runs' in params:
            form_params.append(('training_runs', params['training_runs']))  # noqa: E501
            collection_formats['training_runs'] = 'multi'  # noqa: E501
        if 'testing_runs' in params:
            form_params.append(('testing_runs', params['testing_runs']))  # noqa: E501
            collection_formats['testing_runs'] = 'multi'  # noqa: E501
        if 'training_lumisections' in params:
            form_params.append(('training_lumisections', params['training_lumisections']))  # noqa: E501
            collection_formats['training_lumisections'] = 'multi'  # noqa: E501
        if 'testing_lumisections' in params:
            form_params.append(('testing_lumisections', params['testing_lumisections']))  # noqa: E501
            collection_formats['testing_lumisections'] = 'multi'  # noqa: E501
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'metadata' in params:
            form_params.append(('metadata', params['metadata']))  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'training_runs' in params:
            form_params.append(('training_runs', params['training_runs']))  # noqa: E501
            collection_formats['training_runs'] = 'multi'  # noqa: E501
        if 'testing_runs' in params:
            form_params.append(('testing_runs', params['testing_runs']))  # noqa: E501
            collection_formats['testing_runs'] = 'multi'  # noqa: E501
        if 'training_lumisections' in params:
            form_params.append(('training_lumisections', params['training_lumisections']))  # noqa: E501
            collection_formats['training_lumisections'] = 'multi'  # noqa: E501
        if 'testing_lumisections' in params:
            form_params.append(('testing_lumisections', params['testing_lumisections']))  # noqa: E501
            collection_formats['testing_lumisections'] = 'multi'  # noqa: E501
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'metadata' in params:
            form_params.append(('metadata', params['metadata']))  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/tasks/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Task',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_task(self, id, **kwargs):  # noqa: E501
        """update_task  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_task(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this task. (required)
        :param int id2:
        :param list[TaskTrainingRuns] training_runs2:
        :param list[TaskTrainingRuns] testing_runs2:
        :param list[TaskTrainingLumisections] training_lumisections2:
        :param list[TaskTrainingLumisections] testing_lumisections2:
        :param str name2:
        :param str metadata2:
        :param datetime created2:
        :param datetime modified2:
        :param int id2:
        :param list[TaskTrainingRuns] training_runs:
        :param list[TaskTrainingRuns] testing_runs:
        :param list[TaskTrainingLumisections] training_lumisections:
        :param list[TaskTrainingLumisections] testing_lumisections:
        :param str name:
        :param str metadata:
        :param datetime created:
        :param datetime modified:
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_task_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_task_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_task_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_task  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_task_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this task. (required)
        :param int id2:
        :param list[TaskTrainingRuns] training_runs2:
        :param list[TaskTrainingRuns] testing_runs2:
        :param list[TaskTrainingLumisections] training_lumisections2:
        :param list[TaskTrainingLumisections] testing_lumisections2:
        :param str name2:
        :param str metadata2:
        :param datetime created2:
        :param datetime modified2:
        :param int id2:
        :param list[TaskTrainingRuns] training_runs:
        :param list[TaskTrainingRuns] testing_runs:
        :param list[TaskTrainingLumisections] training_lumisections:
        :param list[TaskTrainingLumisections] testing_lumisections:
        :param str name:
        :param str metadata:
        :param datetime created:
        :param datetime modified:
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'id2', 'training_runs2', 'testing_runs2', 'training_lumisections2', 'testing_lumisections2', 'name2', 'metadata2', 'created2', 'modified2', 'id2', 'training_runs', 'testing_runs', 'training_lumisections', 'testing_lumisections', 'name', 'metadata', 'created', 'modified']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'training_runs' in params:
            form_params.append(('training_runs', params['training_runs']))  # noqa: E501
            collection_formats['training_runs'] = 'multi'  # noqa: E501
        if 'testing_runs' in params:
            form_params.append(('testing_runs', params['testing_runs']))  # noqa: E501
            collection_formats['testing_runs'] = 'multi'  # noqa: E501
        if 'training_lumisections' in params:
            form_params.append(('training_lumisections', params['training_lumisections']))  # noqa: E501
            collection_formats['training_lumisections'] = 'multi'  # noqa: E501
        if 'testing_lumisections' in params:
            form_params.append(('testing_lumisections', params['testing_lumisections']))  # noqa: E501
            collection_formats['testing_lumisections'] = 'multi'  # noqa: E501
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'metadata' in params:
            form_params.append(('metadata', params['metadata']))  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'training_runs' in params:
            form_params.append(('training_runs', params['training_runs']))  # noqa: E501
            collection_formats['training_runs'] = 'multi'  # noqa: E501
        if 'testing_runs' in params:
            form_params.append(('testing_runs', params['testing_runs']))  # noqa: E501
            collection_formats['testing_runs'] = 'multi'  # noqa: E501
        if 'training_lumisections' in params:
            form_params.append(('training_lumisections', params['training_lumisections']))  # noqa: E501
            collection_formats['training_lumisections'] = 'multi'  # noqa: E501
        if 'testing_lumisections' in params:
            form_params.append(('testing_lumisections', params['testing_lumisections']))  # noqa: E501
            collection_formats['testing_lumisections'] = 'multi'  # noqa: E501
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'metadata' in params:
            form_params.append(('metadata', params['metadata']))  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/tasks/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Task',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_task(self, id, **kwargs):  # noqa: E501
        """update_task  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_task(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this task. (required)
        :param int id2:
        :param list[TaskTrainingRuns] training_runs2:
        :param list[TaskTrainingRuns] testing_runs2:
        :param list[TaskTrainingLumisections] training_lumisections2:
        :param list[TaskTrainingLumisections] testing_lumisections2:
        :param str name2:
        :param str metadata2:
        :param datetime created2:
        :param datetime modified2:
        :param int id2:
        :param list[TaskTrainingRuns] training_runs:
        :param list[TaskTrainingRuns] testing_runs:
        :param list[TaskTrainingLumisections] training_lumisections:
        :param list[TaskTrainingLumisections] testing_lumisections:
        :param str name:
        :param str metadata:
        :param datetime created:
        :param datetime modified:
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_task_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_task_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_task_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_task  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_task_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this task. (required)
        :param int id2:
        :param list[TaskTrainingRuns] training_runs2:
        :param list[TaskTrainingRuns] testing_runs2:
        :param list[TaskTrainingLumisections] training_lumisections2:
        :param list[TaskTrainingLumisections] testing_lumisections2:
        :param str name2:
        :param str metadata2:
        :param datetime created2:
        :param datetime modified2:
        :param int id2:
        :param list[TaskTrainingRuns] training_runs:
        :param list[TaskTrainingRuns] testing_runs:
        :param list[TaskTrainingLumisections] training_lumisections:
        :param list[TaskTrainingLumisections] testing_lumisections:
        :param str name:
        :param str metadata:
        :param datetime created:
        :param datetime modified:
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'id2', 'training_runs2', 'testing_runs2', 'training_lumisections2', 'testing_lumisections2', 'name2', 'metadata2', 'created2', 'modified2', 'id2', 'training_runs', 'testing_runs', 'training_lumisections', 'testing_lumisections', 'name', 'metadata', 'created', 'modified']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'training_runs' in params:
            form_params.append(('training_runs', params['training_runs']))  # noqa: E501
            collection_formats['training_runs'] = 'multi'  # noqa: E501
        if 'testing_runs' in params:
            form_params.append(('testing_runs', params['testing_runs']))  # noqa: E501
            collection_formats['testing_runs'] = 'multi'  # noqa: E501
        if 'training_lumisections' in params:
            form_params.append(('training_lumisections', params['training_lumisections']))  # noqa: E501
            collection_formats['training_lumisections'] = 'multi'  # noqa: E501
        if 'testing_lumisections' in params:
            form_params.append(('testing_lumisections', params['testing_lumisections']))  # noqa: E501
            collection_formats['testing_lumisections'] = 'multi'  # noqa: E501
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'metadata' in params:
            form_params.append(('metadata', params['metadata']))  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'training_runs' in params:
            form_params.append(('training_runs', params['training_runs']))  # noqa: E501
            collection_formats['training_runs'] = 'multi'  # noqa: E501
        if 'testing_runs' in params:
            form_params.append(('testing_runs', params['testing_runs']))  # noqa: E501
            collection_formats['testing_runs'] = 'multi'  # noqa: E501
        if 'training_lumisections' in params:
            form_params.append(('training_lumisections', params['training_lumisections']))  # noqa: E501
            collection_formats['training_lumisections'] = 'multi'  # noqa: E501
        if 'testing_lumisections' in params:
            form_params.append(('testing_lumisections', params['testing_lumisections']))  # noqa: E501
            collection_formats['testing_lumisections'] = 'multi'  # noqa: E501
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'metadata' in params:
            form_params.append(('metadata', params['metadata']))  # noqa: E501
        if 'created' in params:
            form_params.append(('created', params['created']))  # noqa: E501
        if 'modified' in params:
            form_params.append(('modified', params['modified']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/tasks/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Task',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
